---
stitle: "Untitled"
author: "Sarah Tennant"
date: "24/05/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


### Can LM predict firing rate accurately on other part of track?


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


# Classify neurons based on activity on outbound and homebound
```{r}
mark_predict_group <- function(outbound, homebound){

  if(outbound == "Positive" & homebound == "Negative") {
    return( "posneg" ) 
  } else if(outbound == "Positive" & homebound == "Positive") {
    return( "pospos" )
  } else if(outbound == "Negative" & homebound == "Positive") {
    return( "negpos" )
  } else if(outbound == "Negative" & homebound == "Negative") {
    return( "negneg" )
  } else if(outbound == "Positive" & homebound == "None") {
    return( "posnon" )
  } else if(outbound == "Negative" & homebound == "None") {
    return( "negnon" )
  } else {
    return("None")
  }
}


spatial_firing <- spatial_firing %>%
  mutate( predict_id_p = map2(lm_result_o_rewarded_p, lm_result_h_p, mark_predict_group))

```


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###

## Calculate whether neurons reset or continue across outbound and homebound

1. Normalise firing rate
2. Run on all cells
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_p = map(Rates_averaged_p, normalise_rates))

```

## Predict firing rate in hombound region based on fit from real data in outbound region

1. make function to predict firing rate

```{r}
lm_predict <- function(df){
  new.data <- data.frame(Position =df$Position)
}
```

2. Calculate mean apsolute difference between predicted and real fits in the first 5 cm of homebound zone

```{r}

lm_predict_mse_homebound <- function(rate){
  if(all(is.na(rate))) 
    return(NA)
  startbins=c(30:90)
  df <- tibble(Rates = unlist(rate), Position=rep(1:200))

  lmer <- lm(Rates ~ Position, data = df[startbins,])
  
  df_homebound <- df %>% filter(between(Position, 110, 115))
  new.data <- lm_predict(df_homebound)
  Rates <- predict(lmer, newdata = new.data)
  mydata <- cbind(new.data, Rates)
  
  mean( df_homebound$Rates - mydata$Rate, na.rm=TRUE)

}

spatial_firing <- spatial_firing %>%
  mutate(predict_mean_p = map(normalised_rates_p, lm_predict_mse_homebound)) 
  
```

3. Classify neurons based on apsolute difference between predicted and real as either "Continuous" or "Reset"

```{r}
mark_color <- function(df, id){
  if (is.na(df) ) {
    return( "None" )
  } else if( id == "posneg" | id == "negpos") {
    return( "Switch" ) 
  } else if( (df > -1 & df < 1) & (id == "pospos" | id == "negneg")) {
    return( "Continuous" )
  } else if( (df <= -1 | df >= 1) & (id == "pospos" | id == "negneg")) {
    return( "Reset" ) 
    } else {
    return("None")
  }
}

spatial_firing <- spatial_firing %>%
  mutate(color_predict_p = map2(predict_mean_p, predict_id_p, mark_color))

```

4. Calculate number of neurons that are in each group as classified above
```{r}
path_integrating_neurons <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")

#path_integrating_neurons <- subset(spatial_firing, lm_result_o_rewarded_p == "Positive" | lm_result_o_rewarded_p == "Negative")

all <- nrow(subset(spatial_firing, lm_result_o_rewarded_p == "Negative" | lm_result_o_rewarded_p == "Positive")) # all neurons that are conciderd ramp like on probe trials
switchers <- nrow(subset(path_integrating_neurons, color_predict_p == "Switch")) # cells that switch slope 
reset_p <-nrow(subset(path_integrating_neurons, color_predict_p == "Reset"))
continuous_p <-nrow(subset(path_integrating_neurons, color_predict_p == "Continuous"))
none_p <-nrow(subset(path_integrating_neurons, predict_id_p == "posnon"| predict_id_p == "negnon"))
```

6. find proportion of neurons that reset in both beaconed & probe
```{r}
reset_both <-subset(path_integrating_neurons, color_predict == "Reset" & color_predict_p == "Reset")

```


## Plot a pie chart of proportions of neurons in each group

1. Extract number of cells that fall into catagories:
- reset in beaconed (reset_b)
- reset in probe (reset_p)
- reset in beaconed, continuous in probe 
- reset in beaconed, reset in probe 
- continuous in beaconed, reset in probe 
- continuous in beaconed, continuous in probe 

```{r}
# positive homebound slopes
reset_b <-subset(spatial_firing, color_predict == "Reset")
reset_p <-subset(spatial_firing, color_predict_p == "Reset")

reset_b_p <-nrow(subset(spatial_firing, color_predict_p == "Reset" & color_predict == "Reset"))/nrow(spatial_firing)*100
reset_b_only <-nrow(subset(spatial_firing, color_predict_p == "Continuous" & color_predict == "Reset"))/nrow(spatial_firing)*100
reset_p_only <-nrow(subset(spatial_firing, color_predict_p == "Reset" & color_predict == "Continuous"))/nrow(spatial_firing)*100
reset_b_p_cont <-nrow(subset(spatial_firing, color_predict_p == "Continuous" & color_predict == "Continuous"))/nrow(spatial_firing)*100

reset_b_p_num <-nrow(subset(spatial_firing, color_predict_p == "Reset" & color_predict == "Reset"))
reset_b_only_num <-nrow(subset(spatial_firing, color_predict_p == "Continuous" & color_predict == "Reset"))
reset_p_only_num <-nrow(subset(spatial_firing, color_predict_p == "Reset" & color_predict == "Continuous"))
reset_b_p_cont_num <-nrow(subset(spatial_firing, color_predict_p == "Continuous" & color_predict == "Continuous"))

```

2. put percentages into tibble
```{r}

proportions_mixed_ramps <- tibble(perc=c(reset_b_p, reset_b_only, reset_p_only, reset_b_p_cont), num=c(reset_b_p_num, reset_b_only_num, reset_p_only_num, reset_b_p_cont_num), ramp_id= c("Reset(B+P)", "Reset(B) Continuous(P)", "Continuous(B) Reset(P)", "Continuous(B+P)"),ramp_type = c("Reset(B+P)", "Reset(B) Continuous(P)", "Continuous(B) Reset(P)", "Continuous(B+P)"))

```

3. Plot as pie chart
```{r}

# Create Data
data <- data.frame(
  group=LETTERS[1:4],
  value=c(reset_b_p_num,reset_b_only_num,reset_p_only_num, reset_b_p_cont_num)
)

# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set2")

ggsave(file = "plots/predict_reset_Comparison_proportions.png", width = 4, height = 4)

```


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###

## plot bar chart of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone


1. extract neurons with slope on outbound
```{r}
data <- spatial_firing %>% filter(predict_id_p == "pospos" | predict_id_p == "negneg" | predict_id_p == "posneg"| predict_id_p == "negpos")
```

2. extract only neurons that are driven by path integration (as determined by CueAnalysis.0100.Rmd - i.e. Figure 4)
```{r}
pi_data <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")
#cue_data <- data %>% filter(group == "Positive-cue" | group == "Negative-cue")

```

3. Plot bar charts 
```{r}

ggplot(data=subset(pi_data,lm_result_o_rewarded_p == "Negative"), aes(x = unlist(predict_mean_p), fill=as.factor(unlist(lm_result_o_rewarded_p)))) +
  coord_cartesian(xlim=c(-5,5), y=c(0,0.7)) +
  geom_histogram(aes(y=..density..), alpha=0.5) +
  scale_fill_manual(values=c("violetred2")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  geom_vline(xintercept = 1, color="black", linetype="dotted") +
  geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=10), 
        legend.text=element_text(size=10), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/PredictProbe_homebound_mean_PInegative_pi.png",width = 4, height = 2)


ggplot(data=subset(pi_data, lm_result_o_rewarded_p == "Positive"), aes(x = unlist(predict_mean_p), fill=as.factor(unlist(lm_result_o_rewarded_p)))) +
  coord_cartesian(xlim=c(-5,5), y=c(0,0.7)) +
  geom_histogram(aes(y=..density..), alpha=0.5) +
  scale_fill_manual(values=c( "chartreuse3")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  geom_vline(xintercept = 1, color="black", linetype="dotted") +
  geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=10), 
        legend.text=element_text(size=10), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/PredictProbe_homebound_mean_PIpositive_pi.png",width = 4, height = 2)

```


## plot outbound and homebound slopes for each neuron - seperated by whether they reset or are continuous 

1. Extract reset and continuous neurons
```{r}
reset <- pi_data %>% filter(color_predict_p == "Reset")
continuous <- pi_data %>% filter(color_predict_p == "Continuous")
```

2. Plot scatter of slopes on outbound&homebound
```{r}

ggplot() + 
    geom_jitter(data=continuous,aes(x = as.numeric(unlist(asr_p_rewarded_slope_o)), y = as.numeric(unlist(asr_p_rewarded_slope_h)), color=factor(unlist(lm_result_o_rewarded)))) +
    geom_point(data=reset,aes(x = as.numeric(unlist(asr_p_rewarded_slope_o)), y = as.numeric(unlist(asr_p_rewarded_slope_h)), color=factor(unlist(lm_result_o_rewarded))), shape=1) +
    coord_cartesian(ylim = c(-.7,.7), xlim = c(-.7,.7)) +
    xlab("Outbound slope") +
    ylab("Homebound slope") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=16),
          axis.text.y = element_text(size=16),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/slope_comparison_probe_reset2_pi.png", width = 5, height = 5)

```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Plot average firing rates for each group of neuron

Groups are as follows :

outbound homebound  reset
    +       +         n
    +       +         y
    +       -         -
    +      non        -
    -       +         -
    -       -         n
    -       -         y
    -      non        -


# go into dataframe and from each average_rates column : all neurons
```{r}
df <- tibble(Position = rep(1:200, times=nrow(spatial_firing)), Rates = unlist(spatial_firing$Rates_averaged_p), Outbound_beaconed = rep(spatial_firing$lm_result_o_rewarded_p, each=200), Homebound_beaconed = rep(spatial_firing$lm_result_h_p, each=200),group = rep(as.character(spatial_firing$color_predict_p), each=200))

```

# go into dataframe and from each average_rates column : just path integration neurons
```{r}
df <- tibble(Position = rep(1:200, times=nrow(pi_data)), Rates = unlist(pi_data$Rates_averaged_nb), Outbound_beaconed = rep(pi_data$lm_result_o_rewarded_nb, each=200), Homebound_beaconed = rep(pi_data$lm_result_h_nb, each=200), group = rep(as.character(pi_data$color_predict_p), each=200), predict_mean = rep(as.numeric(pi_data$predict_mean), each=200))

```


```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```

```{r}
ggplot(data=df_neg_cue) +
  coord_cartesian(ylim = c(5,40)) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negneg_cells_all_correct_probe_PI_2.png", width = 3.5, height = 2.5)

```





```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```

```{r}
ggplot(data=df_neg_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/negneg_cells_all_wrong_probe_PI_2.png", width = 3.5, height = 2.5)

```





```{r}
df_pos_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```



```{r}
ggplot(data=df_pos_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "Black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/negpos_cells_all_wrong_probe_PI_2.png", width = 3.5, height = 2.5)

```





```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```



```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/pospos_cells_all_correct_probe_PI_2.png", width = 3.5, height = 2.5)


```



```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```



```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/pospos_cells_all_wrong_probe_PI_2.png", width = 3.5, height = 2.5)


```




```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/posneg_cells_all_wrong_probe_PI2.png", width = 3.5, height = 2.5)


```





```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "None") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/posnon_cells_all_wrong_probe_PI_2.png", width = 3.5, height = 2.5)


```




```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "None") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/negnon_cells_all_wrong_probe_PI2.png", width = 3.5, height = 2.5)


```


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


### Plot Sankey Diagrams


```{r}
data <- spatial_firing %>% filter(predict_id_p == "pospos" | predict_id_p == "negneg")

```

# filter for pi neurons
```{r}
pi_data <- subset(data, group == "Positive-PI" | group == "Negative-PI")
cue_data <- subset(data,group == "Positive-cue" | group == "Negative-cue")

```

# filter for negative > negative & positive > positive
```{r}
negneg_pineurons <-subset(pi_data, lm_result_o_rewarded_p == "Negative" & lm_result_h_p == "Negative")
posos_pineurons <-subset(pi_data, lm_result_o_rewarded_p == "Positive" & lm_result_h_p == "Positive")
negpos_pineurons<-subset(pi_data, lm_result_o_rewarded_p == "Negative" & lm_result_h_p == "Positive")
posneg_pineurons<-subset(pi_data, lm_result_o_rewarded_p == "Positive" & lm_result_h_p == "Negative")

```


# find out proportions of reset and continuous in these groups
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, color_predict_p == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, color_predict_p == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, color_predict_p == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, color_predict_p == "Continuous"))

posneg_pineurons <-nrow(posneg_pineurons)/nrow(posneg_pineurons)*100
negpos_pineurons <-nrow(negpos_pineurons)/nrow(negpos_pineurons)*100

```

## raw numbers 
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, color_predict_p == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, color_predict_p == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, color_predict_p == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, color_predict_p == "Continuous"))
```


```{r}

data_long <- tibble(value=c(negneg_pineurons_reset, negneg_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont), 
                    
                      source= c("Negative > Negative","Negative > Negative", "Positive > Positive", "Positive > Positive"),
                     target= c("Reset", "Continuous", "Reset", "Continuous"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```


```{r}
# A connection data frame is a list of flows with intensity for each flow
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","F56666", "#FDE725FF","#B4DE2CFF" ,"#F56666", "#B4DE2CFF","FDE725FF", "#B4DE2CFF", "#B4DE2CFF"])'

#ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'


links <- data.frame(
  source=c("Positive1","Positive1", "Reset1", "Continuous1", "Negative1", "Negative1",  "Reset2", "Continuous2"), 
  target=c("Reset1","Continuous1", "Positive2", "Positive2", "Reset2", "Continuous2", "Negative2", "Negative2"), 
  value=c(pospos_pineurons_reset,pospos_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont, negneg_pineurons_reset, negneg_pineurons_cont ,negneg_pineurons_reset, negneg_pineurons_cont))
  
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=30, fontSize=13, nodePadding=15)

p


```

```{r}
data <- spatial_firing %>% filter(predict_id_p == "pospos" | predict_id_p == "negneg" | predict_id_p == "posneg"| predict_id_p == "negpos")

pi_data <- subset(data, group == "Positive-PI" | group == "Negative-PI")

```

```{r}

pi_positive <-subset(pi_data, lm_result_o_rewarded_p == "Positive")
pi_negative <-subset(pi_data, lm_result_o_rewarded_p == "Negative")
pi_none <-subset(pi_data, lm_result_o_rewarded_p == "None")
pi_ramp <-subset(pi_data, lm_result_o_rewarded_p == "Positive" |lm_result_o_rewarded_p == "Negative")

pi_positive_pos <-nrow(subset(pi_positive, lm_result_h_p == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_result_h_p == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_result_h_p == "None"))
pi_negative_pos <-nrow(subset(pi_negative, lm_result_h_p == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_result_h_p == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_result_h_p == "None"))
pi_none_pos <-nrow(subset(pi_none, lm_result_h_p == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_result_h_p == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_result_h_p == "None"))


```

```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```




```{r}
pi_positive_pos <-nrow(subset(pi_positive, lm_result_h_p == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_result_h_p == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_result_h_p == "None"))
pi_negative_pos <-nrow(subset(pi_negative, lm_result_h_p == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_result_h_p == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_result_h_p == "None"))
pi_none_pos <-nrow(subset(pi_none, lm_result_h_p == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_result_h_p == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_result_h_p == "None"))

```

