---
title: "WholeTrackAnalysis"
author: "Sarah Tennant"
date: "01/09/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Script aims to determine if ramp activity resets or is continuous across the reward zone


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


First, mark cells based on their activity in the outbound and homebound region
i.e. pospos = positive in outbound, positive in homebound
i.e. posneg = positive in outbound, negative in homebound

1. write function to mark cells based on groups
```{r}
mark_predict_group <- function(outbound, homebound){
  if (is.na(df) ) {
    return( "None" )
  } else if( outbound == "Positive" & homebound =="Negative") {
    return( "posneg" ) 
  } else if( outbound == "Positive" & homebound =="Positive") {
    return( "pospos" )
  } else if( outbound == "Negative" & homebound =="Positive") {
    return( "negpos" )
  } else if( outbound == "Negative" & homebound =="Negative") {
    return( "negneg" )
  } else if( outbound == "Negative" & homebound =="Unclassified") {
    return( "negnon" )
  } else if( outbound == "Positive" & homebound =="Unclassified") {
    return( "posnon" )
  } else {
    return("None")
  }
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate( predict_id = map2(slope_criteria_pval, slope_criteria_pval_h, mark_predict_group))

```


Now, we want to know what proportion of cells fit this group 
_note : we focus on cue independant/path integrating neurons here as classified in Figure 4 (CueAnalysis_0100.Rmd)_

1. Find cue independant cells
```{r}
cueindependant_neurons <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")
cuedependant_neurons <- subset(spatial_firing, group == "Positive-cue" | group == "Negative-cue")

```

2. find proportion of cue independant cells that fall into groups as catagorised above (pospos, posneg etc)
```{r}
# positive homebound slopes
pospos <-nrow(subset(cueindependant_neurons, predict_id == "pospos"))/nrow(cueindependant_neurons)*100
posneg <-nrow(subset(cueindependant_neurons, predict_id == "posneg"))/nrow(cueindependant_neurons)*100
negneg <-nrow(subset(cueindependant_neurons, predict_id == "negneg"))/nrow(cueindependant_neurons)*100
negpos <-nrow(subset(cueindependant_neurons, predict_id == "negpos"))/nrow(cueindependant_neurons)*100

# positive homebound slopes
pospos_num <-nrow(subset(cueindependant_neurons, predict_id == "pospos"))
posneg_num <-nrow(subset(cueindependant_neurons, predict_id == "posneg"))
negneg_num <-nrow(subset(cueindependant_neurons, predict_id == "negneg"))
negpos_num <-nrow(subset(cueindependant_neurons, predict_id == "negpos"))

```

3. Same as above but for cue dependant neurons
```{r}
# positive homebound slopes
pospos <-nrow(subset(cuedependant_neurons, predict_id == "pospos"))/nrow(cuedependant_neurons)*100
posneg <-nrow(subset(cuedependant_neurons, predict_id == "posneg"))/nrow(cuedependant_neurons)*100
negneg <-nrow(subset(cuedependant_neurons, predict_id == "negneg"))/nrow(cuedependant_neurons)*100
negpos <-nrow(subset(cuedependant_neurons, predict_id == "negpos"))/nrow(cuedependant_neurons)*100

# positive homebound slopes
pospos_num <-nrow(subset(cuedependant_neurons, predict_id == "pospos"))
posneg_num <-nrow(subset(cuedependant_neurons, predict_id == "posneg"))
negneg_num <-nrow(subset(cuedependant_neurons, predict_id == "negneg"))
negpos_num <-nrow(subset(cuedependant_neurons, predict_id == "negpos"))

```

4. put proportions into tibble for plotting
```{r}

proportions_mixed_ramps <- tibble(perc=c(pospos, posneg, negneg, negpos), num=c(pospos_num, posneg_num, negneg_num, negpos_num), ramp_id= c("+ +", "+ -", "- - ", "- +"),ramp_type = c("+ +", "+ -", "- - ", "- +"))

```

5. Plot pie chart of proportions
```{r}

# Create Data
data <- data.frame(
  group=LETTERS[1:4],
  value=c(pospos,posneg,negneg,negpos)
)

# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")

ggsave(file = "plots/homebound_proportions_cueindependant.png", width = 4, height = 4)

```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###

## plot bar chart of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone

1. extract neurons with slope on outbound
```{r}
data <- spatial_firing %>% filter(predict_id == "pospos" | predict_id == "negneg" | predict_id == "posneg"| predict_id == "negpos")
```

2. extract only neurons that are driven by path integration (as determined by CueAnalysis.0100.Rmd - i.e. Figure 4)
```{r}
pi_data <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")
#cue_data <- data %>% filter(group == "Positive-cue" | group == "Negative-cue")

```

3. Plot bar charts - positive neurons

```{r}
ggplot(data=subset(pi_data, slope_criteria_pval == "Positive"), aes(x = unlist(predict_mean), fill=as.factor(unlist(slope_criteria_pval)))) +
  coord_cartesian(xlim=c(-5,5), y=c(0,0.7)) +
  geom_histogram(aes(y=..density..), alpha=0.5) +
  scale_fill_manual(values=c( "chartreuse3")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  geom_vline(xintercept = 1, color="black", linetype="dotted") +
  geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=10), 
        legend.text=element_text(size=10), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/Predict_homebound_mean_PIpositive_pi.png",width = 4, height = 2)
```

4. Plot bar charts - Negative neurons

```{r}

ggplot(data=subset(pi_data,slope_criteria_pval == "Negative"), aes(x = unlist(predict_mean), fill=as.factor(unlist(slope_criteria_pval)))) +
  coord_cartesian(xlim=c(-5,5), y=c(0,0.7)) +
  geom_histogram(aes(y=..density..), alpha=0.5) +
  scale_fill_manual(values=c("violetred2")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  geom_vline(xintercept = 1, color="black", linetype="dotted") +
  geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=10), 
        legend.text=element_text(size=10), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/Predict_homebound_mean_PInegative_pi.png",width = 4, height = 2)

```





### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


Now, we want to find out if within pospos and negneg groups - are their firing rate reset or continue across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 


First, normalise firing rates. 

1. make function to load rates and normalise
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates = map(Rates_averaged_rewarded_b, normalise_rates))


```

Then, predict firing rate in hombound region based on fit from real data in outbound region

1. make function to predict firing rate
```{r}
lm_predict <- function(df){
  new.data <- data.frame(Position =df$Position)
}
```

3. Function to calculate mean difference in firing rate between real and predicted data
```{r}

lm_predict_mse_homebound <- function(rate){
  if(all(is.na(rate))) 
    return(NA)
  startbins=c(30:90)
  df <- tibble(Rates = unlist(rate), Position=rep(1:200))

  lmer <- lm(Rates ~ Position, data = df[startbins,])
  
  df_homebound <- df %>% filter(between(Position, 110, 115))
  new.data <- lm_predict(df_homebound)
  Rates <- predict(lmer, newdata = new.data)
  mydata <- cbind(new.data, Rates)
  
  mean( df_homebound$Rates - mydata$Rate)

}

```

2. Run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(predict_mean = map(normalised_rates, lm_predict_mse_homebound)) 
  
```


Now, we can classify cells based on their predicted activity. 

1. Function to classify neurons based on predict mean

```{r}
mark_color <- function(df, id){
  if (is.na(df) ) {
    return( "None" )
  } else if( id == "posneg" | id == "negpos") {
    return( "Reset" ) 
  } else if( id == "posnon" | id == "negnon") {
    return( "Continuous" ) 
  } else if( (df > -1 & df < 1) & (id == "pospos" | id == "negneg")) {
    return( "Continuous" )
  } else if( (df <= -1 | df >= 1) & (id == "pospos" | id == "negneg")) {
    return( "Reset" ) 
    } else {
    return("None")
  }
}

```


2. Run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(color_predict = map2(predict_mean, predict_id, mark_color))

```

3. Calculate number of neurons that are in each group as classified above
```{r}
path_integrating_neurons <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")

neg_probe <- nrow(subset(spatial_firing, slope_criteria_pval_p == "Negative" )) # all neurons that are conciderd ramp like on probe trials
pos_probe <- nrow(subset(spatial_firing, slope_criteria_pval_p == "Positive")) # all neurons that are conciderd ramp like on probe trials

all <- nrow(subset(path_integrating_neurons, slope_criteria_pval_p == "Negative" | slope_criteria_pval_p == "Positive")) # all neurons that are conciderd ramp like on probe trials
switchers <- nrow(subset(path_integrating_neurons, color_predict_p == "Switch")) # cells that switch slope 
reset_p <-nrow(subset(path_integrating_neurons, color_predict_p == "Reset"))
continuous_p <-nrow(subset(path_integrating_neurons, color_predict_p == "Continuous"))
none_p <-nrow(subset(path_integrating_neurons, predict_id_p == "posnon"| predict_id_p == "negnon"))

```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## now plot scatter of slopes for outbound and slopes for homebound with neurons marked accordng to whether they are reset or continuous


```{r}
data <- spatial_firing %>% filter(predict_id == "pospos" | predict_id == "negneg" | predict_id == "posneg"| predict_id == "negpos" | predict_id == "posnon"| predict_id == "negnon")
```

```{r}
pi_data <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")
```

```{r}
reset <- pi_data %>% filter(color_predict == "Reset")
continuous <- pi_data %>% filter(color_predict == "Continuous")
```


```{r}

ggplot() + 
    geom_jitter(data=continuous,aes(x = as.numeric(unlist(asr_b_rewarded_slope_o)), y = as.numeric(unlist(asr_b_rewarded_slope_h)), color=factor(unlist(slope_criteria_pval)))) +
    geom_jitter(data=reset,aes(x = as.numeric(unlist(asr_b_rewarded_slope_o)), y = as.numeric(unlist(asr_b_rewarded_slope_h)), color=factor(unlist(slope_criteria_pval))), shape=1) +
    coord_cartesian(ylim = c(-.6,.6), xlim = c(-.6,.6)) +
    xlab("Outbound slope") +
    ylab("Homebound slope") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=16),
          axis.text.y = element_text(size=16),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/slope_comparison_reset.png", width = 5, height = 5)

```

### -------------------------------------------------------------------------------------------------------------------------------------------------- ###



## save new firing rates

```{r}

lm_predict_homebound <- function(df){
  if(all(is.na(df))) 
    return(NA)
  startbins=c(30:90)

  lmer <- lm(Rates ~ Position, data = df[startbins,])
  
  df_homebound <- df %>% filter(between(Position, 110, 170))
  new.data <- lm_predict(df_homebound)
  Rates <- predict(lmer, newdata = new.data)
  mydata <- cbind(new.data, Rates)
  
}

```

2. Run

```{r}

spatial_firing <- spatial_firing %>%
  mutate(predict_firingrate = map(asr_b_rewarded, lm_predict_homebound)) 
  
```


Now we want to plot population rate across whole track for diff groups so we can visualise the average firing rate

1. Split data based on cue independant/cue dependant

```{r}
pi_data <- subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")
cue_data <- subset(spatial_firing, group == "Positive-cue" | group == "Negative-cue")

```

2. make tibble with average firing rates and classifications : just path integration neurons
```{r}
df <- tibble(Position = rep(1:200, times=nrow(pi_data)), Rates = unlist(pi_data$Rates_averaged_rewarded_b), Outbound_beaconed = rep(pi_data$slope_criteria_pval, each=200), Homebound_beaconed = rep(pi_data$slope_criteria_pval_h, each=200), group = rep(as.character(pi_data$color_predict), each=200), predict_mean = rep(as.numeric(pi_data$predict_mean), each=200))

```

3. make tibble with average firing rates and classifications : just cue neurons
```{r}
df <- tibble(Position = rep(1:200, times=nrow(cue_data)), Rates = unlist(cue_data$Rates_averaged), Outbound_beaconed = rep(cue_data$lm_result_o_rewarded, each=200), Homebound_beaconed = rep(cue_data$lm_result_h_b, each=200), Outbound_nonbeaconed = rep(cue_data$lm_result_o_rewarded_p, each=200), group = rep(as.character(cue_data$group), each=200), predict_mean = rep(as.numeric(cue_data$predict_mean), each=200))

```


4. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Continuous") %>%
  #subset(predict > -5 & predict < 5) %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

5. Plot average rates
```{r}
ggplot(data=df_neg_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "Black") +
  theme_classic() +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,50,10), expand = c(0, 0)) +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negneg_cells_all_correct_mean_PI_f.png", width = 3.5, height = 2.5)

```


4. Subset data by group then average rates for plotting          **Negative Negative Reset**

```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

5. Plot data
```{r}
ggplot(data=df_neg_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,30,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/negneg_cells_all_wrong_mean_PI_f.png", width = 3.5, height = 2.5)

```



4. Subset data by group then average rates for plotting          **Negative Positive**
```{r}
df_pos_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```

5. Plot data
```{r}
ggplot(data=df_pos_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  #geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/negpos_cells_all_wrong_mean_PI_f.png", width = 3.5, height = 2.5)

```


4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```


5. Plot data
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,30,10), expand = c(0, 0)) +
  #geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/pospos_cells_all_correct_mean_PI_f.png", width = 3.5, height = 2.5)


```


4. Subset data by group then average rates for plotting          **Positive Positive Reset**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```


5. Plot data
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  #geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/pospos_cells_all_wrong_mean_PI_f.png", width = 3.5, height = 2.5)


```

4. Subset data by group then average rates for plotting          **Positive Negative**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```


5. Plot data
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12), 
        panel.grid = element_blank(),
        panel.border = element_blank()) 

ggsave(file = "plots/posneg_cells_all_wrong_mean_PI_f.png", width = 3.5, height = 2.5)


```


4. Subset data by group then average rates for plotting          **Positive Unclassified**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Unclassified") %>%
  #subset(predict_mean < -1 | predict_mean > 1) %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```

5. Plot rates
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12), 
        panel.grid = element_blank(),
        panel.border = element_blank()) 

ggsave(file = "plots/posnon_cells_all_wrong_mean_PI_f.png", width = 3.5, height = 2.5)


```

4. Subset data by group then average rates for plotting          **Negative Unclassified**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```

5. Plot data
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12), 
        panel.grid = element_blank(),
        panel.border = element_blank()) 

ggsave(file = "plots/negnon_cells_all_wrong_mean_PI_f.png", width = 3.5, height = 2.5)


```






### -------------------------------------------------------------------------------------------------------------------------------------------------- ###



### Sankey Diagrams ### 


# make into sankey

```{r}
data <- spatial_firing %>% filter(predict_id == "pospos" | predict_id == "negneg")

```

# filter for pi neurons
```{r}
pi_data <- subset(data, group == "Positive-PI" | group == "Negative-PI")
cue_data <- subset(data,group == "Positive-cue" | group == "Negative-cue")

```


# filter for negative > negative & positive > positive
```{r}
negneg_pineurons <-subset(pi_data, slope_criteria_pval == "Negative" & slope_criteria_pval_h == "Negative")
posos_pineurons <-subset(pi_data, slope_criteria_pval == "Positive" & slope_criteria_pval_h == "Positive")
negpos_pineurons<-subset(pi_data, slope_criteria_pval == "Negative" & slope_criteria_pval_h == "Positive")
posneg_pineurons<-subset(pi_data, slope_criteria_pval == "Positive" & slope_criteria_pval_h == "Negative")

```

# find out proportions of reset and continuous in these groups
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, color_predict == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, color_predict == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, color_predict == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, color_predict == "Continuous"))

posneg_pineurons <-nrow(posneg_pineurons)/nrow(posneg_pineurons)*100
negpos_pineurons <-nrow(negpos_pineurons)/nrow(negpos_pineurons)*100

```

## raw numbers 
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, color_predict == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, color_predict == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, color_predict == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, color_predict == "Continuous"))
```


```{r}

data_long <- tibble(value=c(negneg_pineurons_reset, negneg_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont), 
                    
                      source= c("Negative > Negative","Negative > Negative", "Positive > Positive", "Positive > Positive"),
                     target= c("Reset", "Continuous", "Reset", "Continuous"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```


```{r}
# A connection data frame is a list of flows with intensity for each flow
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","F56666", "#FDE725FF","#B4DE2CFF" ,"#F56666", "#B4DE2CFF","FDE725FF", "#B4DE2CFF", "#B4DE2CFF"])'

#ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'


links <- data.frame(
  source=c("Positive1","Positive1", "Reset1", "Continuous1", "Negative1", "Negative1",  "Reset2", "Continuous2"), 
  target=c("Reset1","Continuous1", "Positive2", "Positive2", "Reset2", "Continuous2", "Negative2", "Negative2"), 
  value=c(pospos_pineurons_reset,pospos_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont, negneg_pineurons_reset, negneg_pineurons_cont ,negneg_pineurons_reset, negneg_pineurons_cont))
  
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=30, fontSize=13, nodePadding=15)

p


```

```{r}
data <- spatial_firing %>% filter(predict_id == "pospos" | predict_id == "negneg" | predict_id == "posneg"| predict_id == "negpos")

pi_data <- subset(data, group == "Positive-PI" | group == "Negative-PI")

```

```{r}

pi_positive <-subset(pi_data, slope_criteria_pval == "Positive")
pi_negative <-subset(pi_data, slope_criteria_pval == "Negative")
pi_none <-subset(pi_data, slope_criteria_pval == "None")

pi_positive_pos <-nrow(subset(pi_positive, slope_criteria_pval_h == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, slope_criteria_pval_h == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, slope_criteria_pval_h == "None"))
pi_negative_pos <-nrow(subset(pi_negative, slope_criteria_pval_h == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, slope_criteria_pval_h == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, slope_criteria_pval_h == "None"))
pi_none_pos <-nrow(subset(pi_none, slope_criteria_pval_h == "Positive"))
pi_none_neg <-nrow(subset(pi_none, slope_criteria_pval_h == "Negative"))
pi_none_none <-nrow(subset(pi_none, slope_criteria_pval_h == "None"))

pi_positive_pos_num <-nrow(subset(pi_positive, slope_criteria_pval_h == "Positive"))
pi_positive_neg_num <-nrow(subset(pi_positive, slope_criteria_pval_h == "Negative"))
pi_positive_none_num <-nrow(subset(pi_positive, slope_criteria_pval_h == "None"))
pi_negative_pos_num <-nrow(subset(pi_negative, slope_criteria_pval_h == "Positive"))
pi_negative_neg_num <-nrow(subset(pi_negative, slope_criteria_pval_h == "Negative"))
pi_negative_none_num <-nrow(subset(pi_negative, slope_criteria_pval_h == "None"))
pi_none_pos_num <-nrow(subset(pi_none, slope_criteria_pval_h == "Positive"))
pi_none_neg_num <-nrow(subset(pi_none, slope_criteria_pval_h == "Negative"))
pi_none_none_num <-nrow(subset(pi_none, slope_criteria_pval_h == "None"))

```

```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###
