---
title: "Figure5_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Script aims to determine if ramp activity resets or is continuous across the reward zone


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


### First, we need to classify neurons based on their ramp activity in the homebound region, similar to that done in figure 2 analysis. 

# Run simple linear model to examine relationship between firing rate and position
_note:for now we are only interested in the homebound region of the track (110 - 170 cm)_


1. Make function to run linear model

Use lm_helper defined in analysis for figure 2.


2. run lm on all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_h_rewarded_fit_')) %>%
  select(-contains('asr_nb_h_rewarded_fit_')) %>%
  select(-contains('asr_p_h_rewarded_fit_')) %>%
  mutate(asr_b_h_rewarded_fit = pmap(list(asr_b_rewarded, 110, 170), lm_helper),
         asr_nb_h_rewarded_fit = pmap(list(asr_nb_rewarded, 110, 170), lm_helper),
         asr_p_h_rewarded_fit = pmap(list(asr_p_rewarded, 110, 170), lm_helper)) %>%
  unnest_wider(asr_b_h_rewarded_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_nb_h_rewarded_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_p_h_rewarded_fit, names_sep = "_", names_repair = "universal")
```

Linear model results are stored in:
spatial_firing$asr_b_h_rewarded_fit_pval
spatial_firing$asr_b_h_rewarded_fit_slope
spatial_firing$asr_b_h_rewarded_fit_r.squared


3. Plot coefficients of model (slope and r2 value) for each neuron
```{r}
ggplot(data=spatial_firing, aes(x = asr_b_h_rewarded_fit_slope,
                                y = asr_b_h_rewarded_fit_r.squared)) +
    coord_cartesian(xlim = c(-0.7,0.7), ylim = c(0,1)) +
    geom_point() +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    scale_color_manual(values=c("grey82", "grey32", "violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
  ggsave(file = "plots/shuff_lm_homebound_allcells.png", width = 4, height = 5)
}

```


### ---------------------------------------------------------------------------- ### 

## Identification of homebound ramp cells in dataset 

Ramp like cells are identified by whether the coefficients of the linear model lie outside the 95% confidence intervals of the same result from 1000 shuffled datasets

Beause the homebound zone is the same length as the outbound zone, and as shuffling is across the full track length, we can use the shuffle results generated for Figure 2.

### classify neurons based on shuffle activity

If outside the 95% of the shuffled dataset, a neuron is considered to have ramp like activity along the track. 

First we want to correct the pvals of the lm, to account for multiple comparisons

1. put all pvalues into tibble then adjust using p.adjust from - package
```{r}
p_vals_b <- tibble(pvals = spatial_firing$asr_b_h_rewarded_fit_p.value)
adu_p_b <- tibble(adjust_pval_b_h = p.adjust(p_vals_b$pvals, "BH"))

```

2. bind new adjusted pvalues to dataframe
```{r}
spatial_firing <- cbind(spatial_firing, adu_p_b)
```

3. do the same for non-beaconed trials
```{r}
p_vals_nb <- tibble(pvals = spatial_firing$asr_nb_h_rewarded_fit_p.value)
adu_p_nb <- tibble(adjust_pval_nb_h = p.adjust(p_vals_nb$pvals, "BH"))
spatial_firing <- cbind(spatial_firing, adu_p_nb)
```

3. do the same for probe trials 
```{r}
p_vals_p <- tibble(pvals = spatial_firing$asr_p_h_rewarded_fit_p.value)
adu_p_p <- tibble(adjust_pval_p_h = p.adjust(p_vals_p$pvals, "BH"))
spatial_firing <- cbind(spatial_firing, adu_p_p)
```

Now we want to classify neurons, taking the adjusted significance into account

Uses the function compare_slopes from Figure 2.

#compare_slopes(spatial_firing$shuffle_min_slope_b_o[[1]], spatial_firing$shuffle_max_slope_b_o, spatial_firing$asr_b_h_rewarded_fit_slope[[1]], spatial_firing$adjust_pval_b_h)

```{r}

spatial_firing <- spatial_firing %>%
  mutate(
    lm_group_b_h = pmap(
      list(
        shuffle_min_slope_b_o,
        shuffle_max_slope_b_o,
        asr_b_h_rewarded_fit_slope,
        adjust_pval_b_h
      ),
      compare_slopes
    ),
    lm_group_nb_h = pmap(
      list(
        shuffle_min_slope_nb_o,
        shuffle_max_slope_nb_o,
        asr_nb_h_rewarded_fit_slope,
        adjust_pval_nb_h
      ),
      compare_slopes
    ),
    lm_group_p_h = pmap(
      list(
        shuffle_min_slope_p_o,
        shuffle_max_slope_p_o,
        asr_p_h_rewarded_fit_slope,
        adjust_pval_p_h
      ),
      compare_slopes
    )
  )

```

Linear model classification is stored in:
spatial_firing$lm_group_b_h
spatial_firing$lm_group_nb_h
spatial_firing$lm_group_p_h


### ------------------------------------------------------------------------------------------ ### 


Now, we can classify cells based on their activity in the outbound and homebound region

i.e. pospos = positive in outbound, positive in homebound
i.e. posneg = positive in outbound, negative in homebound

1. write function to mark cells based on groups
```{r}
mark_track_category <- function(outbound, homebound){
  if (is.na(outbound) ) {
    return( "None" )  
  } else if( outbound == "Positive" & homebound == "Negative") {
    return( "posneg" ) 
  } else if( outbound == "Positive" & homebound == "Positive") {
    return( "pospos" )
  } else if( outbound == "Negative" & homebound == "Positive") {
    return( "negpos" )
  } else if( outbound == "Negative" & homebound == "Negative") {
    return( "negneg" )
  } else if( outbound == "Negative" & homebound == "Unclassified") {
    return( "negnon" )
  } else if( outbound == "Positive" & homebound == "Unclassified") {
    return( "posnon" )
  } else {
    return("None")
  }
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(track_category = map2(lm_group_b, lm_group_b_h, mark_track_category)) %>%
  mutate(track_category_nb = map2(lm_group_nb, lm_group_nb_h, mark_track_category))

```

### ------------------------------------------------------------------------------------------ ### 

Now, we want to know what proportion of cells fit this group 
_note : we focus on cue-independent neurons here as classified in Figure 4 (Figure4_A.Rmd)_

1. Find cue independent cells
_note: cue_group_o is defined in Figure4_Analysis.Rmd_
```{r}
cueindependent_neurons <- subset(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

2. find proportion of cue independent cells that fall into groups as catagorised above (pospos, posneg etc)
```{r}
# positive homebound slopes
pospos <-nrow(subset(cueindependent_neurons, track_category == "pospos"))/nrow(cueindependent_neurons)*100
posneg <-nrow(subset(cueindependent_neurons, track_category == "posneg"))/nrow(cueindependent_neurons)*100
negneg <-nrow(subset(cueindependent_neurons, track_category == "negneg"))/nrow(cueindependent_neurons)*100
negpos <-nrow(subset(cueindependent_neurons, track_category == "negpos"))/nrow(cueindependent_neurons)*100

# positive homebound slopes
pospos_num <-nrow(subset(cueindependent_neurons, track_category == "pospos"))
posneg_num <-nrow(subset(cueindependent_neurons, track_category == "posneg"))
negneg_num <-nrow(subset(cueindependent_neurons, track_category == "negneg"))
negpos_num <-nrow(subset(cueindependent_neurons, track_category == "negpos"))

```

3. put proportions into tibble for plotting
```{r}

proportions_mixed_ramps <- tibble(perc=c(pospos, posneg, negneg, negpos), num=c(pospos_num, posneg_num, negneg_num, negpos_num), ramp_id= c("+ +", "+ -", "- - ", "- +"),ramp_type = c("+ +", "+ -", "- - ", "- +"))

```

5. Plot pie chart of proportions
```{r}

# Create Data
data <- data.frame(
  group=LETTERS[1:4],
  value=c(pospos,posneg,negneg,negpos)
)

# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")

if (save_figures == 1) {
 ggsave(file = "plots/Reset_cellproportions_cueindependant.png", width = 4, height = 4) 
}
```



### ------------------------------------------------------------------------------------------ ### 

Now, we want to find out if within pospos and negneg groups - are their firing rate reset or continue across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 


First, normalise firing rates. 

1. make function to load rates and normalise
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates = map(Rates_averaged_rewarded_b, normalise_rates)) %>%
  mutate(normalised_rates_nb = map(Rates_averaged_rewarded_nb, normalise_rates))

```

Then, predict firing rate in homebound region based on fit from real data in outbound region

1. make function to predict firing rate
```{r}
lm_predict <- function(df){
  new.data <- data.frame(Position =df$Position)
}
```

3. Predict mean and confidence intervals for firing rate at the start of the homebound zone (track positions 110 to 115 cm) based on firing in the outbound zone (30 to 90 cm).
```{r}
predict_homebound <- function(df, fit_start = 30, fit_end = 90, predict_start = 110, predict_end = 115){
  # check for NAs
  if(all(is.na(df))) 
    return(NA)
  # Make track column
  df <- tibble(Rates = unlist(df), Position=rep(1:200))
  # fit
  model <- lm(Rates ~ Position, data = filter(df, Position >= fit_start, Position <= fit_end))
  # predict
  homebound_prediction_pos <- tibble(Position = rep(1:200))
  #homebound_prediction <- predict(model, newdata = homebound_prediction_pos, interval = "confidence")
  homebound_prediction <- predict(model, newdata = homebound_prediction_pos, interval = "prediction", level = 0.99) 
  as.tibble(homebound_prediction)
}


```

Test whether data lies outside of confidence intervals
```{r}
offset_test <- function(rates, lwr, upr){
    # check for NAs
 if(all(is.na(rates))) 
    return(NA)
  rates <- mean(as.double(rates[110:115]))
  upr <- mean(as.double(upr[110:115]))
  lwr <- mean(as.double(lwr[110:115]))
 if(rates > upr) {
   return("Pos")
 }

 if (rates < lwr) {
   return("Neg")
 }
    return("None")

}
```

Calculate difference between mean rate and predicted mean rate at the start of the homebound zone
```{r}
calc_predict_diff <- function(rates, fit)
{
  diff <- mean(as.double(rates[110:115])) - mean(as.double(fit[110:115]))
  }
```

2. Run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_')) %>%
  select(-contains('predict_params_nb_')) %>%
  mutate(predict_params = map(normalised_rates, predict_homebound)) %>%
  mutate(predict_params_nb = map(normalised_rates_nb, predict_homebound)) %>%
  unnest_wider(predict_params, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(predict_params_nb, names_sep = "_", names_repair = "universal")

spatial_firing <- spatial_firing %>%
  mutate(offset = pmap_chr(list(normalised_rates, predict_params_lwr, predict_params_upr), offset_test),
         predict_diff = map2_dbl(normalised_rates, predict_params_fit, calc_predict_diff),
         predict_diff_nb = map2_dbl(normalised_rates_nb, predict_params_nb_fit, calc_predict_diff))

```


### ------------------------------------------------------------------------------------------ ### 

Now, we can classify cells based on their predicted activity. 
_first method_
1. Function to classify neurons based on offset (Matt code that does it based on prediction)

```{r}
mark_reset_group_predict <- function(offset){
  if (is.na(offset) ) {
    return( "None" )
  } else if( offset == "None") {
    return( "Continuous" )
  } else if( ( offset == "Neg" ||  offset == "Pos")) {
    return( "Reset" ) 
  }
}

```

2. Run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reset_group = map(offset, mark_reset_group_predict))

```


Now, we can classify cells based on their predicted activity. 
_second method_
1. classify based on predict mean (Sarah method)

```{r}
mark_reset_group <- function(diff){
  if (is.na(diff) ) {
    return( "None" )
  } else if( (diff > -1 & diff < 1)) {
    return( "Continuous" )
  } else if( (diff <= -1 | diff >= 1)) {
    return( "Reset" ) 
  } else {
    return("None")
  }
}

```

2. Run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reset_group = map(predict_diff, mark_reset_group)) %>%
  mutate(reset_group_nb = map(predict_diff_nb, mark_reset_group))

```


then add another column, which contains the slope in both the outbound and homebound and the reset activity

```{r}
mark_track_category <- function(outbound, homebound, reset){
  if (is.na(outbound) ) {
    return( "None" )  
  } else if( (outbound == "Positive") & (homebound == "Negative")) {
    return( "+ -" ) 
  } else if( (outbound == "Positive") & (homebound == "Positive") & (reset == "Continuous")) {
    return( "+ +" )
  } else if( (outbound == "Positive") & (homebound == "Positive") & (reset == "Reset")) {
    return( "+ + R" )
  } else if( (outbound == "Negative") & (homebound == "Positive")) {
    return( "- +" )
  } else if( (outbound == "Negative") & (homebound == "Negative") & (reset == "Continuous")) {
    return( "- -" )
  } else if( (outbound == "Negative") & (homebound == "Negative") & (reset == "Reset")) {
    return( "- - R" )
  } else if( (outbound == "Negative") & (homebound == "Unclassified")) {
    return( "- none" )
  } else if( (outbound == "Positive") & (homebound == "Unclassified")) {
    return( "+ none" )
    
  } else {
    return("None")
  }
}

```

3. Run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(track_reset_group = pmap(list(lm_group_b, lm_group_b_h, reset_group), mark_track_category)) %>%
  mutate(track_reset_group_nb = pmap(list(lm_group_nb, lm_group_nb_h, reset_group_nb), mark_track_category)) 

```

### ------------------------------------------------------------------------------------------ ### 


## plot bar chart of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone

1. extract neurons with slope on outbound & homebound
```{r}
data <- subset(spatial_firing, track_category == "pospos" | track_category == "negneg" | track_category == "posneg" | track_category == "negpos" | track_category == "negnon" | track_category == "posnon")
```

2. extract only neurons that are driven by path integration (as determined by Figure 4 Analysis)
```{r}
pi_data <- subset(data, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

3. subset based on position
```{r}
position_neurons <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

4. Plot bar charts - positive neurons
```{r}
ggplot(data=subset(position_neurons, lm_group_b == "Positive"), aes(x = unlist(predict_diff), fill=as.factor(unlist(reset_group)))) +
  coord_cartesian(xlim=c(-5,5)) +
  geom_histogram(aes(y=..count..), alpha=0.5) +
  scale_fill_manual(values=c(  "grey", "chartreuse3","chartreuse3")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  #geom_vline(xintercept = 1, color="black", linetype="dotted") +
  #geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictHomeboundMean_PIpositive_pi.png",width = 4, height = 2.5)
}
```

5. Plot bar charts - Negative neurons

```{r}

ggplot(data=subset(position_neurons,lm_group_b == "Negative"), aes(x = unlist(predict_diff), fill=as.factor(unlist(reset_group)))) +
  coord_cartesian(xlim=c(-5,5)) +
  geom_histogram(aes(y=..count..), alpha=0.5) +
  scale_fill_manual(values=c( "grey", "violetred2","violetred2")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  #geom_vline(xintercept = 1, color="black", linetype="dotted") +
  #geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictHomeboundMean_PInegative_pi.png",width = 4, height = 2.5)
}
```




### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## now plot scatter of slopes for outbound and slopes for homebound with neurons marked accordng to whether they are reset or continuous

1. 
```{r}
data <- spatial_firing %>% filter(track_category == "pospos" | track_category == "negneg" | track_category == "posneg"| track_category == "negpos" | track_category == "posnon"| track_category == "negnon")
```

2. 
```{r}
pi_data <- subset(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

3. subset based on position
```{r}
position_neurons <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

4. 
```{r}
reset <- position_neurons %>% filter(reset_group == "Reset")
continuous <- position_neurons %>% filter(reset_group == "Continuous")
```

5. 
```{r}

ggplot() + 
    geom_jitter(data=continuous,aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), color=factor(unlist(lm_group_b)))) +
    geom_jitter(data=reset,aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), color=factor(unlist(lm_group_b))), shape=1) +
    coord_cartesian(ylim = c(-.6,.6), xlim = c(-.6,.6)) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    geom_abline(intercept = 0, slope = -1, colour = "grey", linetype = "dashed") +
    xlab("Outbound slope") +
    ylab("Homebound slope") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=18),
          axis.text.y = element_text(size=18),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=17), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_reset.png", width = 4, height = 4) 
}
```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###

Now we want to plot population rate across whole track for diff groups so we can visualise the average firing rate

cue_group_os are as follows :

outbound homebound  reset
    +       +         n
    +       +         y
    +       -         -
    +      non        -
    -       +         -
    -       -         n
    -       -         y
    -      non        -
    
    
1. Split data based on cue independant/cue dependant

```{r}
position_neurons <- subset(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

3. subset based on position
```{r}
pi_data <-subset(position_neurons, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. make tibble with average firing rates and classifications : _just path integration neurons_
```{r}
df <- tibble(session_id = rep(pi_data$session_id, each=200),
             Position = rep(1:200, times=nrow(pi_data)), 
             Rates = unlist(pi_data$Rates_averaged_rewarded_b), 
             Outbound_beaconed = rep(pi_data$lm_group_b, each=200), 
             Homebound_beaconed = rep(pi_data$lm_group_b_h, each=200), 
             group = rep(as.character(pi_data$reset_group), each=200))

```

3. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

5. Plot average rates                                           **Negative Negative Continuous**
```{r}
ggplot(data=df_neg_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "Black") +
  theme_classic() +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,50,10), expand = c(0, 0)) +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))

if (save_figures == 1) {
 ggsave(file = "plots/Negneg_contiuous_mean.png", width = 3.5, height = 2.5) 
}
```


4. Subset data by group then average rates for plotting          **Negative Negative Reset**

```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

5. Plot data                                                    **Negative Negative Reset**
```{r}
ggplot(data=df_neg_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,30,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))

if (save_figures == 1) {
 ggsave(file = "plots/negneg_reset_mean.png", width = 3.5, height = 2.5) 
}
```



4. Subset data by group then average rates for plotting          **Negative Positive**
```{r}
df_pos_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

5. Plot data
```{r}
ggplot(data=df_pos_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))

if (save_figures == 1) {
 ggsave(file = "plots/negpos_mean.png", width = 3.5, height = 2.5) 
}
```


4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```


5. Plot data                                                    **Positive Positive Continuous**
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  #geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,30,10), expand = c(0, 0)) +
  #geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))

if (save_figures == 1) {
  ggsave(file = "plots/pospos_continuous_mean.png", width = 3.5, height = 2.5) 
}
```


4. Subset data by group then average rates for plotting          **Positive Positive Reset**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


5. Plot data                                                     **Positive Positive Reset**
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "Black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))

if (save_figures == 1) {
  ggsave(file = "plots/pospos_reset_mean.png", width = 3.5, height = 2.5)
}
```

4. Subset data by group then average rates for plotting          **Positive Negative**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
```


5. Plot data                                                        **Positive Negative**
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14), 
        panel.grid = element_blank(),
        panel.border = element_blank()) 

if (save_figures == 1) {
  ggsave(file = "plots/posneg_mean.png", width = 3.5, height = 2.5)
}
```


4. Subset data by group then average rates for plotting          **Positive Unclassified**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
```

5. Plot rates                                                     **Positive Unclassified**
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12), 
        panel.grid = element_blank(),
        panel.border = element_blank()) 

if (save_figures == 1) {
  ggsave(file = "plots/posnon_mean.png", width = 3.5, height = 2.5)
}
```

4. Subset data by group then average rates for plotting          **Negative Unclassified**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates), sd_b = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

5. Plot data                                                      **Negative Unclassified**
```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12), 
        panel.grid = element_blank(),
        panel.border = element_blank()) 

if (save_figures == 1) {
  ggsave(file = "plots/negnon_mean.png", width = 3.5, height = 2.5)
}
```






### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


### Sankey Diagrams

Now we want to plot a sankey diagram showing the slope of neurons in the outbound and homebound region. 

1.
```{r}
data <- spatial_firing %>% filter(track_category == "pospos" | track_category == "negneg" | track_category == "posneg"| track_category == "negpos" | track_category == "posnon"| track_category == "negnon")

pi_data <- subset(data, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")

pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. 
```{r}

pi_positive <-subset(pi_data, lm_group_b == "Positive")
pi_negative <-subset(pi_data, lm_group_b == "Negative")
pi_none <-subset(pi_data, lm_group_b == "Unclassified")

pi_positive_pos <-nrow(subset(pi_positive, lm_group_b_h == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_group_b_h == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_group_b_h == "Unclassified"))
pi_negative_pos <-nrow(subset(pi_negative, lm_group_b_h == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_group_b_h == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_group_b_h == "Unclassified"))
pi_none_pos <-nrow(subset(pi_none, lm_group_b_h == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_group_b_h == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_group_b_h == "Unclassified"))

pi_positive_pos_num <-nrow(subset(pi_positive, lm_group_b_h == "Positive"))
pi_positive_neg_num <-nrow(subset(pi_positive, lm_group_b_h == "Negative"))
pi_positive_none_num <-nrow(subset(pi_positive, lm_group_b_h == "Unclassified"))
pi_negative_pos_num <-nrow(subset(pi_negative, lm_group_b_h == "Positive"))
pi_negative_neg_num <-nrow(subset(pi_negative, lm_group_b_h == "Negative"))
pi_negative_none_num <-nrow(subset(pi_negative, lm_group_b_h == "Unclassified"))
pi_none_pos_num <-nrow(subset(pi_none, lm_group_b_h == "Positive"))
pi_none_neg_num <-nrow(subset(pi_none, lm_group_b_h == "Negative"))
pi_none_none_num <-nrow(subset(pi_none, lm_group_b_h == "Unclassified"))

```

```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###

1. 
```{r}
data <- spatial_firing %>% filter(track_category == "pospos" | track_category == "negneg")

```

# filter for pi neurons
```{r}
pi_data <- subset(data, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")

pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")

```


# filter for negative > negative & positive > positive
```{r}
negneg_pineurons <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Negative")
posos_pineurons <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Positive")
negpos_pineurons<-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Positive")
posneg_pineurons<-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Negative")

```

## raw numbers 
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, reset_group == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, reset_group == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, reset_group == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, reset_group == "Continuous"))
```


```{r}

data_long <- tibble(value=c(negneg_pineurons_reset, negneg_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont), 
                    
                      source= c("Negative > Negative","Negative > Negative", "Positive > Positive", "Positive > Positive"),
                     target= c("Reset", "Continuous", "Reset", "Continuous"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```


```{r}
# A connection data frame is a list of flows with intensity for each flow
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","F56666", "#FDE725FF","#B4DE2CFF" ,"#F56666", "#B4DE2CFF","FDE725FF", "#B4DE2CFF", "#B4DE2CFF"])'

#ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'


links <- data.frame(
  source=c("Positive1","Positive1", "Reset1", "Continuous1", "Negative1", "Negative1",  "Reset2", "Continuous2"), 
  target=c("Reset1","Continuous1", "Positive2", "Positive2", "Reset2", "Continuous2", "Negative2", "Negative2"), 
  value=c(pospos_pineurons_reset,pospos_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont, negneg_pineurons_reset, negneg_pineurons_cont ,negneg_pineurons_reset, negneg_pineurons_cont))
  
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=30, fontSize=13, nodePadding=15)

p


```



