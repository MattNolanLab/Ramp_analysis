---
title: "Figure5_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### ------------------------------------------------------------------------------------------ ### 


## Script aims to determine if ramp activity resets or is continuous across the reward zone


### ------------------------------------------------------------------------------------------ ### 


### First, we need to classify neurons based on their ramp activity in the homebound region, similar to that done in figure 2 analysis. 

# Run simple linear model to examine relationship between firing rate and position
_note:for now we are only interested in the homebound region of the track (110 - 170 cm)_


1. Make function to run linear model

Use lm_helper defined in analysis for figure 2.


2. run lm on all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_h_rewarded_fit_')) %>%
  select(-contains('asr_nb_h_rewarded_fit_')) %>%
  select(-contains('asr_p_h_rewarded_fit_')) %>%
  mutate(asr_b_h_rewarded_fit = pmap(list(asr_b_rewarded, 110, 170), lm_helper),
         asr_nb_h_rewarded_fit = pmap(list(asr_nb_rewarded, 110, 170), lm_helper),
         asr_p_h_rewarded_fit = pmap(list(asr_p_rewarded, 110, 170), lm_helper)) %>%
  unnest_wider(asr_b_h_rewarded_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_nb_h_rewarded_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_p_h_rewarded_fit, names_sep = "_", names_repair = "universal")
```

Linear model results are stored in:
spatial_firing$asr_b_h_rewarded_fit_pval
spatial_firing$asr_b_h_rewarded_fit_slope
spatial_firing$asr_b_h_rewarded_fit_r.squared


3. Plot coefficients of model (slope and r2 value) for each neuron
```{r}
ggplot(data=spatial_firing, aes(x = asr_b_h_rewarded_fit_slope,
                                y = asr_b_h_rewarded_fit_r.squared)) +
    coord_cartesian(xlim = c(-0.7,0.7), ylim = c(0,1)) +
    geom_point() +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    scale_color_manual(values=c("grey82", "grey32", "violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
  ggsave(file = "plots/shuff_lm_homebound_allcells.png", width = 4, height = 5)
}

```


### ---------------------------------------------------------------------------- ### 

## Identification of homebound ramp cells in dataset 

Ramp like cells are identified by whether the coefficients of the linear model lie outside the 95% confidence intervals of the same result from 1000 shuffled datasets

Beause the homebound zone is the same length as the outbound zone, and as shuffling is across the full track length, we can use the shuffle results generated for Figure 2.

### classify neurons based on shuffle activity

If outside the 95% of the shuffled dataset, a neuron is considered to have ramp like activity along the track. 

First we want to correct the pvals of the lm, to account for multiple comparisons

1. put all pvalues into tibble then adjust using p.adjust from - package
```{r}
p_vals_b <- tibble(pvals = spatial_firing$asr_b_h_rewarded_fit_p.value)
adu_p_b <- tibble(adjust_pval_b_h = p.adjust(p_vals_b$pvals, "BH"))

```

2. bind new adjusted pvalues to dataframe
```{r}
spatial_firing <- cbind(spatial_firing, adu_p_b)
```

3. do the same for non-beaconed trials
```{r}
p_vals_nb <- tibble(pvals = spatial_firing$asr_nb_h_rewarded_fit_p.value)
adu_p_nb <- tibble(adjust_pval_nb_h = p.adjust(p_vals_nb$pvals, "BH"))
spatial_firing <- cbind(spatial_firing, adu_p_nb)
```

3. do the same for probe trials 
```{r}
p_vals_p <- tibble(pvals = spatial_firing$asr_p_h_rewarded_fit_p.value)
adu_p_p <- tibble(adjust_pval_p_h = p.adjust(p_vals_p$pvals, "BH"))
spatial_firing <- cbind(spatial_firing, adu_p_p)
```

Now we want to classify neurons, taking the adjusted significance into account

Uses the function compare_slopes from Figure 2.

#compare_slopes(spatial_firing$shuffle_min_slope_b_o[[1]], spatial_firing$shuffle_max_slope_b_o, spatial_firing$asr_b_h_rewarded_fit_slope[[1]], spatial_firing$adjust_pval_b_h)

```{r}

spatial_firing <- spatial_firing %>%
  mutate(
    lm_group_b_h = pmap(
      list(
        shuffle_min_slope_b_o,
        shuffle_max_slope_b_o,
        asr_b_h_rewarded_fit_slope,
        adjust_pval_b_h
      ),
      compare_slopes
    ),
    lm_group_nb_h = pmap(
      list(
        shuffle_min_slope_nb_o,
        shuffle_max_slope_nb_o,
        asr_nb_h_rewarded_fit_slope,
        adjust_pval_nb_h
      ),
      compare_slopes
    ),
    lm_group_p_h = pmap(
      list(
        shuffle_min_slope_p_o,
        shuffle_max_slope_p_o,
        asr_p_h_rewarded_fit_slope,
        adjust_pval_p_h
      ),
      compare_slopes
    )
  )

```

Linear model classification is stored in:
spatial_firing$lm_group_b_h
spatial_firing$lm_group_nb_h
spatial_firing$lm_group_p_h


### ------------------------------------------------------------------------------------------ ### 


Now, we can classify cells based on their activity in the outbound and homebound region

i.e. pospos = positive in outbound, positive in homebound
i.e. posneg = positive in outbound, negative in homebound

1. write function to mark cells based on groups
```{r}
mark_track_category <- function(outbound, homebound){
  if (is.na(outbound) ) {
    return( "None" )  
  } else if( outbound == "Positive" & homebound == "Negative") {
    return( "posneg" ) 
  } else if( outbound == "Positive" & homebound == "Positive") {
    return( "pospos" )
  } else if( outbound == "Negative" & homebound == "Positive") {
    return( "negpos" )
  } else if( outbound == "Negative" & homebound == "Negative") {
    return( "negneg" )
  } else if( outbound == "Negative" & homebound == "Unclassified") {
    return( "negnon" )
  } else if( outbound == "Positive" & homebound == "Unclassified") {
    return( "posnon" )
  } else {
    return("None")
  }
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(track_category = map2(lm_group_b, lm_group_b_h, mark_track_category))

```


### ------------------------------------------------------------------------------------------ ### 

Now, we want to know what proportion of cells fit this group 
_note : we focus on cue-independent neurons here as classified in Figure 4 (Figure4_A.Rmd)_

1. Find cue independent cells
_note: cue_group_o is defined in Figure4_Analysis.Rmd_
```{r}
cueindependent_neurons <- subset(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

2. find proportion of cue independent cells that fall into groups as catagorised above (pospos, posneg etc)
```{r}
# positive homebound slopes
pospos <-nrow(subset(cueindependent_neurons, track_category == "pospos"))/nrow(cueindependent_neurons)*100
posneg <-nrow(subset(cueindependent_neurons, track_category == "posneg"))/nrow(cueindependent_neurons)*100
negneg <-nrow(subset(cueindependent_neurons, track_category == "negneg"))/nrow(cueindependent_neurons)*100
negpos <-nrow(subset(cueindependent_neurons, track_category == "negpos"))/nrow(cueindependent_neurons)*100

# positive homebound slopes
pospos_num <-nrow(subset(cueindependent_neurons, track_category == "pospos"))
posneg_num <-nrow(subset(cueindependent_neurons, track_category == "posneg"))
negneg_num <-nrow(subset(cueindependent_neurons, track_category == "negneg"))
negpos_num <-nrow(subset(cueindependent_neurons, track_category == "negpos"))

```

3. put proportions into tibble for plotting
```{r}

proportions_mixed_ramps <- tibble(perc=c(pospos, posneg, negneg, negpos), num=c(pospos_num, posneg_num, negneg_num, negpos_num), ramp_id= c("+ +", "+ -", "- - ", "- +"),ramp_type = c("+ +", "+ -", "- - ", "- +"))

```

5. Plot pie chart of proportions
```{r}

# Create Data
data <- data.frame(
  group=LETTERS[1:4],
  value=c(pospos,posneg,negneg,negpos)
)

# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")

if (save_figures == 1) {
 ggsave(file = "plots/Reset_cellproportions_cueindependant.png", width = 4, height = 4) 
}
```



### ------------------------------------------------------------------------------------------ ### 

Now, we want to find out if within pospos and negneg groups - are their firing rate reset or continue across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 


First, normalise firing rates. 

1. make function to load rates and normalise
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates = map(Rates_averaged_rewarded_b, normalise_rates))

```

Then, predict firing rate in homebound region based on fit from real data in outbound region

1. make function to predict firing rate
```{r}
lm_predict <- function(df){
  new.data <- data.frame(Position =df$Position)
}
```

3. Predict mean and confidence intervals for firing rate at the start of the homebound zone (track positions 110 to 115 cm) based on firing in the outbound zone (30 to 90 cm).
```{r}
predict_homebound <- function(df, fit_start = 30, fit_end = 90, predict_start = 110, predict_end = 115){
  # check for NAs
  if(all(is.na(df))) 
    return(NA)
  # Make track column
  df <- tibble(Rates = unlist(df), Position=rep(1:200))
  # fit
  model <- lm(Rates ~ Position, data = filter(df, Position >= fit_start, Position <= fit_end))
  # predict
  homebound_prediction_pos <- tibble(Position = rep(1:200))
  #homebound_prediction <- predict(model, newdata = homebound_prediction_pos, interval = "confidence")
  homebound_prediction <- predict(model, newdata = homebound_prediction_pos, interval = "prediction", level = 0.99) 
  as.tibble(homebound_prediction)
}


```

Test whether data lies outside of confidence intervals
```{r}
offset_test <- function(rates, lwr, upr){
    # check for NAs
 if(all(is.na(rates))) 
    return(NA)
  rates <- mean(as.double(rates[110:115]))
  upr <- mean(as.double(upr[110:115]))
  lwr <- mean(as.double(lwr[110:115]))
 if(rates > upr) {
   return("Pos")
 }

 if (rates < lwr) {
   return("Neg")
 }
    return("None")

}
```

Calculate difference between mean rate and predicted mean rate at the start of the homebound zone
```{r}
calc_predict_diff <- function(rates, fit)
{
  diff <- mean(as.double(rates[110:115])) - mean(as.double(fit[110:115]))
  }
```

2. Run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_')) %>%
  mutate(predict_params = map(normalised_rates, predict_homebound)) %>%
  unnest_wider(predict_params, names_sep = "_", names_repair = "universal") 

spatial_firing <- spatial_firing %>%
  mutate(offset = pmap_chr(list(normalised_rates, predict_params_lwr, predict_params_upr), offset_test),
         predict_diff = map2_dbl(normalised_rates, predict_params_fit, calc_predict_diff))

```


### ------------------------------------------------------------------------------------------ ### 

Now, we can classify cells based on their predicted activity. 

1. Function to classify neurons based on offset 

```{r}
mark_reset_group_predict <- function(offset){
  if (is.na(offset) ) {
    return( "None" )
  } else if( offset == "None") {
    return( "Continuous" )
  } else if( ( offset == "Neg" ||  offset == "Pos")) {
    return( "Reset" ) 
  }
}

```

2. Run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reset_group = map(offset, mark_reset_group_predict))

```



### ------------------------------------------------------------------------------------------ ### 


## plot bar chart of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone

1. extract neurons that are ++ or -- on beaconed trials, position encoding (Figure 3) and driven by path integration (Figure 4)
```{r}
df_position_pi <- spatial_firing %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")  %>% 
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
  
```

4. Plot bar charts - positive neurons
```{r}
ggplot(data=subset(df_position_pi, lm_group_b == "Positive"), aes(x = unlist(predict_diff), fill=as.factor(unlist(reset_group)))) +
  coord_cartesian(xlim=c(-6,6)) +
  geom_histogram(aes(y=..count..), alpha=0.5) +
  scale_fill_manual(values=c(  "grey", "chartreuse3","chartreuse3")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictHomeboundMean_PIpositive_pi.png",width = 4, height = 2.5)
}
```

5. Plot bar charts - Negative neurons
```{r}

ggplot(data=subset(df_position_pi,lm_group_b == "Negative"), aes(x = unlist(predict_diff), fill=as.factor(unlist(reset_group)))) +
  coord_cartesian(xlim=c(-5,5)) +
  geom_histogram(aes(y=..count..), alpha=0.5) +
  scale_fill_manual(values=c( "grey", "violetred2","violetred2")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictHomeboundMean_PInegative_pi.png",width = 4, height = 2.5)
}
```




### ------------------------------------------------------------------------------------------ ### 


## now plot scatter of slopes for outbound and slopes for homebound with neurons marked accordng to whether they are reset or continuous

1. Here we subset neurons based on position encoding (Figure 3) and path integrating (Figure 4) and either reset or contiuous firing. 
```{r}
position_neurons_reset <- spatial_firing  %>% 
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")  %>% 
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")  %>% 
  filter(reset_group == "Reset")

position_neurons_continuous <- spatial_firing  %>% 
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")  %>% 
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")  %>% 
  filter(reset_group == "Continuous")
```

2. Plot scatter plot
```{r}

ggplot() + 
    geom_point(data=subset(position_neurons_reset, track_category == "pospos" | track_category == "negneg"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), alpha=0.8) +
    geom_point(data=subset(position_neurons_reset, track_category == "posneg" | track_category == "negpos"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), shape=2, alpha=0.8) +
    geom_point(data=subset(position_neurons_reset, track_category == "posnon" | track_category == "negnon"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), shape=3, alpha=0.8) +  
      geom_point(data=subset(position_neurons_continuous, track_category == "pospos" | track_category == "negneg"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), shape=1, alpha=0.8) +

      #geom_point(data=position_neurons_reset,aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), color=factor(unlist(lm_group_b)))) +
    #geom_point(data=position_neurons_continuous,aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), y = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), color=factor(unlist(lm_group_b))), shape=1) +
    coord_cartesian(ylim = c(-.45,.61), xlim = c(-.45,.45)) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    geom_abline(intercept = 0, slope = -1, colour = "grey", linetype = "dashed") +
    xlab("Outbound slope") +
    ylab("Homebound slope") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=18),
          axis.text.y = element_text(size=18),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=17), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_reset.png", width = 4, height = 4) 
}
```



### ------------------------------------------------------------------------------------------ ### 

Now we want to plot population rate across whole track for diff groups so we can visualise the average firing rate

groups are as follows :

outbound homebound  reset
    +       +         n
    +       +         y
    +       -         -
    +      non        -
    -       +         -
    -       -         n
    -       -         y
    -      non        -
    
    
1. Split data based on cue independant/cue dependant
```{r}
position_neurons <- subset(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

3. subset based on position
```{r}
pi_data <-subset(position_neurons, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. make tibble with average firing rates and classifications : _just path integration neurons_
```{r}
df <- tibble(session_id = rep(pi_data$session_id, each=200),
             Position = rep(1:200, times=nrow(pi_data)), 
             Rates = unlist(pi_data$Rates_averaged_rewarded_b), 
             Outbound_beaconed = rep(pi_data$lm_group_b, each=200), 
             Homebound_beaconed = rep(pi_data$lm_group_b_h, each=200), 
             group = rep(as.character(pi_data$reset_group), each=200))

```

3. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
```

Function to plot mean and SEM of firing rate as a function of position.
```{r}
mean_SEM_plots <- function(df, colour1 = "black"){
  ggplot(data=df) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_r, ymin = mean_r - sem_r, ymax = mean_r + sem_r), fill = "Blue", alpha=0.2) +
  geom_line(aes(y=mean_r, x=Position), color = "Blue") +
  theme_classic() +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  scale_y_continuous(breaks=seq(5,50,10), expand = c(0, 0)) +
  labs(y = "Mean firing rate (Hz)\n", x = "Position") +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))
}

```


5. Plot average rates                                           **Negative Negative Continuous**
```{r}
mean_SEM_plots(df_neg_cue)

if (save_figures == 1) {
 ggsave(file = "plots/Negneg_contiuous_mean.png", width = 3.5, height = 2.5) 
}
```


4. Subset data by group then average rates for plotting          **Negative Negative Reset**

```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
mean_SEM_plots(df_neg_cue)

if (save_figures == 1) {
 ggsave(file = "plots/negneg_reset_mean.png", width = 3.5, height = 2.5) 
}
```



4. Subset data by group then average rates for plotting          **Negative Positive**
```{r}
df_pos_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))

mean_SEM_plots(df_pos_cue)

if (save_figures == 1) {
 ggsave(file = "plots/negpos_mean.png", width = 3.5, height = 2.5) 
}
```


4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))
  
mean_SEM_plots(df_pos_pi)


if (save_figures == 1) {
  ggsave(file = "plots/pospos_continuous_mean.png", width = 3.5, height = 2.5) 
}
```


4. Subset data by group then average rates for plotting          **Positive Positive Reset**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE), sem_r = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))

mean_SEM_plots(df_pos_pi)

if (save_figures == 1) {
  ggsave(file = "plots/pospos_reset_mean.png", width = 3.5, height = 2.5)
}
```

4. Subset data by group then average rates for plotting          **Positive Negative**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))


mean_SEM_plots(df_pos_pi)

if (save_figures == 1) {
  ggsave(file = "plots/posneg_mean.png", width = 3.5, height = 2.5)
}
```


4. Subset data by group then average rates for plotting          **Positive Unclassified**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))


mean_SEM_plots(df_pos_pi)

if (save_figures == 1) {
  ggsave(file = "plots/posnon_mean.png", width = 3.5, height = 2.5)
}
```

4. Subset data by group then average rates for plotting          **Negative Unclassified**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates), sem_r = std.error(Rates)) %>%
  mutate(Position = rep(-30:169))

mean_SEM_plots(df_pos_pi)

if (save_figures == 1) {
  ggsave(file = "plots/negnon_mean.png", width = 3.5, height = 2.5)
}
```

###
### ------------------------------------------------------------------------------------------ ### 

## Calculate number of neurons that areset/switch/continuous across outbound and homebound

_Figure 5 stats_

1. First, select cells that are position encoding (figure 3)
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Select cells that are path integrating i.e. have slopes on both the beaconed and non-beaconed (Figure 4)
```{r}
pi_data <- subset(position_cells, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

3. For this group of neurons, find numbers of cells that fit different patterns of outbound/homebound slope
```{r}

pospos <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Positive")
negneg <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Negative")

posneg <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Negative")
negpos <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Positive")

posnon <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Unclassified")
negnon <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Unclassified")


pospos_r <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Positive" & reset_group == "Reset")
pospos_c <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Positive" & reset_group == "Continuous")
negneg_r <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Negative" & reset_group == "Reset")
negneg_c <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Negative" & reset_group == "Continuous")

```

4. calculate number of neurons that switch slope, stay the same or are reset/continuous
```{r}
switch_slope <- nrow(posneg) + nrow(negpos)
only_outbound_slope <- nrow(posnon) + nrow(negnon)
same_slope <- nrow(pospos) + nrow(negneg)
same_slope_reset <- nrow(pospos_r) + nrow(negneg_r)
same_slope_continuous <- nrow(pospos_c) + nrow(negneg_c)

```


