---
title: "RampCodes_Figure5"
author: "Sarah Tennant & Matt Nolan"
date: "20/10/2021"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### --------------------------------------------------------------------------------- ###


## Runs analysis that compares cued trials (Beaconed) to uncued (Non-beaconed + Probe)


### --------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons have the following patterns of ramp activity:

1. Cue-independent ('PI'): ramp in both cued (B) and uncued (NB/P)
2. Cue-dependent ('cue'): ramp in just cued (B)
3. Cue-impaired ('onlypi'   ): ramp in just uncued (NB/P)

To classify cells into these categories above, we will use the classification established in Figure 2. This requires that Figure 2 analyses have been run for B and NB/P groups. Note that in the code 'nb' includes non-beaconed and probe trials.

1. Make function to classify cells based on activity in beaconed / non-beaconed & probe trials 
```{r}
mark_neurons <- function(beac, nb){
  if (is.na(beac) | is.na(nb) ) {
    return( "None" )
  } else if( beac == "Positive" & nb == "Positive") {
    return( "Positive-PI" )
  } else if( beac == "Negative" & nb == "Negative") {
    return( "Negative-PI" )
  } else if( beac == "Positive" & nb == "Unclassified") {
    return( "Positive-cue" )
  } else if( beac == "Negative" & nb == "Unclassified") {
    return( "Negative-cue" )
  } else if( beac == "Unclassified" & nb == "Positive") {
    return( "Positive-onlypi" )
  } else if( beac == "Unclassified" & nb == "Negative") {
    return( "Negative-onlypi" )
  } else if( beac == "Unclassified" & nb == "Unclassified") {
    return( "Unclassified" )
    } else {
    return("None")
  }
}
```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(cue_group_o = map2(lm_group_b, lm_group_p, mark_neurons))
```


_Figure 4B-E stats_
position encoding ramp neurons were classified with a similar slope on the non-beaconed and probe trials as on beaconed trials ....
1. extract position cells
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")

position_ramp_cells <- subset(position_cells, lm_group_b == "Negative" | lm_group_b == "Positive")

```

2. from above, extract position neurons that are ramp like in beaconed trials
```{r}
pos_position_cells <- subset(position_ramp_cells, lm_group_b == "Positive")
neg_position_cells <- subset(position_ramp_cells, lm_group_b == "Negative")
```

3. find neurons that maintain ramp polarity in the non beaconed trial
```{r}
posnb_position_cells <- nrow(subset(pos_position_cells, lm_group_p == "Positive"))
negnb_position_cells <- nrow(subset(neg_position_cells, lm_group_p == "Negative"))

```

4. calculate numbers of neurons that stay the same slope in beaconed and non beaconed
```{r}
total <- nrow(pos_position_cells) + nrow(neg_position_cells)
neurons_same <- (posnb_position_cells + negnb_position_cells)
```

Do the same as above but for neurons that switch ramp polarity in the non beaconed trial

1. extract position ramp neurons that switch ramp polarity on the non-beaconed trial
```{r}
posnb_position_cells <- nrow(subset(pos_position_cells, lm_group_p != "Positive"))
negnb_position_cells <- nrow(subset(neg_position_cells, lm_group_p != "Negative"))
```

2. calculate number of neurons that change slope on beaconed and non beaconed
```{r}
total <- nrow(pos_position_cells) + nrow(neg_position_cells)
neurons_diff <- (posnb_position_cells + negnb_position_cells)
```

3. finally, also want to calculate numbers of neurons that are unclassified on beaconed and ramp like on non-beaconed
```{r}
un_position_cells <- subset(spatial_firing, lm_group_b == "Unclassified")
unnb_position_cells <- nrow(subset(un_position_cells, lm_group_p == "Positive" | lm_group_p == "Negative"))

```


### ----------------------------------------------------------------------------------------- ###


Visualise the proportion of cells that fit the above criteria.  

We will first focus on neurons classified as having a positive or negative slope in Figure 2. A problem with this analysis is that it includes neurons that in Figure 3 are shown to be modulated by speed or acceleration but not position. The further analysis below will address this.


Function to return a tibble with proportions of neurons classified as cue-dependent, cue-independent or path integration only.
```{r}
calc_props_cue_dep <- function(cue_group){
  cue_group <- as.character(cue_group)
  num_cells <- length(cue_group)
  
  pi_num <- length(which(cue_group == "Positive-PI" | cue_group == "Negative-PI"))
  cue_num <- length(which(cue_group == "Positive-cue" | cue_group == "Negative-cue"))
  pionly_num <- length(which(cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi"))
  uc_num <- length(which(cue_group == "Unclassified"))
  none_num <- length(which(cue_group == "None"))
  
  pi <- pi_num / num_cells
  cue <- cue_num / num_cells
  pionly <- pionly_num / num_cells
  uc <-uc_num / num_cells
  none <- none_num / num_cells

proportions_mixed_ramps <- tibble(perc=c(pi, cue, pionly, uc, none), num=c(pi_num, cue_num, pionly_num, uc_num, none_num),ramp_type = c("Cue-independent", "Cue-dependant", "Path-Integration-only", "Unclassified", "None"))
}
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_mixed_ramps <- calc_props_cue_dep(spatial_firing$cue_group_o)
```


Plot a pie chart of results, 
_note : pie segments represent the proportions with numbers in text_
```{r}
proportions_mixed_ramps_pi_maker <- function(df){
  # Compute the position of labels
data <- df %>% 
  arrange(desc(ramp_type)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_type)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")
}

proportions_mixed_ramps_pi_maker(proportions_mixed_ramps)

if (save_figures == 1) {
  ggsave(file = "plots/CueComparison_proportions.png", width = 4, height = 4)
}
```




### -------------------------------------------------------------------------------------------------------- ###

We also want to compare the classification of neurons between cued and uncued trials. We will do this using a Sankey plot

We need a pair of vectors called 'value' that contain the number of cells for each group transition between 'source' and 'target', which are categories for slopes the beaconed and the non-beaconed trials.
The transitions will be ordered as:
++
+-
+NC
-+
--
-NC
NC+
NC-
NCNC

```{r}
# ob_group and h_group are column names from the results data frame that contain the grouping information.
calc_transitions <- function(group1, group2){
  df <- tibble(g1 = as.character(group1), g2 = as.character(group2))
  
  transition_values <- c(length(which(df$g1 == "Positive" & df$g2 == "Positive")),
                         length(which(df$g1 == "Positive" & df$g2 == "Negative")),
                         length(which(df$g1 == "Positive" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Negative" & df$g2 == "Positive")),
                         length(which(df$g1 == "Negative" & df$g2 == "Negative")),
                         length(which(df$g1 == "Negative" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Positive")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Negative")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Unclassified")))
  transition_values_long <- tibble(value = transition_values,
                                   source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "Unclassified","Unclassified", "Unclassified"),
                                   target= c(" Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified")
                                   ) %>%
    filter(value > 0)
  
  nodes <- data.frame(name=c(as.character(transition_values_long$source), as.character(transition_values_long$target)) %>% unique())
  transition_values_long$IDsource=match(transition_values_long$source, nodes$name)-1
  transition_values_long$IDtarget=match(transition_values_long$target, nodes$name)-1
  return(transition_values_long)
}
```

Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long <- calc_transitions(spatial_firing$lm_group_b, spatial_firing$lm_group_p)

# Probably a more elegant way to do this as already made in calc_transitions
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

```

Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#66cd00","#EE3A8C", "#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```





### ------------------------------------------------------------------------------------------ ### 

## Seperate 

```{r}
spatial_firing_high  <- subset(spatial_firing, max_trial_number >= 60 )
```


1. Write function to add position
```{r}
add_position <- function(df, session_id, cluster_id) {
  sum = sum(unlist(df), na.rm=TRUE)
  return(sum)
}
```

2. Run on dataframe : Average trials with reward

input columns: 
Rates_averaged_rewarded_b = beaconed trials
Rates_averaged_rewarded_nb = non-beaconed and probe trials
Rates_averaged_rewarded_p = probe trials only
```{r}
spatial_firing_high <- spatial_firing_high %>%
  mutate(asr_p_sum = pmap(list(Rates_averaged_rewarded_p, session_id, cluster_id), add_position))
```

```{r}
spatial_firing_probeonly <- subset(spatial_firing_high, asr_p_sum != 0 )
```


### ----------------------------------------------------------------------------------------------- ###

### ------------------------------------------------------------------------------------------ ### 


_same as above but just for position modulated cells_

Here, we want to focus the analysis exclusively on neurons that have a +/- slope on beaconed trials (Figure 2) and are position modulated (Figure 3).

```{r}
position_neurons <- filter(spatial_firing_probeonly, lm_group_b == "Positive" | lm_group_b == "Negative",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_pos_mixed_ramps <- calc_props_cue_dep(position_neurons$cue_group_o)

proportions_mixed_ramps_pi_maker(proportions_pos_mixed_ramps)
```


```{r}
# ob_group and h_group are column names from the results data frame that contain the grouping information.
calc_transitions <- function(group1, group2){
  df <- tibble(g1 = as.character(group1), g2 = as.character(group2))
  
  transition_values <- c(
                         length(which(df$g1 == "Positive" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Negative" & df$g2 == "Unclassified")))
  transition_values_long <- tibble(value = transition_values,
                                   source= c("Positive", "Negative"),
                                   target= c(" Unclassified"," Unclassified")
                                   ) %>%
    filter(value > 0)
  
  nodes <- data.frame(name=c(as.character(transition_values_long$source), as.character(transition_values_long$target)) %>% unique())
  transition_values_long$IDsource=match(transition_values_long$source, nodes$name)-1
  transition_values_long$IDtarget=match(transition_values_long$target, nodes$name)-1
  return(transition_values_long)
}
```

Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long_pos <- calc_transitions(position_neurons$lm_group_b, position_neurons$lm_group_p)

# Probably a more elegant way to do this as already made in calc_transitions
nodes_pos <- data.frame(name=c(as.character(data_long_pos$source), as.character(data_long_pos$target)) %>% unique())

```

Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#66cd00","#EE3A8C", "#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long_pos, Nodes = nodes_pos,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}


```




```{r}
position_neurons <- filter(spatial_firing_probeonly, lm_group_b_h == "Positive" | lm_group_b_h == "Negative",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```



Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long_pos <- calc_transitions(position_neurons$lm_group_b_h, position_neurons$lm_group_p_h)

# Probably a more elegant way to do this as already made in calc_transitions
nodes_pos <- data.frame(name=c(as.character(data_long_pos$source), as.character(data_long_pos$target)) %>% unique())

```

Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#66cd00","#EE3A8C", "#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long_pos, Nodes = nodes_pos,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}


```

### --------------------------------------------------------------------------------------- ###

Now we want to visualise the average firing rate for each of the groups (cue dependant & cue independent / positive & negative).

We will again focus exclusively on neurons that have a +/- slope (Figure 2) and are position modulated (Figure 3). To do so we will use the tibble 'position_neurons' generated above.

Function to plot data mean and SEM of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SEM_plots_BvsNB <- function(df, group_b, group_p, x_start = -10, x_end = 70){
  df <- df %>%
    filter(lm_group_b == group_b,
           lm_group_p == group_p) %>%
    select(normalised_rates, normalised_rates_p, cue_group_o) %>%
    unnest(c(normalised_rates, normalised_rates_p))
 df$normalised_rates <- as.double(df$normalised_rates)
 df$normalised_rates_p <- as.double(df$normalised_rates_p)
 df$cue_group_o <- as.character(df$cue_group_o)
 numcells <- length(df$normalised_rates)/200
 df$Position <- rep(-30:169, times = numcells)
 
 df <- df %>%
   group_by(cue_group_o, Position) %>%
   summarise(mean_b = mean(normalised_rates, na.rm = TRUE),
             mean_p = mean(normalised_rates_p, na.rm = TRUE),
             se_b = std.error(normalised_rates, na.rm = TRUE),
             se_p = std.error(normalised_rates_p, na.rm = TRUE))
 
 ggplot(data=df) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_p, ymin = mean_p - se_p, ymax = mean_p + se_p), fill = "blue", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_p, x=Position), color = "blue") +
  annotate("rect", xmin=-10, xmax=0, ymin=-1.5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=70, ymin=-1.5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  theme_classic() +
  labs(y = "Z-scored firing rate", x = "Location (cm)") +
  xlim(x_start, x_end) +
  ylim(-1.5, 2.5) +
  #scale_x_discrete(breaks=c("40","60","80"), labels=c("10", "30", "50")) +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        text = element_text(size=14))
}
```



Subset data by group then average rates for plotting          **Negative Cue**
```{r}
(NegUC_plot <- mean_SEM_plots_BvsNB(position_neurons, "Negative", "Unclassified"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_NegCue.png", width = 3, height = 2.35)
}
```


Subset data by group then average rates for plotting          **Positive Cue**
```{r}
(PosUC_plot <- mean_SEM_plots_BvsNB(position_neurons, "Positive", "Unclassified"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_PosCue.png", width = 3, height = 2.35)
}
```


Subset data by group then average rates for plotting          **Positive PI**

```{r}
(PosPos_plot <- mean_SEM_plots_BvsNB(position_neurons, "Positive", "Positive"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_PosPI.png", width = 3, height = 2.35)
}
```


Subset data by group then average rates for plotting          **Negative PI**

```{r}
(NegNeg_plot <- mean_SEM_plots_BvsNB(position_neurons, "Negative", "Negative"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_NegPI.png", width = 3, height = 2.35)
}
```


Subset data by group then average rates for plotting          **Negative PI only**

These data are not in position neurons so make a new data frame containing these neurons.
```{r}
unclassified_neurons <- filter(spatial_firing, lm_group_b == "Unclassified")
```

```{r}
(UCNeg_plot <- mean_SEM_plots_BvsNB(unclassified_neurons, "Unclassified", "Negative"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)
}
```

Subset data by group then average rates for plotting          **Positive PI only**

```{r}
(UCPos_plot <- mean_SEM_plots_BvsNB(unclassified_neurons, "Unclassified", "Positive"))

if (save_figures == 1) {
 ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5) 
}
```





###----------------------------------------------------------------------------------------------###
Additional analyses related to Figure 5.

First split data based on cue independent/cue dependent as we are only interested in position neurons here
```{r}
cue_independant_neurons <- filter(position_neurons, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
cue_dependant_neurons <- filter(position_neurons, cue_group_o == "Positive-cue" | cue_group_o == "Negative-cue")

```


Make bar charts showing the distribution of P, PS, PA and PSA neurons.
```{r}
make_mm_class_bar <- function(df){
  pos <-subset(df, lm_group_b == "Positive")
  neg <-subset(df, lm_group_b == "Negative")
  mixed_ramps <- tibble(perc=c(nrow(subset(pos, final_model_o_b == "P"))/nrow(pos)*100,
                             nrow(subset(neg, final_model_o_b == "P"))/nrow(neg)*100,
                             nrow(subset(pos,final_model_o_b == "PS"))/nrow(pos)*100,
                             nrow(subset(neg,final_model_o_b == "PS"))/nrow(neg)*100,
                             nrow(subset(pos ,final_model_o_b == "PA"))/nrow(pos)*100,
                             nrow(subset(neg ,final_model_o_b == "PA"))/nrow(neg)*100,
                             nrow(subset(pos ,final_model_o_b == "PSA"))/nrow(pos)*100, 
                             nrow(subset(neg ,final_model_o_b == "PSA"))/nrow(neg)*100), 
                      
                      ramp_id= c("P","P", 
                                 "PS", "PS",
                                 "PA", "PA", 
                                 "PAS", "PAS"), 
                      ramp_type= rep(c("Positive", "Negative"), 4))
  
  level_order <- c("P", "PS", "PA", "PAS")
ggplot(mixed_ramps, aes(x= factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons") +
  scale_fill_manual(values=c("firebrick1","gold", "darkorchid1", "darkslategray")) +
  #scale_fill_brewer(palette= "RdYlBu") +
  theme_classic() +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
}

make_mm_class_bar(cue_dependant_neurons)

if (save_figures == 1) {
  ggsave(file = "plots/LMERProportions_beaconed_cuedependant.png", width = 4, height = 4.5)
}


make_mm_class_bar(cue_independant_neurons)

if (save_figures == 1) {
 ggsave(file = "plots/LMERProportions_beaconed_cueindependant.png", width = 4, height = 4.5) 
}
```




Plot the distribution of standardised coefficients for cue-dependent and cue-independent cells with positve / negative slopes.

Use function 'standard_plot' from Figure 3. This expects a tibble with columns 'coef_type' (either P, S or A) and 'coef' (the coefficients)

Make tibble for coefficient plots
4. put data into a tibble for plotting.
```{r}
data_coef_2 <- tibble(session_id = rep(unlist(position_neurons$unique_id), times=3), 
                    cluster_id = rep(position_neurons$cluster_id, times=3), 
                    coef = c(as.character(position_neurons$o_b_mod_coefs_pos),
                             as.character(position_neurons$o_b_mod_coefs_speed),
                             as.character(position_neurons$o_b_mod_coefs_accel)),
                    group = rep(as.character(position_neurons$final_model_o_b), 3),
                    cue_group = rep(as.character(position_neurons$cue_group_o), 3),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(position_neurons)),
                    lm_result = rep(as.character(position_neurons$lm_group_b), times=3))
```

Use function 'standard_plot' from Figure 2. This expects a tibble with columns 'coef_type' (either P, S or A) and 'coef' (the coefficients)


Plot coefficients for cells classified in Figure 3 as having 'significant' positional coefficients in the mixed effect model, and Figure 4 as having ramp-like activity on both beaconed and non-beaconed/probe trials. 

```{r}
data_coef_PSA_PI_pos <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Positive-PI")

(PSA_PI_pos_coef_plot <- standard_plot(data_coef_PSA_PI_pos))

if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PSAPIposcells.png", width = 2.2, height = 3.5)
}


```


```{r}
data_coef_PSA_PI_neg <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Negative-PI")

(PSA_PI_neg_coef_plot <- standard_plot(data_coef_PSA_PI_neg))

if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PSAPInegcells.png", width = 2.2, height = 3.5)
}
```



Plot coefficients for cells classified in Figure 2 as having 'significant' positional coefficients in the mixed effect model, and Figure 4 as having ramp-like activity on beaconed but not non-beaconed/probe trials. 


```{r}
data_coef_PSA_cue_pos <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Positive-cue")

standard_plot(data_coef_PSA_cue_pos)
```


```{r}
data_coef_PSA_cue_neg <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Negative-cue")

standard_plot(data_coef_PSA_cue_pos)
```


### ----------------------------------------------------------------------------------------- ###

_Figure 5C stats_

Compare coefficients for position, speed and acceleration from lmer model for neurons that maintain slope on beaconed and non beaconed


1.focus on all position neurons (Figure 2) that have positive or negative slope (Figure 1)
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA" )

position_ramp_cells <- subset(position_cells, lm_group_b == "Negative" | lm_group_b == "Positive")

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save <- select(position_ramp_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

```

3. put data into a tibble for plotting
```{r}
data_coef <- tibble(session_id = rep(unlist(spatial_firing_save$unique_id), times=3), 
                    cluster_id = rep(spatial_firing_save$cluster_id, times=3), 
                    coef = c(as.character(spatial_firing_save$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b)), 
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save)),
                    lm_result = rep(as.character(spatial_firing_save$lm_group_b), times=3))
```

4. run anova
```{r}
one.way <- aov(coef ~ coef_type, data = data_coef)

summary(one.way)
```

5. Post hoc Tukey's test
```{r}
tukey.test <- TukeyHSD(one.way)
tukey.test$coef_type
```


same as above but split by positive or negative slope
1.focus on all position neurons (Figure 2)
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Split by positive or negative slope (Figure 1)
```{r}
pos_position_cells <- subset(spatial_firing, lm_group_b == "Positive")
neg_position_cells <- subset(spatial_firing, lm_group_b == "Negative")

```

3. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save <- select(pos_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

```

4. put data into a tibble for plotting
```{r}
data_coef <- tibble(session_id = rep(unlist(spatial_firing_save$unique_id), times=3), 
                    cluster_id = rep(spatial_firing_save$cluster_id, times=3), 
                    coef = c(as.character(spatial_firing_save$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b)), 
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save)),
                    lm_result = rep(as.character(spatial_firing_save$lm_group_b), times=3))
```

5. run anova
```{r}
one.way <- aov(coef ~ coef_type, data = data_coef)

summary(one.way)
```

6. Post hoc Tukey's test
```{r}
tukey.test <- TukeyHSD(one.way)
tukey.test$coef_type
```






### ------------------------------------------------------------------------------------------------------------------- ###

We want to know about whether the slope classification of neurons on beaconed trials is maintained on probe trials.

We first ask this question for all neurons whose classification is independent of the reward zone cue.

1. Split by position neurons (Figure 2)
```{r}
position_cells <- subset(spatial_firing_high , final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Select cells that have slopes on both the beaconed and non-beaconed (Figure 1)
```{r}
pi_data <- subset(spatial_firing_high, lm_group_b == "Positive" | lm_group_b == "Negative")
```

The groups we want to consider are +/+(O), +/+(C), +/-, -/-(O), -/-(C) and -/+. In addition for probe trials there will be a group 'other' for activity that is no longer in one of these categories.

3. Split by linear model result (figure 2) in outbound and homebound region for beaconed trials
```{r}
pospos <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Positive")
posneg <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Negative")
negpos <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Positive")
negneg <-subset(pi_data, lm_group_b == "Negative" & lm_group_b_h == "Negative")
posnon <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Unclassified")
negnon <-subset(pi_data, lm_group_b == "Positive" & lm_group_b_h == "Unclassified")

```

# test
```{r}
x <- (nrow(pospos) + nrow(negneg) + nrow(posneg) + (nrow(negpos) +nrow(posnon) + nrow(negnon)))
```

4. Split by linear model result (figure 1) in outbound and homebound region for beaconed trials
```{r}
# Beaconed: pospos
# stays the same
pospos_pospos <-nrow(subset(pospos, lm_group_p == "Positive" & lm_group_p_h == "Positive"))

# homebound changes
pospos_posneg <-nrow(subset(pospos, lm_group_p == "Positive" & lm_group_p_h == "Negative"))
pospos_posnon <-nrow(subset(pospos, lm_group_p == "Positive" & lm_group_p_h == "Unclassified"))

# outbound changes
pospos_negpos <-nrow(subset(pospos, lm_group_p == "Negative" & lm_group_p_h == "Positive"))
pospos_negnon <-nrow(subset(pospos, lm_group_p == "Negative" & lm_group_p_h == "Unclassified"))
pospos_negneg <-nrow(subset(pospos, lm_group_p == "Negative" & lm_group_p_h == "Negative"))


# Beaconed: posneg
posneg_posneg <-nrow(subset(posneg, lm_group_p == "Positive" & lm_group_p_h == "Negative"))

posneg_posnon <-nrow(subset(posneg, lm_group_p == "Positive" & lm_group_p_h == "Unclassified"))
posneg_pospos <-nrow(subset(posneg, lm_group_p == "Positive" & lm_group_p_h == "Positive"))

posneg_negpos <-nrow(subset(posneg, lm_group_p == "Negative" & lm_group_p_h == "Positive"))
posneg_negnon <-nrow(subset(posneg, lm_group_p == "Negative" & lm_group_p_h == "Unclassified"))
posneg_negneg <-nrow(subset(posneg, lm_group_p == "Negative" & lm_group_p_h == "Negative"))


# Beaconed: negneg
# stays the same
negneg_negneg <-nrow(subset(negneg, lm_group_p == "Negative" & lm_group_p_h == "Negative"))

# homebound changes
negneg_negpos <-nrow(subset(negneg, lm_group_p == "Negative" & lm_group_p_h == "Positive"))
negneg_negnon <-nrow(subset(negneg, lm_group_p == "Negative" & lm_group_p_h == "Unclassified"))

# outbound changes
negneg_posneg <-nrow(subset(negneg, lm_group_p == "Positive" & lm_group_p_h == "Negative"))
negneg_posnon <-nrow(subset(negneg, lm_group_p == "Positive" & lm_group_p_h == "Unclassified"))
negneg_pospos <-nrow(subset(negneg, lm_group_p == "Positive" & lm_group_p_h == "Positive"))


# Beaconed: negpos
# stays the same
negpos_negpos <-nrow(subset(negpos, lm_group_p == "Negative" & lm_group_p_h == "Positive"))

# homebound changes
negpos_negnon <-nrow(subset(negpos, lm_group_p == "Negative" & lm_group_p_h == "Unclassified"))
negpos_negneg <-nrow(subset(negpos, lm_group_p == "Negative" & lm_group_p_h == "Negative"))

# Outbound changes
negpos_posneg <-nrow(subset(negpos, lm_group_p == "Positive" & lm_group_p_h == "Negative"))
negpos_posnon <-nrow(subset(negpos, lm_group_p == "Positive" & lm_group_p_h == "Unclassified"))
negpos_pospos <-nrow(subset(negpos, lm_group_p == "Positive" & lm_group_p_h == "Positive"))


# Beaconed: posnon
posnon_posneg <-nrow(subset(posnon, lm_group_p == "Positive" & lm_group_p_h == "Negative"))

posnon_posnon <-nrow(subset(posnon, lm_group_p == "Positive" & lm_group_p_h == "Unclassified"))
posnon_pospos <-nrow(subset(posnon, lm_group_p == "Positive" & lm_group_p_h == "Positive"))

posnon_negpos <-nrow(subset(posnon, lm_group_p == "Negative" & lm_group_p_h == "Positive"))
posnon_negnon <-nrow(subset(posnon, lm_group_p == "Negative" & lm_group_p_h == "Unclassified"))
posnon_negneg <-nrow(subset(posnon, lm_group_p == "Negative" & lm_group_p_h == "Negative"))

# Beaconed: negnon
# stays the same
negnon_negpos <-nrow(subset(negnon, lm_group_p == "Negative" & lm_group_p_h == "Positive"))

# homebound changes
negnon_negnon <-nrow(subset(negnon, lm_group_p == "Negative" & lm_group_p_h == "Unclassified"))
negnon_negneg <-nrow(subset(negnon, lm_group_p == "Negative" & lm_group_p_h == "Negative"))

# Outbound changes
negnon_posneg <-nrow(subset(negnon, lm_group_p == "Positive" & lm_group_p_h == "Negative"))
negnon_posnon <-nrow(subset(negnon, lm_group_p == "Positive" & lm_group_p_h == "Unclassified"))
negnon_pospos <-nrow(subset(negnon, lm_group_p == "Positive" & lm_group_p_h == "Positive"))

```


5. put into tibble
```{r}

data_long <-
  tibble(
    value = c(
    
      posneg_posnon,

      pospos_posnon
    ),
    
    source = c(
      "+ -",

      "+ +"
    ),
    
    target = c(
      " + non",
      " + non"
    )
  )


data_long <- data_long %>%
  filter(value > 0)                           
                    
```


```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#66cd00","#EE3A8C", "#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```





```{r}

data_long <-
  tibble(
    value = c(
    
      negpos_negnon,

      negneg_negnon
    ),
    
    source = c(

      "- +",

      "- -"
    ),
    
    target = c(
      " - non",
      " - non"
    )
  )


data_long <- data_long %>%
  filter(value > 0)                           
                    
```


```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#EE3A8C", "#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```

