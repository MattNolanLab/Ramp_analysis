---
title: "RampCodes_Figure4"
author: "Sarah Tennant & Matt Nolan"
date: "20/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### ------------------------------------------------------------------------------------------ ### 


## Script aims to evaluate the dependence of firing rates on the reward zone cues and to evaluate properties of neurons with similar firing rate trajectories in the presence and absence of these cues.


### ------------------------------------------------------------------------------------------ ### 

First, classify neurons based on their slope activity in the outbound and homebound region in probe trials (similar to beaconed trials in Figure1_Analysis.Rmd)

i.e. pospos = positive in outbound, positive in homebound
i.e. posneg = positive in outbound, negative in homebound

.

```{r}
# Use function 'mark_track_category' previously used in Figure 1
spatial_firing <- spatial_firing %>%
  mutate(track_category_p = map2(lm_group_p, lm_group_p_h, mark_track_category))

# Find predicted rates after the reward zone based on rates before the reward zone
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_p = map(Rates_averaged_rewarded_p, normalise_rates))

spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_p_')) %>%
  mutate(predict_params_p = map(normalised_rates_p, predict_homebound)) %>%
  unnest_wider(predict_params_p,
               names_sep = "_",
               names_repair = "universal")

spatial_firing <- spatial_firing %>%
  mutate(
    offset_p = pmap_chr(
      list(
        normalised_rates_p,
        predict_params_p_lwr,
        predict_params_p_upr
      ),
      offset_test
    ),
    predict_diff_p = map2_dbl(normalised_rates_p, predict_params_p_fit, calc_predict_diff)
  )

# Classify cells based on their predicted activity using function 'mark_reset_group_predict' defined in Figure 1.

spatial_firing <- spatial_firing %>%
  mutate(reset_group_p = map(offset_p, mark_reset_group_predict))

table(spatial_firing$offset_p, useNA = "always")
```



### ------------------------------------------------------------------------------------------ ### 

Does the firing rate slope before or after the reward zone differ between beaconed and probe trials?

Subset spatial firing to contain only cells that have probe trial data and where the number of trials in the session  is >= 30.
```{r}
sum_unlist <- function(df) {sum(unlist(df), na.rm=TRUE)}
spatial_firing_probe_only <-
  subset(spatial_firing, max_trial_number >= 30) %>%
  mutate(asr_p_sum = map_dbl(Rates_averaged_rewarded_p, sum_unlist)) %>%
  subset(asr_p_sum != 0) %>%
  filter(lm_group_b == "Positive" | lm_group_b == "Negative") 
```

We ask first for all neurons that on beaconed trials have are classified with positive or negative slopes on the track segment before the reward zone.


Plot scatter of slopes after the reward zone on beaconed & probe
```{r}
b_vs_p_o_slope_plot(spatial_firing_probe_only)

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_outbound.png", width = 4, height = 4) 
}


b_vs_p_h_slope_plot(spatial_firing_probe_only)

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_homebound.png", width = 4, height = 4) 
}
```


Calculate r2 and p value for liner correlation of the above data
```{r}
model <- lm(asr_b_o_rewarded_fit_slope ~ asr_p_o_rewarded_fit_slope, data = spatial_firing_probe_only)
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)

model <- lm(asr_b_h_rewarded_fit_slope ~ asr_p_h_rewarded_fit_slope, data = spatial_firing_probe_only)
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)

```



We ask the same question foucssing on positional neurons (P, PA, PS, PSA) that on beaconed trials have are classified with positive or negative slopes on the track segment before the reward zone.
```{r}
spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  b_vs_p_o_slope_plot()

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_outbound.png", width = 4, height = 4) 
}


spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  b_vs_p_h_slope_plot()

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_homebound.png", width = 4, height = 4) 
}
```



Calculate r2 and p value for liner correlation of the above data
```{r}
model <- lm(asr_b_o_rewarded_fit_slope ~ asr_p_o_rewarded_fit_slope, data = spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") )
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)

model <- lm(asr_b_h_rewarded_fit_slope ~ asr_p_h_rewarded_fit_slope, data = spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") )
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)
```


Now compare offsets on beaconed vs probe trials
```{r}
b_vs_p_offset_plot(spatial_firing_probe_only)

spatial_firing_probe_only %>% filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  b_vs_p_offset_plot()

spatial_firing_probe_only %>%
  filter(final_model_o_b == "P") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  b_vs_p_offset_plot()
```


Plot distribution of offsets on probe trials.
```{r}
spatial_firing_probe_only %>%
  filter(final_model_o_b == "P") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") %>%
  offset_ggplot(diff_colname = "predict_diff_p", group_colname = "reset_group_p", colour_2 = "violetred2")

spatial_firing_probe_only %>%
  filter(final_model_o_b == "P") %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  offset_ggplot(diff_colname = "predict_diff_p", group_colname = "reset_group_p", colour_2 = "violetred2")
```


Does the distribution mean differ from zero?


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Plot average firing rates for neurons with firing rate profile (e.g. ++, +-, etc) that doesn't change when the reward zone cues are removed.



```{r}
# Function to make family of plots comparing beaconed and probe trials
comp_beacon_probe_rate_plots_all <- function(df){
  a <- df %>% plot_beaconed_vs_probe_all("Negative", "Negative", "Negative", "Negative")
  
  b <- df %>% plot_beaconed_vs_probe_all("Negative", "Positive", "Negative", "Positive")
  
  c <- df %>% plot_beaconed_vs_probe_all("Positive", "Positive", "Positive", "Positive")
  
  d <- df %>% plot_beaconed_vs_probe_all("Positive", "Negative", "Positive", "Negative")
  
  return(list(a, b, c, d))
}

comp_beacon_probe_rate_plots <- function(df){
  a <- df %>% plot_beaconed_vs_probe("Negative", "Negative")
  
  b <- df %>% plot_beaconed_vs_probe("Negative", "Positive")
  
  c <- df %>% plot_beaconed_vs_probe("Positive", "Positive")
  
  d <- df %>% plot_beaconed_vs_probe("Positive", "Negative")
  
  return(list(a, b, c, d))
}


(ci_plots <- comp_beacon_probe_rate_plots(spatial_firing_probe_only))

spatial_firing_probe_only %>% filter(final_model_o_b == "P") %>% comp_beacon_probe_rate_plots

(ci_all_plots <- comp_beacon_probe_rate_plots_all(spatial_firing_probe_only))


if (save_figures == 1) {
  ggsave(file = "plots/Negneg_probe_JustB.png",width = 3.6, height = 2.9)
}

```


### ------------------------------------------------------------------------------------------------------------------- ###

We want to know about whether the slope classification of neurons on beaconed trials is maintained on probe trials.

## Calculate numbers of neurons with given outbound and homebound classifications on beaconed and probe trials.
```{r}
# How many cells are in each group?
(b_vs_p_nos <- table(
  mapply(
    paste,
    spatial_firing_probe_only$lm_group_b,
    spatial_firing_probe_only$lm_group_b_h
  ),
  mapply(
    paste,
    spatial_firing_probe_only$lm_group_p,
    spatial_firing_probe_only$lm_group_p_h
  )
))

```


Prepare data to make a Sankey plot
```{r}

data_long <-
  tibble(
    value = c(
    
      b_vs_p_nos['Positive Negative','Positive Positive'],
      b_vs_p_nos['Positive Negative','Positive Negative'],
      b_vs_p_nos['Positive Negative','Negative Positive'],
      b_vs_p_nos['Positive Negative','Positive Unclassified'],
      b_vs_p_nos['Positive Negative','Negative Unclassified'],
      b_vs_p_nos['Positive Negative','Negative Negative'],
      
      b_vs_p_nos['Positive Positive','Positive Positive'],
      b_vs_p_nos['Positive Positive','Positive Negative'],
      b_vs_p_nos['Positive Positive','Negative Positive'],
      b_vs_p_nos['Positive Positive','Positive Unclassified'],
      b_vs_p_nos['Positive Positive','Negative Unclassified'],
      b_vs_p_nos['Positive Positive','Negative Negative'],
      
      b_vs_p_nos['Negative Positive','Positive Positive'],
      b_vs_p_nos['Negative Positive','Positive Negative'],
      b_vs_p_nos['Negative Positive','Negative Positive'],
      b_vs_p_nos['Negative Positive','Positive Unclassified'],
      b_vs_p_nos['Negative Positive','Negative Unclassified'],
      b_vs_p_nos['Negative Positive','Negative Negative'],
      
      b_vs_p_nos['Negative Negative','Positive Positive'],
      b_vs_p_nos['Negative Negative','Positive Negative'],
      b_vs_p_nos['Negative Negative','Negative Positive'],
      b_vs_p_nos['Negative Negative','Positive Unclassified'],
      b_vs_p_nos['Negative Negative','Negative Unclassified'],
      b_vs_p_nos['Negative Negative','Negative Negative']
    ),
    
    source = c(
      "+ -",
      "+ -",
      "+ -",
      "+ -",
      "+ -",
      "+ -",
      "+ +",
      "+ +",
      "+ +",
      "+ +",
      "+ +",
      "+ +",
      "- +",
      "- +",
      "- +",
      "- +",
      "- +",
      "- +",
      "- -",
      "- -",
      "- -",
      "- -",
      "- -",
      "- -"
    ),
    
    target = c(
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -",
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -",
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -",
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -"
    )
  )


data_long <- data_long %>%
  filter(value > 0)                           
                    
```


```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#66cd00","#EE3A8C", "#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```


### ------------------------------------------------------------------------------------------ ### 

## Plot coefficients for Figure 4I



_Plot coefficients for just position cells_


6a. Plot coefficients for cells classified in Figure 1 as having a positive slope and in Figure 2 as having significant fit coefficients for position only.

```{r}
# this cell requires data_coef made in Figure 2 Analysis Rmd
data_coef_pos_allp <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PSA" | group == "PA") %>%
  subset(lm_result == "Positive")

(pos_SA_coef_plot <- standard_plot(data_coef_pos_allp))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositiveAllPositioncells.png", width = 3, height = 2.5)
}
```



6b. Plot coefficients for cells classified in Figure 1 as having a negative slope and in Figure 2 as having significant fit coefficients for position only.

```{r}
data_coef_neg_allp <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PSA" | group == "PA") %>%
  subset(lm_result == "Negative")

(neg_SA_coef_plot <- standard_plot(data_coef_neg_allp))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativeAllPositioncells.png", width = 3, height = 2.5)
}
```




### ------------------------------------------------------------------------------------------ ### 




### Calculate average stop histogram for all mice, sessions and plot


1. Subset data by group         
```{r}

df <-  
  tibble(average_stops = unlist(spatial_firing$average_stops), 
            average_stops_p = unlist(spatial_firing$average_stops_p))


```

2. Average rates
```{r}
df <- df %>%
  mutate(Position = rep(-30:169, times = nrow(spatial_firing))) %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(as.numeric(average_stops), na.rm =TRUE), sem_r = std.error(as.numeric(average_stops)), 
                   mean_p = mean(as.numeric(average_stops_p), na.rm =TRUE), sem_p = std.error(as.numeric(average_stops_p))) 

```

3. Plot
```{r}
ggplot(data=df) +
  annotate("rect", xmin=-30, xmax=0, ymin=0,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=0,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=0,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_line(aes(y=mean_r, x=Position), color = "Black") +
  geom_line(aes(y=mean_p, x=Position), color = "Blue") +
  scale_x_continuous(breaks=seq(-30,170,100), expand = c(0, 0)) +
  labs(y = "Stops (cm)", x = "Location (cm)") +
  theme_classic() +
  theme(axis.text.x = element_text(size=18),
      axis.text.y = element_text(size=18),
      legend.title = element_blank(),
      text = element_text(size=18),
      plot.margin = margin(21, 25, 5, 20))
if (save_figures == 1) {
  ggsave(file = "plots/stops_mean.png", width = 3.6, height = 2.9)
}
```


