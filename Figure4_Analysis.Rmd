---
title: "Figure4_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### --------------------------------------------------------------------------------- ###


## Runs analysis that compares cued trials (Beaconed) to uncued (Non-beaconed + Probe)

_note : focuses on activity in outbound region_


### --------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons have the following patterns of ramp activity:

1. Cue-independent ('PI'): ramp in both cued (B) and uncued (NB/P)
2. Cue-dependent ('cue'): ramp in just cued (B)
3. Cue-impaired ('onlypi'   ): ramp in just uncued (NB/P)

To classify cells into these categories above, we will use the classification established in Figure 2. This requires that Figure 2 analyses have been run for B and NB/P groups. Note that in the code 'nb' includes non-beaconed and probe trials.

1. Make function to classify cells based on activity in beaconed / non-beaconed & probe trials 
```{r}
mark_neurons <- function(beac, nb){
  if (is.na(beac) | is.na(nb) ) {
    return( "None" )
  } else if( beac == "Positive" & nb == "Positive") {
    return( "Positive-PI" )
  } else if( beac == "Negative" & nb == "Negative") {
    return( "Negative-PI" )
  } else if( beac == "Positive" & nb == "Unclassified") {
    return( "Positive-cue" )
  } else if( beac == "Negative" & nb == "Unclassified") {
    return( "Negative-cue" )
  } else if( beac == "Unclassified" & nb == "Positive") {
    return( "Positive-onlypi" )
  } else if( beac == "Unclassified" & nb == "Negative") {
    return( "Negative-onlypi" )
  } else if( beac == "Unclassified" & nb == "Unclassified") {
    return( "Unclassified" )
    } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(cue_group_o = map2(lm_group_b, lm_group_nb, mark_neurons))

```



Visualise the proportion of cells that fit the above criteria.  

We will first focus on neurons classified as having a positive or negative slope in Figure 2. A problem with this analysis is that it includes neurons that in Figure 3 are shown to be modulated by speed or acceleration but not position. The further analysis below will address this.


Function to return a tibble with proportions of neurons classified as cue-dependent, cue-independent or path integration only.
```{r}
calc_props_cue_dep <- function(cue_group){
  cue_group <- as.character(cue_group)
  num_cells <- length(cue_group)
  
  pi_num <- length(which(cue_group == "Positive-PI" | cue_group == "Negative-PI"))
  cue_num <- length(which(cue_group == "Positive-cue" | cue_group == "Negative-cue"))
  pionly_num <- length(which(cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi"))
  uc_num <- length(which(cue_group == "Unclassified"))
  none_num <- length(which(cue_group == "None"))
  
  pi <- pi_num / num_cells
  cue <- cue_num / num_cells
  pionly <- pionly_num / num_cells
  uc <-uc_num / num_cells
  none <- none_num / num_cells

proportions_mixed_ramps <- tibble(perc=c(pi, cue, pionly, uc, none), num=c(pi_num, cue_num, pionly_num, uc_num, none_num),ramp_type = c("Cue-independent", "Cue-dependant", "Path-Integration-only", "Unclassified", "None"))
}
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_mixed_ramps <- calc_props_cue_dep(spatial_firing$cue_group_o)
```


Plot a pie chart of results, 
_note : pie segments represent the proportions with numbers in text_
```{r}
proportions_mixed_ramps_pi_maker <- function(df){
  # Compute the position of labels
data <- df %>% 
  arrange(desc(ramp_type)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_type)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")
}

proportions_mixed_ramps_pi_maker(proportions_mixed_ramps)

if (save_figures == 1) {
  ggsave(file = "plots/CueComparison_proportions.png", width = 4, height = 4)
}
```




### -------------------------------------------------------------------------------------------------------- ###

We also want to compare the classification of neurons between cued and uncued trials. We will do this using a Sankey plot

We need a pair of vectors called 'value' that contain the number of cells for each group transition between 'source' and 'target', which are categories for slopes the beaconed and the non-beaconed trials.
The transitions will be ordered as:
++
+-
+NC
-+
--
-NC
NC+
NC-
NCNC

```{r}
# ob_group and h_group are column names from the results data frame that contain the grouping information.
calc_transitions <- function(group1, group2){
  df <- tibble(g1 = as.character(group1), g2 = as.character(group2))
  
  transition_values <- c(length(which(df$g1 == "Positive" & df$g2 == "Positive")),
                         length(which(df$g1 == "Positive" & df$g2 == "Negative")),
                         length(which(df$g1 == "Positive" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Negative" & df$g2 == "Positive")),
                         length(which(df$g1 == "Negative" & df$g2 == "Negative")),
                         length(which(df$g1 == "Negative" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Positive")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Negative")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Unclassified")))
  transition_values_long <- tibble(value = transition_values,
                                   source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "Unclassified","Unclassified", "Unclassified"),
                                   target= c(" Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified")
                                   ) %>%
    filter(value > 0)
  
  nodes <- data.frame(name=c(as.character(transition_values_long$source), as.character(transition_values_long$target)) %>% unique())
  transition_values_long$IDsource=match(transition_values_long$source, nodes$name)-1
  transition_values_long$IDtarget=match(transition_values_long$target, nodes$name)-1
  return(transition_values_long)
}
```

Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long <- calc_transitions(spatial_firing$lm_group_b, spatial_firing$lm_group_nb)

# Probably a more elegant way to do this as already made in calc_transitions
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

```

Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```





### ------------------------------------------------------------------------------------- ###

_same as above but just for position modulated cells_

Here, we want to focus the analysis exclusively on neurons that have a +/- slope on beaconed trials (Figure 2) and are position modulated (Figure 3).

```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_pos_mixed_ramps <- calc_props_cue_dep(position_neurons$cue_group_o)

proportions_mixed_ramps_pi_maker(proportions_pos_mixed_ramps)
```

Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long_pos <- calc_transitions(position_neurons$lm_group_b, position_neurons$lm_group_nb)

# Probably a more elegant way to do this as already made in calc_transitions
nodes_pos <- data.frame(name=c(as.character(data_long_pos$source), as.character(data_long_pos$target)) %>% unique())

```

Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long_pos, Nodes = nodes_pos,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}


```



### --------------------------------------------------------------------------------------- ###

Now we want to visualise the average firing rate for each of the groups (cue dependant & cue independent / positive & negative).

We will again focus exclusively on neurons that have a +/- slope (Figure 2) and are position modulated (Figure 3). To do so we will use the tibble 'position_neurons' generated above.

Function to plot data mean and SEM of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SEM_plots <- function(df, group_b, group_nb, x_start = 30, x_end = 90){
  df <- df %>%
    filter(lm_group_b == group_b,
           lm_group_nb == group_nb) %>%
    select(Rates_averaged_rewarded_b, Rates_averaged_rewarded_nb, cue_group_o) %>%
    unnest(c(Rates_averaged_rewarded_b, Rates_averaged_rewarded_nb))
 df$Rates_averaged_rewarded_b <- as.double(df$Rates_averaged_rewarded_b)
 df$Rates_averaged_rewarded_nb <- as.double(df$Rates_averaged_rewarded_nb)
 df$cue_group_o <- as.character(df$cue_group_o)
 numcells <- length(df$Rates_averaged_rewarded_nb)/200
 df$Position <- rep(1:200, times = numcells)
 
 df <- df %>%
   group_by(cue_group_o, Position) %>%
   summarise(mean_b = mean(Rates_averaged_rewarded_b, na.rm = TRUE),
             mean_nb = mean(Rates_averaged_rewarded_nb, na.rm = TRUE),
             se_b = std.error(Rates_averaged_rewarded_b, na.rm = TRUE),
             se_nb = std.error(Rates_averaged_rewarded_nb, na.rm = TRUE))
 
 ggplot(data=df) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - se_nb, ymax = mean_nb + se_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```



Subset data by group then average rates for plotting          **Negative Cue**
```{r}
(NegUC_plot <- mean_SEM_plots(position_neurons, "Negative", "Unclassified"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_NegCue.png", width = 3.5, height = 2.5)
}
```


Subset data by group then average rates for plotting          **Positive Cue**
```{r}
(PosUC_plot <- mean_SEM_plots(position_neurons, "Positive", "Unclassified"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_PosCue.png", width = 3.5, height = 2.5)
}
```


Subset data by group then average rates for plotting          **Positive PI**

```{r}
(PosPos_plot <- mean_SEM_plots(position_neurons, "Positive", "Positive"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_PosPI.png", width = 3.5, height = 2.5)
}
```


Subset data by group then average rates for plotting          **Negative PI**

```{r}
(NegNeg_plot <- mean_SEM_plots(position_neurons, "Negative", "Negative"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_NegPI.png", width = 3.5, height = 2.5)
}
```


Subset data by group then average rates for plotting          **Negative PI only**

These data are not in position neurons so make a new data frame containing these neurons.
```{r}
unclassified_neurons <- filter(spatial_firing, lm_group_b == "Unclassified")
```

```{r}
(UCNeg_plot <- mean_SEM_plots(unclassified_neurons, "Unclassified", "Negative"))

if (save_figures == 1) {
  ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)
}
```

Subset data by group then average rates for plotting          **Positive PI only**

```{r}
(UCPos_plot <- mean_SEM_plots(unclassified_neurons, "Unclassified", "Positive"))

if (save_figures == 1) {
 ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5) 
}
```





###----------------------------------------------------------------------------------------------###
Additional analyses related to Figure 4.

First split data based on cue independent/cue dependent as we are only interested in position neurons here
```{r}
cue_independant_neurons <- filter(position_neurons, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
cue_dependant_neurons <- filter(position_neurons, cue_group_o == "Positive-cue" | cue_group_o == "Negative-cue")

```


Make bar charts showing the distribution of P, PS, PA and PSA neurons.
```{r}
make_mm_class_bar <- function(df){
  pos <-subset(df, lm_group_b == "Positive")
  neg <-subset(df, lm_group_b == "Negative")
  mixed_ramps <- tibble(perc=c(nrow(subset(pos, final_model_o_b == "P"))/nrow(pos)*100,
                             nrow(subset(neg, final_model_o_b == "P"))/nrow(neg)*100,
                             nrow(subset(pos,final_model_o_b == "PS"))/nrow(pos)*100,
                             nrow(subset(neg,final_model_o_b == "PS"))/nrow(neg)*100,
                             nrow(subset(pos ,final_model_o_b == "PA"))/nrow(pos)*100,
                             nrow(subset(neg ,final_model_o_b == "PA"))/nrow(neg)*100,
                             nrow(subset(pos ,final_model_o_b == "PSA"))/nrow(pos)*100, 
                             nrow(subset(neg ,final_model_o_b == "PSA"))/nrow(neg)*100), 
                      
                      ramp_id= c("P","P", 
                                 "PS", "PS",
                                 "PA", "PA", 
                                 "PAS", "PAS"), 
                      ramp_type= rep(c("Positive", "Negative"), 4))
  
  level_order <- c("P", "PS", "PA", "PAS")
ggplot(mixed_ramps, aes(x= factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons") +
  scale_fill_manual(values=c("firebrick1","gold", "darkorchid1", "darkslategray")) +
  #scale_fill_brewer(palette= "RdYlBu") +
  theme_classic() +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
}

make_mm_class_bar(cue_dependant_neurons)

if (save_figures == 1) {
  ggsave(file = "plots/LMERProportions_beaconed_cuedependant.png", width = 4, height = 4.5)
}


make_mm_class_bar(cue_independant_neurons)

if (save_figures == 1) {
 ggsave(file = "plots/LMERProportions_beaconed_cueindependant.png", width = 4, height = 4.5) 
}
```




Plot the distribution of standardised coefficients for cue-dependent and cue-independent cells with positve / negative slopes.

Use function 'standard_plot' from Figure 3. This expects a tibble with columns 'coef_type' (either P, S or A) and 'coef' (the coefficients)

Make tibble for coefficient plots
4. put data into a tibble for plotting.
```{r}
data_coef_2 <- tibble(session_id = rep(unlist(position_neurons$unique_id), times=3), 
                    cluster_id = rep(position_neurons$cluster_id, times=3), 
                    coef = c(as.character(position_neurons$o_b_mod_coefs_pos),
                             as.character(position_neurons$o_b_mod_coefs_speed),
                             as.character(position_neurons$o_b_mod_coefs_accel)),
                    group = rep(as.character(position_neurons$final_model_o_b), 3),
                    cue_group = rep(as.character(position_neurons$cue_group_o), 3),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(position_neurons)),
                    lm_result = rep(as.character(position_neurons$lm_group_b), times=3))
```

Use function 'standard_plot' from Figure 3. This expects a tibble with columns 'coef_type' (either P, S or A) and 'coef' (the coefficients)


Plot coefficients for cells classified in Figure 3 as having 'significant' positional coefficients in the mixed effect model, and Figure 4 as having ramp-like activity on both beaconed and non-beaconed/probe trials. 

```{r}
data_coef_PSA_PI_pos <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Positive-PI")

(PSA_PI_pos_coef_plot <- standard_plot(data_coef_PSA_PI_pos))

if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PSAPIposcells.png", width = 3, height = 3.5)
}


```


```{r}
data_coef_PSA_PI_neg <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Negative-PI")

(PSA_PI_neg_coef_plot <- standard_plot(data_coef_PSA_PI_neg))

if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PSAPInegcells.png", width = 3, height = 3.5)
}
```



Plot coefficients for cells classified in Figure 3 as having 'significant' positional coefficients in the mixed effect model, and Figure 4 as having ramp-like activity on beaconed but not non-beaconed/probe trials. 


```{r}
data_coef_PSA_cue_pos <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Positive-cue")

standard_plot(data_coef_PSA_cue_pos)
```


```{r}
data_coef_PSA_cue_neg <- data_coef_2 %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(cue_group == "Negative-cue")

standard_plot(data_coef_PSA_cue_pos)
```


## save dataset for harry

2. take only columns we need for the rest of the analysis
```{r}
if(save_figures == 1) {
  spatial_firing_save <- select(spatial_firing, session_id, cluster_id, lm_group_b, final_model_o_b, final_model_h_b, lm_group_b_h, cue_group_o) %>%
    unnest(cols = c(session_id, cluster_id, lm_group_b, final_model_o_b, final_model_h_b, lm_group_b_h, cue_group_o)) %>%
  as.tibble()
}
```

3. save to csv file _this is for matching to plots from python_
```{r}
write_csv2(spatial_firing_save, "all_results_linearmodel.csv")
```

