---
title: "Figure4_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### --------------------------------------------------------------------------------- ###


## Runs analysis that compares cued trials (beaconed) to uncued (non-beaconed + probe)

_note : focuses on activity in outbound region_

### --------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons has the following pattern ramp activity :

1. ramp in both cued and uncued (PI)
2. ramp in just cued (cue)
3. ramp in just uncued (onlypi)

To classify cells into these catagories above, we will use the criteria established in Figure 2 using linear modelling. 

1. make function to classify cells based on activity in beaconed / non-beaconed&probe trials 
```{r}
mark_neurons <- function(beac, probe){
  if (is.na(beac) | is.na(probe) ) {
    return( "None" )
  } else if( beac == "Positive" & probe == "Positive") {
    return( "Positive-PI" )
  } else if( beac == "Negative" & probe == "Negative") {
    return( "Negative-PI" )
  } else if( beac == "Positive" & probe == "Unclassified") {
    return( "Positive-cue" )
  } else if( beac == "Negative" & probe == "Unclassified") {
    return( "Negative-cue" )
  } else if( beac == "Unclassified" & probe == "Positive") {
    return( "Positive-onlypi" )
  } else if( beac == "Unclassified" & probe == "Negative") {
    return( "Negative-onlypi" )
    } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(cue_group = map2(lm_group, lm_group_nb, mark_neurons))

```



Now I want to visualise the proportion of cells that fit these above criteria. I'm going to do this by plotting a pie chart. 

1. subset neurons by group _just looking at cue dependant or independant for now_
```{r}
ramps <-subset(spatial_firing, lm_group == "Positive" | lm_group == "Negative")

# positive homebound slopes
pi <-nrow(subset(ramps, cue_group == "Positive-PI" | cue_group == "Negative-PI"))/nrow(ramps)*100
cue <-nrow(subset(ramps, cue_group == "Positive-cue" | cue_group == "Negative-cue"))/nrow(ramps)*100
pionly <-nrow(subset(spatial_firing, cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi"))/nrow(spatial_firing)*100
none <-nrow(subset(spatial_firing, cue_group == "None" | cue_group == "None"))/nrow(spatial_firing)*100

# positive homebound slopes
pi_num <-nrow(subset(spatial_firing, cue_group == "Positive-PI" | cue_group == "Negative-PI"))
cue_num <-nrow(subset(spatial_firing, cue_group == "Positive-cue" | cue_group == "Negative-cue"))
pionly_num <-nrow(subset(spatial_firing, cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi"))
none_num <-nrow(subset(spatial_firing, cue_group == "None" | cue_group == "None"))

```

2. Put results into tibble
```{r}

proportions_mixed_ramps <- tibble(perc=c(pi, cue, pionly, none), num=c(pi_num, cue_num, pionly_num, none_num), ramp_id= c("Cue-independant", "Cue-dependant", "Path-Integration-only", "None"),ramp_type = c("Cue-independant", "Cue-dependant", "Path-Integration-only", "None"))

```

3. Plot a pie chart of results, 
_note : pie segments represent the proportions with real values in text_
```{r}

# Create Data
data <- data.frame(
  group=LETTERS[1:4],
  value=c(pi,cue,pionly,none)
)

# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")

ggsave(file = "plots/CueComparison_proportions.png", width = 4, height = 4)

```


4. Also just a quick look at the numbers - how many positive and negative of each (cue/PI)
```{r}
ramps <- subset(spatial_firing, lm_group == "Positive" | lm_group == "Negative")

pi_neg <-nrow(subset(ramps, cue_group == "Negative-PI"))/nrow(ramps)*100
cue_neg <-nrow(subset(ramps, cue_group == "Negative-cue"))/nrow(ramps)*100
pi_pos <-nrow(subset(ramps, cue_group == "Positive-PI"))/nrow(ramps)*100
cue_pos <-nrow(subset(ramps, cue_group == "Positive-cue"))/nrow(ramps)*100

```



### -------------------------------------------------------------------------------------------------------- ###

We also want to see the movement of neurons from cue to uncued trials, do this using a Sankey plot
_note : we focus only on cue independant / path integrating neurons here_


1. Subset based on cue dependancy
```{r}
# positive homebound slopes
pi <-subset(spatial_firing, cue_group == "Positive-PI" | cue_group == "Negative-PI")
cue <-subset(spatial_firing, cue_group == "Positive-cue" | cue_group == "Negative-cue")
pionly <-subset(spatial_firing, cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi")

pi_neg <-subset(spatial_firing, cue_group == "Negative-PI")
cue_neg <-subset(spatial_firing,  cue_group == "Negative-cue")
pi_pos <-subset(spatial_firing, cue_group == "Positive-PI" )
cue_pos <-subset(spatial_firing, cue_group == "Positive-cue" )

```

2. Subset based on non-beaconed activity
```{r}

pi_positive <-subset(spatial_firing, lm_group == "Positive")
pi_negative <-subset(spatial_firing, lm_group == "Negative")
pi_none <-subset(spatial_firing, lm_group == "None")

pi_positive_pos <-nrow(subset(pi_positive, lm_group_nb == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_group_nb == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_group_nb == "None"))
pi_negative_pos <-nrow(subset(pi_negative, lm_group_nb == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_group_nb == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_group_nb == "None"))
pi_none_pos <-nrow(subset(pi_none, lm_group_nb == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_group_nb == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_group_nb == "None"))

```

3. Put data into a tibble with labels
```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

3. Create a node data frame: it lists every entities involved in the flow
```{r}
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

4. Reformat dataframe to provide connection using id, not using the real name like in the links dataframe
```{r}
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

5. Plot sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```