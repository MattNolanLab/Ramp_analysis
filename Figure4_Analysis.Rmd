---
title: "RampCodes_Figure4"
author: "Sarah Tennant & Matt Nolan"
date: "20/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### ------------------------------------------------------------------------------------------ ### 


## Script aims to evaluate the dependence of firing rates on the reward zone cues and to evaluate properties of neurons with similar firing rate trajectories in the presence and absence of these cues.


### ------------------------------------------------------------------------------------------ ### 

First, classify neurons based on their slope activity in the outbound and homebound region in probe trials (similar to beaconed trials in Figure1_Analysis.Rmd)

This analysis isn't so useful as there are relatively few probe trials and therefore insufficient power for classification. This may be useful for future experiments that optimise probe trial number.

```{r}
# Use function 'mark_track_category' previously used in Figure 1
spatial_firing <- spatial_firing %>%
  mutate(track_category_p = map2(lm_group_p, lm_group_p_h, mark_track_category))

# Find predicted rates after the reward zone based on rates before the reward zone
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_p = map(Rates_averaged_rewarded_p, normalise_rates))

spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_p_smoothed = map(Rates_averaged_rewarded_smoothed_p, normalise_rates))

spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_p_')) %>%
  mutate(predict_params_p = map(normalised_rates_p, predict_homebound)) %>%
  unnest_wider(predict_params_p,
               names_sep = "_",
               names_repair = "universal")

spatial_firing <- spatial_firing %>%
  mutate(
    offset_p = pmap_chr(
      list(
        normalised_rates_p,
        predict_params_p_lwr,
        predict_params_p_upr
      ),
      offset_test
    ),
    predict_diff_p = map2_dbl(normalised_rates_p, predict_params_p_fit, calc_predict_diff)
  )

# Classify cells based on their predicted activity using function 'mark_reset_group_predict' defined in Figure 1.

spatial_firing <- spatial_firing %>%
  mutate(reset_group_p = map(offset_p, mark_reset_group_predict))

table(spatial_firing$offset_p, useNA = "always")
```



### ------------------------------------------------------------------------------------------ ### 

Does the firing rate slope before or after the reward zone differ between beaconed and probe trials?

Subset spatial firing to contain only cells that have probe trial data and where the number of trials in the session  is >= 120, and therefore probe trials >= 12.
```{r}
sum_unlist <- function(df) {sum(unlist(df), na.rm=TRUE)}
spatial_firing_probe_only <-
  subset(spatial_firing, max_trial_number >= 120) %>%
  mutate(asr_p_sum = map_dbl(Rates_averaged_p, sum_unlist)) %>%
  subset(asr_p_sum != 0) %>%
  filter(lm_group_b == "Positive" | lm_group_b == "Negative") 
```

We focus on positional neurons (P, PA, PS, PSA) that on beaconed trials are classified with positive or negative slopes on the track segment before the reward zone

Plot absolute slope values for each trial type
```{r}
# Plots
probe_out_slope_plot(spatial_firing_probe_only, "Positive", -0.1, 0.45)
probe_out_slope_plot(spatial_firing_probe_only, "Negative", -0.65, 0.2)

probe_home_slope_plot(spatial_firing_probe_only, "Positive", -0.35, 0.8)
probe_home_slope_plot(spatial_firing_probe_only, "Negative", -0.4, 0.75)

# Compare probe vs beaconed with a paired t-test
probe_slope_tt_p <- spatial_firing_probe_only %>%
  filter(lm_group_b == "Positive") %>%
  summarise(ttest = list(t.test(asr_b_o_rewarded_fit_slope, asr_p_o_rewarded_fit_slope, paired = TRUE),
                         t.test(asr_b_h_rewarded_fit_slope, asr_p_h_rewarded_fit_slope, paired = TRUE))) 

probe_slope_tt_n <- spatial_firing_probe_only %>%
  filter(lm_group_b == "Negative") %>%
  summarise(ttest = list(t.test(asr_b_o_rewarded_fit_slope, asr_p_o_rewarded_fit_slope, paired = TRUE),
                         t.test(asr_b_h_rewarded_fit_slope, asr_p_h_rewarded_fit_slope, paired = TRUE))) 

probe_slope_tt_p[[1]]
probe_slope_tt_n[[1]]

# Test for probe slope different from zero
```



Plot scatter of slopes after the reward zone on beaconed & probe trials.
```{r}
spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  b_vs_p_o_slope_plot()

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_outbound.png", width = 4, height = 4) 
}


spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  b_vs_p_h_slope_plot()

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_homebound.png", width = 4, height = 4) 
}
```



Calculate r2 and p value for liner correlation of the above data
```{r}
model <- lm(asr_b_o_rewarded_fit_slope ~ asr_p_o_rewarded_fit_slope, data = spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") )
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)

model <- lm(asr_b_h_rewarded_fit_slope ~ asr_p_h_rewarded_fit_slope, data = spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") )
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)
```


Now compare offsets on beaconed vs probe trials

Plot absolute offset values for each trial type
```{r}
spatial_firing_probe_only %>% filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  probe_offset_plot("Positive", -3, 1)

spatial_firing_probe_only %>% filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  probe_offset_plot("Negative", -1, 5)
```


Look at possible correlations
```{r}
spatial_firing_probe_only %>% filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  b_vs_p_offset_plot()
```


Plot distribution of offsets on probe trials.
```{r}
# All position types
spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PA" | final_model_o_b == "PS" | final_model_o_b == "PSA") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") %>%
  offset_ggplot(diff_colname = "predict_diff_p", group_colname = "reset_group_p", colour_2 = "violetred2")

spatial_firing_probe_only %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PA" | final_model_o_b == "PS" | final_model_o_b == "PSA") %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  offset_ggplot(diff_colname = "predict_diff_p", group_colname = "reset_group_p", colour_2 = "violetred2")
```


Does the distribution mean differ from zero?

Treat each observation as independent and use a t-test
```{r}
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PA" | final_model_o_b == "PS" | final_model_o_b == "PSA") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") %>%
  select(predict_diff_p) %>%
  t.test(mu = 0)

spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PA" | final_model_o_b == "PS" | final_model_o_b == "PSA") %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  select(predict_diff_p) %>%
  t.test(mu = 0)
```


Does the change in slope between beaconed and probe trials predict the change in offset? E.g. If a neuron's slope is stable then is it's offset? We might expect this for recall of a positional memory.
```{r}
# Look only at P group
spatial_firing %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") %>%
  ggplot(aes(x = asr_p_o_rewarded_fit_slope, y = predict_diff_p)) +
  geom_point()


spatial_firing %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  ggplot(aes(x = asr_p_o_rewarded_fit_slope, y = predict_diff_p)) +
  geom_point()
```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Plot average firing rates for neurons with firing rate profile (e.g. ++, +-, etc) that doesn't change when the reward zone cues are removed.



```{r}
# all neurons negative and positive
#(ci_plots <- comp_beacon_probe_rate_plots(spatial_firing_probe_only))


# all P cells (used for the manuscript)
spatial_firing_probe_only %>% filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>% comp_beacon_probe_rate_plots


if (save_figures == 1) {
  ggsave(file = "plots/Negneg_probe_JustB.png",width = 3.6, height = 2.9)
}


# only P cells
spatial_firing_probe_only %>% filter(final_model_o_b == "P") %>% comp_beacon_probe_rate_plots

# conjunctive P cells
spatial_firing_probe_only %>% filter(final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>% comp_beacon_probe_rate_plots

```


What is the distribution of firing rate profiles of previously positional ramping neurons?
To look at distributions in the data superimpose mean firing rate as a function of positon for each neuron in each group and colour code according to the offset, slope or change in slope / offset.
```{r}
comp_plot <- function(df, plot_column_1 = "Rates_averaged_rewarded_smoothed_b", plot_column_2 = "Rates_averaged_rewarded_smoothed_p", group1 = "Positive", group2 = "Positive") {
  df$pc_1 <- df[[plot_column_1]]
  df$pc_2 <- df[[plot_column_2]]
  df %>% filter(lm_group_b == group1 & lm_group_b_h == group2) %>%
    select(unique_id, pc_1, pc_2) %>%
    mutate(Rates_1 = map(pc_1, unlist),
           Rates_2 = map(pc_2, unlist)) %>%
    unnest(c(unique_id, Rates_1, Rates_2)) %>%
    mutate(Pos = rep(-30:169, length(unique(unique_id)))) %>%
    ggplot() +
    geom_line(aes(x = Pos, y = Rates_1), colour = "blue")+
    geom_line(aes(x = Pos, y = Rates_2), colour = "red") +
    facet_wrap(~unique_id, scales = "free")
}

arp_P <- spatial_firing_probe_only %>%
    filter(final_model_o_b == "P") %>%
  comp_plot("Rates_averaged_rewarded_smoothed_b", "Rates_averaged_rewarded_smoothed_p", "Positive", "Positive")

arp_N <- spatial_firing_probe_only %>%
    filter(final_model_o_b == "P") %>%
  comp_plot("Rates_averaged_rewarded_smoothed_b","Rates_averaged_rewarded_smoothed_p", "Negative", "Negative")

add_track(arp_P)
add_track(arp_N)

```



### ------------------------------------------------------------------------------------------------------------------- ###

We want to know about whether the slope classification of neurons on beaconed trials is maintained on probe trials.

## Calculate numbers of neurons with given outbound and homebound classifications on beaconed and probe trials.
```{r}
# How many cells are in each group?
(b_vs_p_nos <- table(
  mapply(
    paste,
    spatial_firing_probe_only$lm_group_b,
    spatial_firing_probe_only$lm_group_b_h
  ),
  mapply(
    paste,
    spatial_firing_probe_only$lm_group_p,
    spatial_firing_probe_only$lm_group_p_h
  )
))

```


### ------------------------------------------------------------------------------------------ ### 

## Plot coefficients for Figure 4I

This needs as input columnms containing standardized coefficients (coef) and the coefficient type (coef_type). This data is in spatial_firing but not in an appropriate tidy format.

Fit GLMER to probe trial data.
Threshold is set to > 10 probe trials.
```{r}
# df<-data.frame()
# for (i in 1:nrow(spatial_firing)) {
#   print(as.character(i))
#   spatial_firing_i = spatial_firing[i,]
#   o_mm_b_p <- mm_fit_function(spatial_firing_i$spikes_in_time[[1]], TT = 2, thresh = 10)
#   o_mm_p_b_p <- mm_pvalues(o_mm_b_p, spatial_firing_i$session_id[1])
#   o_b_mod_coefs_p <- std_coef(o_mm_b_p)
# 
#   spatial_firing_i$o_b_p_mod_coefs_pos[1] <- as.double(o_b_mod_coefs_p[1])
#   spatial_firing_i$o_b_p_mod_coefs_speed[1] <- as.double(o_b_mod_coefs_p[2])
#   spatial_firing_i$o_b_p_mod_coefs_accel[1] <- as.double(o_b_mod_coefs_p[3])
#   spatial_firing_i$o_mm_p_p_b_pos[1] <- as.double(o_mm_p_b_p[1])
#   spatial_firing_i$o_mm_p_p_b_speed[1] <- as.double(o_mm_p_b_p[2])
#   spatial_firing_i$o_mm_p_p_b_accel[1] <- as.double(o_mm_p_b_p[3])
#   df<-bind_rows(df, spatial_firing_i)
# }
# spatial_firing <- df
# rm(df, spatial_firing_i)
```


```{r}
# this cell requires data_coef made in Figure 2 Analysis Rmd
data_coef_pos_allp <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PSA" | group == "PA") %>%
  subset(lm_result == "Positive")

(pos_SA_coef_plot <- standard_plot(data_coef_pos_allp))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositiveAllPositioncells.png", width = 3, height = 2.5)
}
```


```{r}
data_coef_neg_allp <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PSA" | group == "PA") %>%
  subset(lm_result == "Negative")

(neg_SA_coef_plot <- standard_plot(data_coef_neg_allp))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativeAllPositioncells.png", width = 3, height = 2.5)
}
```




### ------------------------------------------------------------------------------------------ ### 




### Calculate average stop histogram for all mice, sessions and plot

        
```{r}
df <- spatial_firing_probe_only %>%
  select(average_stops, average_stops_p, session_id) %>%
  distinct %>%
  mutate(average_stops = map(average_stops, unlist), 
         average_stops_p = map(average_stops_p, unlist)) %>%
  unnest(c(session_id, average_stops, average_stops_p)) %>%
  mutate(Position = rep(-30:169, length(unique(session_id)))) %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(as.numeric(average_stops), na.rm =TRUE), sem_r = std.error(as.numeric(average_stops)), 
                   mean_p = mean(as.numeric(average_stops_p), na.rm =TRUE), sem_p = std.error(as.numeric(average_stops_p))) 

bp <- ggplot(data=df) +
  geom_line(aes(y=mean_r, x=Position), color = "Black") +
  geom_line(aes(y=mean_p, x=Position), color = "Blue")

(add_track(bp))


```

```{r}
stops_plot <-
  function(df, cn1 = "average_stops", cn2 = "average_stops_p") {
    df$cn1 <- df[[cn1]]
    df$cn2 <- df[[cn2]]
    df %>% select(session_id, cn1, cn2) %>%
      distinct() %>%
      mutate(Stops1 = map(cn1, unlist),
             Stops2 = map(cn2, unlist)) %>%
      unnest(c(session_id, Stops1, Stops2)) %>%
      mutate(Pos = rep(1:200, length(unique(session_id)))) %>%
      ggplot() +
      geom_line(aes(x = Pos, y = Stops1), colour = "Red") +
      geom_line(aes(x = Pos, y = Stops2), colour = "Blue") +
      facet_wrap(vars(session_id), ncol = 5, scales = "free_y")
}

(pl_p <- spatial_firing_probe_only %>% filter(final_model_o_b == "P") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") %>%
  stops_plot(cn1 = "average_stops", cn2 = "average_stops_p"))
  
(pl_n <- spatial_firing_probe_only %>% filter(final_model_o_b == "P") %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") %>%
  stops_plot(cn1 = "average_stops", cn2 = "average_stops_p"))
  
```


spatial_firing_probe_positional <- select(spatial_firing_probe_positional, session_id, cluster_id, unique_id, final_model_o_b, lm_group_b, lm_group_nb, lm_group_p) %>%
  unnest(cols = c(unique_id,final_model_o_b, lm_group_b, lm_group_nb, lm_group_p)) %>%
  as.tibble()
spatial_firing_probe_positional$cluster_id <- as.numeric(spatial_firing_probe_positional$cluster_id)
write.table(spatial_firing_probe_positional, "data_out/positional_cells_with_probe_data.csv", quote=FALSE, sep="\t")
```
