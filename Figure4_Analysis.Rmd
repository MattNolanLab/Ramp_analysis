---
title: "Figure4_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### --------------------------------------------------------------------------------- ###


## Runs analysis that compares cued trials (beaconed) to uncued (non-beaconed + probe)

_note : focuses on activity in outbound region_


### --------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons has the following pattern ramp activity :

1. ramp in both cued and uncued (cue independent)
2. ramp in just cued (cue dependent)
3. ramp in just uncued (only pi)

To classify cells into these categories above, we will use the classification established in Figure 2. This requires that Figure 2 analyses have been run for B and NB groups.

1. make function to classify cells based on activity in beaconed / non-beaconed & probe trials 
```{r}
mark_neurons <- function(beac, nb){
  if (is.na(beac) | is.na(nb) ) {
    return( "None" )
  } else if( beac == "Positive" & nb == "Positive") {
    return( "Positive-PI" )
  } else if( beac == "Negative" & nb == "Negative") {
    return( "Negative-PI" )
  } else if( beac == "Positive" & nb == "Unclassified") {
    return( "Positive-cue" )
  } else if( beac == "Negative" & nb == "Unclassified") {
    return( "Negative-cue" )
  } else if( beac == "Unclassified" & nb == "Positive") {
    return( "Positive-onlypi" )
  } else if( beac == "Unclassified" & nb == "Negative") {
    return( "Negative-onlypi" )
  } else if( beac == "Unclassified" & nb == "Unclassified") {
    return( "Unclassified" )
    } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(cue_group_o = map2(lm_group_b, lm_group_nb, mark_neurons))

```



Visualise the proportion of cells that fit the above criteria.  

We will focus here only on neurons classified as having a positive or negative slope in Figure 2. A problem with this analysis is that it includes neurons that in Figure 3 are shown to be modulated by speed or acceleration but not position. The analysis below will address this.


Function to return a tibble with proportions of neurons classified as cue-dependent, cue-independent or path integration only.
```{r}
calc_props_cue_dep <- function(cue_group){
  cue_group <- as.character(cue_group)
  num_cells <- length(cue_group)
  
  pi_num <- length(which(cue_group == "Positive-PI" | cue_group == "Negative-PI"))
  cue_num <- length(which(cue_group == "Positive-cue" | cue_group == "Negative-cue"))
  pionly_num <- length(which(cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi"))
  uc_num <- length(which(cue_group == "Unclassified"))
  none_num <- length(which(cue_group == "None"))
  
  pi <- pi_num / num_cells
  cue <- cue_num / num_cells
  pionly <- pionly_num / num_cells
  uc <-uc_num / num_cells
  none <- none_num / num_cells

proportions_mixed_ramps <- tibble(perc=c(pi, cue, pionly, uc, none), num=c(pi_num, cue_num, pionly_num, uc_num, none_num), ramp_id= c("Cue-independent", "Cue-dependant", "Path-Integration-only", "Unclassified", "None"),ramp_type = c("Cue-independent", "Cue-dependant", "Path-Integration-only", "Unclassified", "None"))
}
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_mixed_ramps <- calc_props_cue_dep(spatial_firing$cue_group_o)
```


3. Plot a pie chart of results, 
_note : pie segments represent the proportions with real values in text_
```{r}
proportions_mixed_ramps_pi_maker <- function(df){
  # Compute the position of labels
data <- df %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")
}

proportions_mixed_ramps_pi_maker(proportions_mixed_ramps)
# ggsave(file = "plots/CueComparison_proportions.png", width = 4, height = 4)

```




### -------------------------------------------------------------------------------------------------------- ###

We also want to compare the classification of neurons between cued and uncued trials. We will do this using a Sankey plot

We need a pair of vectors called 'value' that contain the number of cells for each group transition between 'source' and 'target', which are categories for slopes the beaconed and the non-beaconed trials.
The transitions will be ordered as:
++
+-
+NC
-+
--
-NC
NC+
NC-
NCNC

```{r}
# ob_group and h_group are column names from the results data frame that contain the grouping information.
calc_transitions <- function(group1, group2){
  df <- tibble(g1 = as.character(group1), g2 = as.character(group2))
  
  transition_values <- c(length(which(df$g1 == "Positive" & df$g2 == "Positive")),
                         length(which(df$g1 == "Positive" & df$g2 == "Negative")),
                         length(which(df$g1 == "Positive" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Negative" & df$g2 == "Positive")),
                         length(which(df$g1 == "Negative" & df$g2 == "Negative")),
                         length(which(df$g1 == "Negative" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Positive")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Negative")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Unclassified")))
  transition_values_long <- tibble(value = transition_values,
                                   source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "Unclassified","Unclassified", "Unclassified"),
                                   target= c(" Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified")
                                   ) %>%
    filter(value > 0)
  
  nodes <- data.frame(name=c(as.character(transition_values_long$source), as.character(transition_values_long$target)) %>% unique())
  transition_values_long$IDsource=match(transition_values_long$source, nodes$name)-1
  transition_values_long$IDtarget=match(transition_values_long$target, nodes$name)-1
  return(transition_values_long)

}

```


Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long <- calc_transitions(spatial_firing$lm_group_b, spatial_firing$lm_group_nb)

# Probably a more elegant way to do this as already made in calc_transitions
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

```


5. Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```





### ------------------------------------------------------------------------------------- ###

_same as above but just for position based cells_

We want to focus the analysis exclusively on neurons that have a +/- slope (Figure 2) and are position modulated (Figure 3).

```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```



Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_pos_mixed_ramps <- calc_props_cue_dep(position_neurons$cue_group_o)

proportions_mixed_ramps_pi_maker(proportions_pos_mixed_ramps)
```
Make a data frame that contains numbers to be used for the Sankey plot.
```{r}
data_long_pos <- calc_transitions(position_neurons$lm_group_b, position_neurons$lm_group_nb)

# Probably a more elegant way to do this as already made in calc_transitions
nodes_pos <- data.frame(name=c(as.character(data_long_pos$source), as.character(data_long_pos$target)) %>% unique())

```


5. Plot Sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long_pos, Nodes = nodes_pos,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```

## For the neurons in the above Sankey plot that have positive or negative slopes on the non-beaconed/probe trials, calculate the proportion in each model group

A function to calculate neurons in each group. Groups are:
P, PA, PS, PSA for NB+ and NB- slopes.
```{r}
calc_pos_groups <- function(lmgroup, final_model) {
  total_plus_neurons <-  length(which(lmgroup == "Positive"))
  total_neg_neurons <-  length(which(lmgroup == "Negative"))
  data_groups <- tibble(perc = c(
    length(which(lmgroup == "Positive" & final_model == "P"))/total_plus_neurons,
    length(which(lmgroup == "Positive" & final_model == "PA"))/total_plus_neurons,
    length(which(lmgroup == "Positive" & final_model == "PS"))/total_plus_neurons,
    length(which(lmgroup == "Positive" & final_model == "PSA"))/total_plus_neurons,
    length(which(lmgroup == "Negative" & final_model == "P"))/total_neg_neurons,
    length(which(lmgroup == "Negative" & final_model == "PA"))/total_neg_neurons,
    length(which(lmgroup == "Negative" & final_model == "PS"))/total_neg_neurons,
    length(which(lmgroup == "Negative" & final_model == "PSA"))/total_neg_neurons
  ),
  ramp_id= c("P","PA","PS", "PSA", "P","PA","PS", "PSA"),
  ramp_type = c("Positive", "Positive", "Positive", "Positive", "Negative", "Negative", "Negative", "Negative"))
  data_groups$perc <- data_groups$perc*100
  return(data_groups)
}
```


Calculate distribution of groups on non-beaconed trials.
```{r}
pos_groups <- calc_pos_groups(position_neurons$lm_group_nb, position_neurons$final_model_o_b)
```

3. plot data
```{r}
# plot data
level_order <- c("P", "PS", "PA", "PSA")
ggplot(pos_groups, aes(x = factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons") +
  scale_fill_manual(values=c("firebrick1","darkorange", "darkorchid1","darkslategray")) +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=14), 
        legend.text=element_text(size=14), 
        axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0))) +
ggsave(file = "plots/cell_proportions-AllNeurons.png", width = 4, height = 4.5)

```




### --------------------------------------------------------------------------------------- ###

Now we want to visualise the average firing rate for each of the groups (cue dependant & cue independent / positive & negative).

We will again focus exclusively on neurons that have a +/- slope (Figure 2) and are position modulated (Figure 3). To do so we will use the frame position_neurons generated above.

Function to plot data mean and SD of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SD_plots <- function(df, group_b, group_nb, x_start = 30, x_end = 90){
  df <- df %>%
    filter(lm_group_b == group_b,
           lm_group_nb == group_nb) %>%
    select(Rates_averaged_rewarded_b, Rates_averaged_rewarded_nb, cue_group_o) %>%
    unnest(c(Rates_averaged_rewarded_b, Rates_averaged_rewarded_nb))
 df$Rates_averaged_rewarded_b <- as.double(df$Rates_averaged_rewarded_b)
 df$Rates_averaged_rewarded_nb <- as.double(df$Rates_averaged_rewarded_nb)
 df$cue_group_o <- as.character(df$cue_group_o)
 numcells <- length(df$Rates_averaged_rewarded_nb)/200
 df$Position <- rep(1:200, times = numcells)
 
 df <- df %>%
   group_by(cue_group_o, Position) %>%
   summarise(mean_b = mean(Rates_averaged_rewarded_b, na.rm = TRUE),
             mean_nb = mean(Rates_averaged_rewarded_nb, na.rm = TRUE),
             se_b = std.error(Rates_averaged_rewarded_b, na.rm = TRUE),
             se_nb = std.error(Rates_averaged_rewarded_nb, na.rm = TRUE))
 
 ggplot(data=df) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - se_nb, ymax = mean_nb + se_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  #stat_smooth(aes(y=mean_b, x=Position), color = "Grey32", n = 60, span = 0.5) +
  #stat_smooth(aes(y=mean_nb, x=Position), color = "Red2", n = 60, span = 0.5) +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```



2. Subset data by group then average rates for plotting          **Negative Cue**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Unclassified"))
# ggsave(file = "plots/AverageRates_PositionCells_NegCue.png", width = 3.5, height = 2.5)
```


4. Subset data by group then average rates for plotting          **Positive Cue**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Unclassified"))
# ggsave(file = "plots/AverageRates_PositionCells_PosCue.png", width = 3.5, height = 2.5)
```



4. Subset data by group then average rates for plotting          **Positive PI**

```{r}
(PosPos_plot <- mean_SD_plots(position_neurons, "Positive", "Positive"))
# ggsave(file = "plots/AverageRates_PositionCells_PosPI.png", width = 3.5, height = 2.5)
```



4. Subset data by group then average rates for plotting          **Negative PI**

```{r}
(NegNeg_plot <- mean_SD_plots(position_neurons, "Negative", "Negative"))
# ggsave(file = "plots/AverageRates_PositionCells_NegPI.png", width = 3.5, height = 2.5)
```


4. Subset data by group then average rates for plotting          **Negative PI only**

These data are not in position neurons so make a new data frame containing these neurons.
```{r}
unclassified_neurons <- filter(spatial_firing, lm_group_b == "Unclassified")
```



```{r}
(UCNeg_plot <- mean_SD_plots(unclassified_neurons, "Unclassified", "Negative"))
# ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)
```


4. Subset data by group then average rates for plotting          **Positive PI only**

```{r}
(UCPos_plot <- mean_SD_plots(unclassified_neurons, "Unclassified", "Positive"))
# ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)
```

### ---------------------------------------------------------------------------------------- ### 


Now, i want to visualise cue dependent and independent on the same plot so i can compare them

1. Subset data by group then average rates for plotting          **Negative slopes only**

```{r}

df_neg <- df %>%
  group_by(Position, group) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  subset(group != "None" & group == "Negative-cue" | group == "Negative-PI") #%>%
  #mutate(Position = rep(0:60))
  
```

2. Plot data 
```{r}
ggplot(data=df_neg) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b, fill=group), alpha=0.2) +
  geom_line(aes(y=mean_b, x=Position, color=group)) +
  theme_classic() +
  scale_color_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  scale_fill_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negative_outbound.png", width = 6, height = 3)


```


3. Subset data by group then average rates for plotting          **Positive slopes only**


```{r}

df_pos <- df %>%
  group_by(Position, group) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  subset(group != "None" & group == "Positive-cue" | group == "Positive-PI")
  #mutate(Position = rep(0:60))
  
```


```{r}
ggplot(data=df_pos) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b, fill=group), alpha=0.2) +
  geom_line(aes(y=mean_b, x=Position, color=group)) +
  theme_classic() +
  scale_color_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  scale_fill_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Positive_outbound.png", width = 6, height = 3)

```




