---
title: "Figure4_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### --------------------------------------------------------------------------------- ###


## Runs analysis that compares cued trials (beaconed) to uncued (non-beaconed + probe)

_note : focuses on activity in outbound region_


### --------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons has the following pattern ramp activity :

1. ramp in both cued and uncued (cue independent)
2. ramp in just cued (cue dependent)
3. ramp in just uncued (only pi)

To classify cells into these categories above, we will use the classification established in Figure 2. This requires that Figure 2 analyses have been run for B and NB groups.

1. make function to classify cells based on activity in beaconed / non-beaconed & probe trials 
```{r}
mark_neurons <- function(beac, nb){
  if (is.na(beac) | is.na(nb) ) {
    return( "None" )
  } else if( beac == "Positive" & nb == "Positive") {
    return( "Positive-PI" )
  } else if( beac == "Negative" & nb == "Negative") {
    return( "Negative-PI" )
  } else if( beac == "Positive" & nb == "Unclassified") {
    return( "Positive-cue" )
  } else if( beac == "Negative" & nb == "Unclassified") {
    return( "Negative-cue" )
  } else if( beac == "Unclassified" & nb == "Positive") {
    return( "Positive-onlypi" )
  } else if( beac == "Unclassified" & nb == "Negative") {
    return( "Negative-onlypi" )
    } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(cue_group_b = map2(lm_group_b, lm_group_nb, mark_neurons))

```



Visualise the proportion of cells that fit the above criteria.  

We will focus here only on neurons classified as having a positive or negative slope in Figure 2. A problem with this analysis is that it includes neurons that in Figure 3 are shown to be modulated by speed or acceleration but not position. The analysis below will address this.


Function to return a tibble with proportions of neurons classified as cue-dependent, cue-independent or path integration only.
```{r}
calc_props_cue_dep <- function(cue_group){
  cue_group <- as.character(cue_group)
  num_cells <- length(cue_group)
  
  pi_num <- length(which(cue_group == "Positive-PI" | cue_group == "Negative-PI"))
  cue_num <- length(which(cue_group == "Positive-cue" | cue_group == "Negative-cue"))
  pionly_num <- length(which(cue_group == "Positive-onlypi" | cue_group == "Negative-onlypi"))
  none_num <- length(which(cue_group == "None" | cue_group == "None"))
  
  pi <- pi_num / num_cells
  cue <- cue_num / num_cells
  pionly <- pi_num / num_cells
  none <- none_num / num_cells

proportions_mixed_ramps <- tibble(perc=c(pi, cue, pionly, none), num=c(pi_num, cue_num, pionly_num, none_num), ramp_id= c("Cue-independent", "Cue-dependant", "Path-Integration-only", "None"),ramp_type = c("Cue-independent", "Cue-dependant", "Path-Integration-only", "None"))
}
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_mixed_ramps <- calc_props_cue_dep(spatial_firing$cue_group_b)
```


3. Plot a pie chart of results, 
_note : pie segments represent the proportions with real values in text_
```{r}
# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")

# ggsave(file = "plots/CueComparison_proportions.png", width = 4, height = 4)

```




### -------------------------------------------------------------------------------------------------------- ###

We also want to see the movement of neurons from cue to uncued trials, do this using a Sankey plot


1. Subset based on cue dependency
```{r}
# positive homebound slopes
pi <-subset(spatial_firing, cue_group_b == "Positive-PI" | cue_group_b == "Negative-PI")
cue <-subset(spatial_firing, cue_group_b == "Positive-cue" | cue_group_b == "Negative-cue")
pionly <-subset(spatial_firing, cue_group_b == "Positive-onlypi" | cue_group_b == "Negative-onlypi")

pi_neg <-subset(spatial_firing, cue_group_b == "Negative-PI")
cue_neg <-subset(spatial_firing,  cue_group_b == "Negative-cue")
pi_pos <-subset(spatial_firing, cue_group_b == "Positive-PI" )
cue_pos <-subset(spatial_firing, cue_group_b == "Positive-cue" )

```

2. Subset based on non-beaconed activity
```{r}

pi_positive <-subset(spatial_firing, lm_group_b == "Positive")
pi_negative <-subset(spatial_firing, lm_group_b == "Negative")
pi_none <-subset(spatial_firing, lm_group_b == "Unclassified")

pi_positive_pos <-nrow(subset(pi_positive, lm_group_nb == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_group_nb == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_group_nb == "Unclassified"))
pi_negative_pos <-nrow(subset(pi_negative, lm_group_nb == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_group_nb == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_group_nb == "Unclassified"))
pi_none_pos <-nrow(subset(pi_none, lm_group_nb == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_group_nb == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_group_nb == "Unclassified"))

```

We need a pair of vectors called 'value' that contain the number of cells for each group transition between 'source' and 'target', which are categories for slopes the beaconed and the non-beaconed trials.
The transitions will be ordered as:
++
+-
+NC
-+
--
-NC
NC+
NC-
NCNC

```{r}
# ob_group and h_group are column names from the results data frame that contain the grouping information.
calc_transitions <- function(group1, group2){
  df <- tibble(g1 = as.character(group1), g2 = as.character(group2))
  
  transition_values <- c(length(which(df$g1 == "Positive" & df$g2 == "Positive")),
                         length(which(df$g1 == "Positive" & df$g2 == "Negative")),
                         length(which(df$g1 == "Positive" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Negative" & df$g2 == "Positive")),
                         length(which(df$g1 == "Negative" & df$g2 == "Negative")),
                         length(which(df$g1 == "Negative" & df$g2 == "Unclassified")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Positive")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Negative")),
                         length(which(df$g1 == "Unclassified" & df$g2 == "Unclassified")))

}

test <- calc_transitions(spatial_firing$lm_group_b, spatial_firing$lm_group_nb)

```



3. Put data into a tibble with labels
```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "Unclassified","Unclassified", "Unclassified"),
                     target= c(" Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified"," Positive"," Negative", " Unclassified"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

3. Create a node data frame: it lists every entities involved in the flow
```{r}
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

4. Reformat dataframe to provide connection using id, not using the real name like in the links dataframe
```{r}
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

5. Plot sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```





### ------------------------------------------------------------------------------------- ###

_same as above but just for position based cells_

We want to focus the analysis exclusively on neurons that have a +/- slope (Figure 2) and are position modulated (Figure 3).

```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```


<!-- ```{r} -->
<!-- unclassified_neurons <-subset(spatial_firing, lm_group_b == "Unclassified") -->
<!-- nb_neurons <-subset(unclassified_neurons, lm_group_nb == "Positive" | lm_group_nb == "Negative") -->

<!-- ``` -->

<!-- 2. subset based on position -->
<!-- ```{r} -->
<!-- position_neurons <-subset(nb_neurons, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") -->
<!-- ``` -->


2. Subset based on non-beaconed activity
```{r}

pi_positive <-subset(position_neurons, lm_group_b == "Positive")
pi_negative <-subset(position_neurons, lm_group_b == "Negative")
pi_none <-subset(position_neurons, lm_group_b == "Unclassified")

pi_positive_pos <-nrow(subset(pi_positive, lm_group_nb == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_group_nb == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_group_nb == "Unclassified"))
pi_negative_pos <-nrow(subset(pi_negative, lm_group_nb == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_group_nb == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_group_nb == "Unclassified"))
pi_none_pos <-nrow(subset(pi_none, lm_group_nb == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_group_nb == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_group_nb == "Unclassified"))

```

3. Put data into a tibble with labels
```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

3. Create a node data frame: it lists every entities involved in the flow
```{r}
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

4. Reformat dataframe to provide connection using id, not using the real name like in the links dataframe
```{r}
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

5. Plot sankey diagram
```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```




## calculate for the neurons included in the above sankey, what proportion of neurons are in each model group
```{r}
pi_positive <-subset(position_neurons, lm_group_b == "Positive")
pi_negative <-subset(position_neurons, lm_group_b == "Negative")

pi_unclassified <-subset(position_neurons, lm_group_b == "Negative")
pi_unclassified <-subset(pi_unclassified, lm_group_nb == "Negative" | lm_group_nb == "Positive")

```

```{r}
# calculate propotion of groups
P_positive <- nrow(subset(pi_positive, final_model_o_b == "P"))/nrow(pi_positive)*100
PA_positive <- nrow(subset(pi_positive, final_model_o_b == "PA"))/nrow(pi_positive)*100
PS_positive <- nrow(subset(pi_positive, final_model_o_b == "PS"))/nrow(pi_positive)*100
PSA_positive <- nrow(subset(pi_positive, final_model_o_b == "PSA"))/nrow(pi_positive)*100

# calculate propotion of groups
P_negative <- nrow(subset(pi_negative, final_model_o_b == "P"))/nrow(pi_negative)*100
PA_negative <- nrow(subset(pi_negative, final_model_o_b == "PA"))/nrow(pi_negative)*100
PS_negative <- nrow(subset(pi_negative, final_model_o_b == "PS"))/nrow(pi_negative)*100
PSA_negative <- nrow(subset(pi_negative, final_model_o_b == "PSA"))/nrow(pi_negative)*100

```
2. put data in tibble
```{r}

data_groups <- tibble(perc=c(P_positive,PA_positive,PS_positive,PSA_positive, P_negative, PA_negative, PS_negative, PSA_negative),ramp_id= c("P","PA","PS", "PSA", "P","PA","PS", "PSA"), ramp_type = c("Positive", "Positive", "Positive", "Positive", "Negative", "Negative", "Negative", "Negative"))

```

3. plot data
```{r}
# plot data
level_order <- c("P", "PS", "PA", "PSA")
ggplot(data_groups, aes(x = factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons") +
  scale_fill_manual(values=c("firebrick1","darkorange", "darkorchid1","darkslategray")) +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=14), 
        legend.text=element_text(size=14), 
        axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0))) +
ggsave(file = "plots/cell_proportions-AllNeurons.png", width = 4, height = 4.5)

```




### --------------------------------------------------------------------------------------- ###

Now we want to visualise the average firing rate for each of the groups (cue dependant & cue independent / positive & negative)

1. Extract all data into tibble 
```{r}
df <- tibble(Position = rep(1:200, times=nrow(position_neurons)), Rates = unlist(position_neurons$Rates_averaged_rewarded_b),Rates_nb = unlist(position_neurons$Rates_averaged_rewarded_nb), lm_group_beaconed = rep(position_neurons$lm_group, each=200), lm_group_nonbeaconed = rep(position_neurons$lm_group_nb, each=200), group = rep(as.character(position_neurons$cue_group), each=200))

```

2. Subset data by group then average rates for plotting          **Negative Cue**
```{r}
df_neg_cue <- df %>%
  subset(lm_group_beaconed == "Negative" & lm_group_nonbeaconed == "Unclassified") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60)) # rewriting position for plot because its easier than doing it ggplot
  
```

5. Plot average beaconed and non-beaconed rates                 **Negative Cue**
```{r}
ggplot(data=df_neg_cue) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  #stat_smooth(aes(y=mean_b, x=Position), color = "Grey32", n = 60, span = 0.5) +
  #stat_smooth(aes(y=mean_nb, x=Position), color = "Red2", n = 60, span = 0.5) +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/AverageRates_PositionCells_NegCue.png", width = 3.5, height = 2.5)

```


4. Subset data by group then average rates for plotting          **Positive Cue**

```{r}
df_pos_cue <- df %>%
  subset(lm_group_beaconed == "Positive" & lm_group_nonbeaconed == "Unclassified") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates                                            **Positive Cue**
```{r}
ggplot(data=df_pos_cue) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/AverageRates_PositionCells_PosCue.png", width = 3.5, height = 2.5)


```




4. Subset data by group then average rates for plotting          **Positive PI**

```{r}
df_pos_pi <- df %>%
  subset(lm_group_beaconed == "Positive" & lm_group_nonbeaconed == "Positive") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))

```

5. Plot average rates                                            **Positive PI**

```{r}
ggplot(data=df_pos_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/AverageRates_PositionCells_NegPI.png", width = 3.5, height = 2.5)


```




4. Subset data by group then average rates for plotting          **Negative PI**

```{r}
df_neg_pi <- df %>%
  subset(lm_group_beaconed == "Negative" & lm_group_nonbeaconed == "Negative") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates                                           **Negative PI**

```{r}
ggplot(data=df_neg_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic()  +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/AverageRates_PositionCells_PosPI.png", width = 3.5, height = 2.5)


```


4. Subset data by group then average rates for plotting          **Negative PI only**

```{r}
df_neg_pi <- df %>%
  subset(lm_group_beaconed == "Unclassified" & lm_group_nonbeaconed == "Negative") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates                                             **Negative PI only**

```{r}
ggplot(data=df_neg_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic()  +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)


```




4. Subset data by group then average rates for plotting          **Positive PI only**

```{r}
df_neg_pi <- df %>%
  subset(lm_group_beaconed == "Unclassified" & lm_group_nonbeaconed == "Positive") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates                                            **Positive PI only**

```{r}
ggplot(data=df_neg_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic()  +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/AverageRates_PositionCells_PosPIonly.png", width = 3.5, height = 2.5)


```


### ---------------------------------------------------------------------------------------- ### 


Now, i want to visualise cue dependant and indpedant on the same plot so i can compare them

1. Subset data by group then average rates for plotting          **Negative slopes only**

```{r}

df_neg <- df %>%
  group_by(Position, group) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  subset(group != "None" & group == "Negative-cue" | group == "Negative-PI") #%>%
  #mutate(Position = rep(0:60))
  
```

2. Plot data 
```{r}
ggplot(data=df_neg) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b, fill=group), alpha=0.2) +
  geom_line(aes(y=mean_b, x=Position, color=group)) +
  theme_classic() +
  scale_color_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  scale_fill_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negative_outbound.png", width = 6, height = 3)


```


3. Subset data by group then average rates for plotting          **Positive slopes only**


```{r}

df_pos <- df %>%
  group_by(Position, group) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE)) %>%
  subset(group != "None" & group == "Positive-cue" | group == "Positive-PI")
  #mutate(Position = rep(0:60))
  
```


```{r}
ggplot(data=df_pos) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b, fill=group), alpha=0.2) +
  geom_line(aes(y=mean_b, x=Position, color=group)) +
  theme_classic() +
  scale_color_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  scale_fill_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Positive_outbound.png", width = 6, height = 3)

```




