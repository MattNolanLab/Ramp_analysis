---
title: "Figure6_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### ------------------------------------------------------------------------------------------ ### 


## Script aims to determine if ramp activity resets or is continuous across the reward zone in PROBE trials 


### ------------------------------------------------------------------------------------------ ### 

First, classify neurons based on their slope activity in the outbound and homebound region in probe trials (similar to beaconed trials in Figure5_Analysis.Rmd)


i.e. pospos = positive in outbound, positive in homebound
i.e. posneg = positive in outbound, negative in homebound

1. write function to mark cells based on cue_groups
```{r}
mark_track_catagory <- function(outbound, homebound){
  if( outbound == "Positive" & homebound =="Negative") {
    return( "posneg" ) 
  } else if( outbound == "Positive" & homebound =="Positive") {
    return( "pospos" )
  } else if( outbound == "Negative" & homebound =="Positive") {
    return( "negpos" )
  } else if( outbound == "Negative" & homebound =="Negative") {
    return( "negneg" )
  } else if( outbound == "Negative" & homebound =="Unclassified") {
    return( "negnon" )
  } else if( outbound == "Positive" & homebound =="Unclassified") {
    return( "posnon" )
  } else {
    return("None")
  }
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate( track_catagory_p = map2(lm_cue_group_p, lm_cue_group_p_h, mark_track_catagory))

```


### ------------------------------------------------------------------------------------------ ### 

Now, we want to find out if within pospos and negneg cue_groups - are their firing rate reset or continue across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 

First, normalise firing rates. 

1. make function to load rates and normalise
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_p = map(Rates_averaged_rewarded_p, normalise_rates))
```

Then, predict firing rate in hombound region based on fit from real data in outbound region

1. make function to predict firing rate
```{r}
lm_predict <- function(df){
  new.data <- data.frame(Position =df$Position)
}
```

2. Calculate mean apsolute difference between predicted and real fits in the first 5 cm of homebound zone

```{r}

lm_predict_mse_homebound <- function(rate){
  if(all(is.na(rate))) 
    return(NA)
  startbins=c(30:90)
  df <- tibble(Rates = unlist(rate), Position=rep(1:200))

  lmer <- lm(Rates ~ Position, data = df[startbins,])
  
  df_homebound <- df %>% filter(between(Position, 110, 115))
  new.data <- lm_predict(df_homebound)
  Rates <- predict(lmer, newdata = new.data)
  mydata <- cbind(new.data, Rates)
  
  mean( df_homebound$Rates - mydata$Rate, na.rm=TRUE)

}
```

3. Run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(predict_mean_p = map(normalised_rates_p, lm_predict_mse_homebound)) 
  
```


Predict mean and confidence intervals for firing rate at the start of the homebound zone (track positions 110 to 115 cm) based on firing in the outbound zone (30 to 90 cm).
```{r}
predict_homebound <- function(df, fit_start = 30, fit_end = 90, predict_start = 110, predict_end = 115){
  # check for NAs
  if(all(is.na(df))) 
    return(NA)
  # Make track column
  df <- tibble(Rates = unlist(df), Position=rep(1:200))
  model <- lm(Rates ~ Position, data = filter(df, Position >= fit_start, Position <= fit_end))
  homebound_prediction_pos <- tibble(Position = rep(1:200))
  homebound_prediction <- predict(model, newdata = homebound_prediction_pos, interval = "confidence") 
}


```

or with confidence intervals and using absolute rates rather than normalised rates:
```{r}
spatial_firing <- spatial_firing %>%
  mutate(predict_mean_p = map(Rates_averaged_rewarded_p, predict_homebound)) 

```

4. Classify neurons based on apsolute difference between predicted and real as either "Continuous" or "Reset"
```{r}
mark_reset_group <- function(df, id){
  if (is.na(df) ) {
    return( "None" )
  } else if( id == "posneg" | id == "negpos") {
    return( "Switch" ) 
  } else if( (df > -1 & df < 1) & (id == "pospos" | id == "negneg")) {
    return( "Continuous" )
  } else if( (df <= -1 | df >= 1) & (id == "pospos" | id == "negneg")) {
    return( "Reset" ) 
    } else {
    return("None")
  }
}

spatial_firing <- spatial_firing %>%
  mutate(reset_group_p = map2(predict_mean_p, track_catagory_p, mark_color))

```


### ------------------------------------------------------------------------------------------ ### 

## plot bar chart of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone


1. extract neurons with slope on outbound
```{r}
data <- spatial_firing %>% filter(track_catagory_p == "pospos" | track_catagory_p == "negneg" | track_catagory_p == "posneg"| track_catagory_p == "negpos")
```

2. extract only neurons that are driven by path integration (as determined by CueAnalysis.0100.Rmd - i.e. Figure 4)
```{r}
pi_data <- subset(spatial_firing, cue_group == "Positive-PI" | cue_group == "Negative-PI")
```

3. subset based on position
```{r}
pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

4. Plot bar charts 
```{r}

ggplot(data=subset(pi_data,lm_group_p == "Negative"), aes(x = unlist(predict_mean_p), fill=as.factor(unlist(lm_group_p)))) +
  coord_cartesian(xlim=c(-5,5), y=c(0,0.7)) +
  geom_histogram(aes(y=..density..), alpha=0.5) +
  scale_fill_manual(values=c("violetred2")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  geom_vline(xintercept = 1, color="black", linetype="dotted") +
  geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=10), 
        legend.text=element_text(size=10), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/PredictProbe_homebound_mean_PInegative_pi.png",width = 4, height = 2)


ggplot(data=subset(pi_data, lm_group_p == "Positive"), aes(x = unlist(predict_mean_p), fill=as.factor(unlist(lm_group_p)))) +
  coord_cartesian(xlim=c(-5,5), y=c(0,0.7)) +
  geom_histogram(aes(y=..density..), alpha=0.5) +
  scale_fill_manual(values=c( "chartreuse3")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  geom_vline(xintercept = 1, color="black", linetype="dotted") +
  geom_vline(xintercept = -1, color="black", linetype="dotted") +
  labs(y="Density", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=10), 
        legend.text=element_text(size=10), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/PredictProbe_homebound_mean_PIpositive_pi.png",width = 4, height = 2)

```

### ------------------------------------------------------------------------------------------ ### 


## plot outbound and homebound slopes for each neuron - seperated by whether they reset or are continuous 

1. Extract reset and continuous neurons
```{r}
reset <- pi_data %>% filter(reset_group_p == "Reset")
continuous <- pi_data %>% filter(reset_group_p == "Continuous")
```

2. Plot scatter of slopes on outbound&homebound
```{r}

ggplot() + 
    geom_jitter(data=continuous,aes(x = as.numeric(unlist(asr_p_o_rewarded_fit_slope)), y = as.numeric(unlist(asr_p_h_rewarded_fit_slope)), color=factor(unlist(lm_group_b)))) +
    geom_point(data=reset,aes(x = as.numeric(unlist(asr_p_o_rewarded_fit_slope)), y = as.numeric(unlist(asr_p_h_rewarded_fit_slope)), color=factor(unlist(lm_group_b))), shape=1) +
    coord_cartesian(ylim = c(-.7,.7), xlim = c(-.7,.7)) +
    xlab("Outbound slope") +
    ylab("Homebound slope") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=16),
          axis.text.y = element_text(size=16),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/slope_comparison_probe_reset.png", width = 5, height = 5)

```



### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Plot average firing rates for each cue_group of neuron

Now we want to plot population rate across whole track for diff groups so we can visualise the average firing rate

cue_groups are as follows :

outbound homebound  reset
    +       +         n
    +       +         y
    +       -         -
    +      non        -
    -       +         -
    -       -         n
    -       -         y
    -      non        -



1. Split data based on cue independant/cue dependant

```{r}
pi_data <- subset(spatial_firing, cue_group == "Positive-PI" | cue_group == "Negative-PI")
```

3. subset based on position
```{r}
pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

# go into dataframe and from each average_rates column : just path integration neurons
```{r}
df <- tibble(Position = rep(1:200, times=nrow(pi_data)), 
             Rates = unlist(pi_data$Rates_averaged_rewarded_p), 
             Outbound_beaconed = rep(pi_data$lm_group_p, each=200), 
             Homebound_beaconed = rep(pi_data$lm_group_p_h, each=200), 
             reset_group = rep(as.character(pi_data$reset_group_p), each=200), 
             predict_mean = rep(as.numeric(pi_data$predict_mean_p), each=200))

```


```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(reset_group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```

```{r}
ggplot(data=df_neg_cue) +
  coord_cartesian(ylim = c(5,40)) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negneg_continuous_mean_probe.png", width = 3.5, height = 2.5)

```





```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Negative") %>%
  subset(reset_group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```

```{r}
ggplot(data=df_neg_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negneg_reset_mean_probe.png", width = 3.5, height = 2.5)

```





```{r}
df_pos_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```



```{r}
ggplot(data=df_pos_cue) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "Black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negpos_mean_probe.png", width = 3.5, height = 2.5)

```





```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(reset_group == "Continuous") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```



```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Pospos_continuous_mean_probe.png", width = 3.5, height = 2.5)


```



```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Positive") %>%
  subset(reset_group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```



```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Negneg_reset_mean_probe.png", width = 3.5, height = 2.5)


```




```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/Posneg_mean_probe.png", width = 3.5, height = 2.5)


```





```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/posnon_mean_probe.png", width = 3.5, height = 2.5)


```




```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Negative" & Homebound_beaconed == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169))
  
```


```{r}
ggplot(data=df_pos_pi) +
  annotate("rect", xmin=-30, xmax=0, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=140, xmax=170, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=60, xmax=80, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.5) +
  geom_line(aes(y=mean_b, x=Position), color = "black") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/negnon_mean_probe.png", width = 3.5, height = 2.5)


```


### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


### Plot Sankey Diagrams

1.
```{r}
data <- spatial_firing %>% filter(track_catagory_p == "pospos" | track_catagory_p == "negneg")

```

2. filter for pi neurons
```{r}
pi_data <- subset(data, cue_group == "Positive-PI" | cue_group == "Negative-PI")

```

3. subset based on position
```{r}
pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

# filter for negative > negative & positive > positive
```{r}
negneg_pineurons <-subset(pi_data, lm_group_p == "Negative" & lm_group_p_h == "Negative")
posos_pineurons <-subset(pi_data, lm_group_p == "Positive" & lm_group_p_h == "Positive")
negpos_pineurons<-subset(pi_data, lm_group_p == "Negative" & lm_group_p_h == "Positive")
posneg_pineurons<-subset(pi_data, lm_group_p == "Positive" & lm_group_p_h == "Negative")

```


# find out proportions of reset and continuous in these cue_groups
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, reset_group_p == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, reset_group_p == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, reset_group_p == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, reset_group_p == "Continuous"))

posneg_pineurons <-nrow(posneg_pineurons)/nrow(posneg_pineurons)*100
negpos_pineurons <-nrow(negpos_pineurons)/nrow(negpos_pineurons)*100

```

## raw numbers 
```{r}
negneg_pineurons_reset <- nrow(subset(negneg_pineurons, reset_group_p == "Reset"))
negneg_pineurons_cont <-nrow(subset(negneg_pineurons, reset_group_p == "Continuous"))

pospos_pineurons_reset <-nrow(subset(posos_pineurons, reset_group_p == "Reset"))
pospos_pineurons_cont <-nrow(subset(posos_pineurons, reset_group_p == "Continuous"))
```


```{r}

data_long <- tibble(value=c(negneg_pineurons_reset, negneg_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont), 
                    
                      source= c("Negative > Negative","Negative > Negative", "Positive > Positive", "Positive > Positive"),
                     target= c("Reset", "Continuous", "Reset", "Continuous"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```


```{r}
# A connection data frame is a list of flows with intensity for each flow
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","F56666", "#FDE725FF","#B4DE2CFF" ,"#F56666", "#B4DE2CFF","FDE725FF", "#B4DE2CFF", "#B4DE2CFF"])'

#ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'


links <- data.frame(
  source=c("Positive1","Positive1", "Reset1", "Continuous1", "Negative1", "Negative1",  "Reset2", "Continuous2"), 
  target=c("Reset1","Continuous1", "Positive2", "Positive2", "Reset2", "Continuous2", "Negative2", "Negative2"), 
  value=c(pospos_pineurons_reset,pospos_pineurons_cont, pospos_pineurons_reset, pospos_pineurons_cont, negneg_pineurons_reset, negneg_pineurons_cont ,negneg_pineurons_reset, negneg_pineurons_cont))
  
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1

# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=30, fontSize=13, nodePadding=15)


p


```



##

```{r}
data <- spatial_firing %>% filter(track_catagory_p == "pospos" | track_catagory_p == "negneg" | track_catagory_p == "posneg"| track_catagory_p == "negpos" | track_catagory_p == "negnon" | track_catagory_p == "posnon")

pi_data <- subset(data, cue_group == "Positive-PI" | cue_group == "Negative-PI")

pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")

```

```{r}

pi_positive <-subset(pi_data, lm_group_p == "Positive")
pi_negative <-subset(pi_data, lm_group_p == "Negative")
pi_none <-subset(pi_data, lm_group_p == "Unclassified")
pi_ramp <-subset(pi_data, lm_group_p == "Positive" | lm_group_p == "Negative")

pi_positive_pos <-nrow(subset(pi_positive, lm_group_p_h == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_group_p_h == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_group_p_h == "Unclassified"))
pi_negative_pos <-nrow(subset(pi_negative, lm_group_p_h == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_group_p_h == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_group_p_h == "Unclassified"))
pi_none_pos <-nrow(subset(pi_none, lm_group_p_h == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_group_p_h == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_group_p_h == "Unclassified"))


```

```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```




```{r}
pi_positive_pos <-nrow(subset(pi_positive, lm_result_h_p == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, lm_result_h_p == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, lm_result_h_p == "None"))
pi_negative_pos <-nrow(subset(pi_negative, lm_result_h_p == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, lm_result_h_p == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, lm_result_h_p == "None"))
pi_none_pos <-nrow(subset(pi_none, lm_result_h_p == "Positive"))
pi_none_neg <-nrow(subset(pi_none, lm_result_h_p == "Negative"))
pi_none_none <-nrow(subset(pi_none, lm_result_h_p == "None"))

```

