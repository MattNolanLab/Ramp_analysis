---
title: "Figure6_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### ------------------------------------------------------------------------------------------ ### 


## Script aims to determine if ramp activity resets or is continuous across the reward zone in PROBE trials 


### ------------------------------------------------------------------------------------------ ### 

First, classify neurons based on their slope activity in the outbound and homebound region in probe trials (similar to beaconed trials in Figure5_Analysis.Rmd)


i.e. pospos = positive in outbound, positive in homebound
i.e. posneg = positive in outbound, negative in homebound

1. To mark cells based on cue_groups use function 'mark_track_category' defined in Figure 5.

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(track_category_p = map2(lm_group_p, lm_group_p_h, mark_track_category))

```


### ------------------------------------------------------------------------------------------ ### 

Now, we want to find out if within pospos and negneg cue_groups - is their firing rate reset or continue across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 

First, normalise firing rates. 

1. make function to load rates and normalise
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_p = map(Rates_averaged_rewarded_p, normalise_rates))
```

Then, predict firing rate in homebound region based on fit from real data in outbound region

Predict mean and confidence intervals for firing rate at the start of the homebound zone (track positions 110 to 115 cm) based on firing in the outbound zone (30 to 90 cm).

2. Run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_p_')) %>%
  mutate(predict_params_p = map(normalised_rates_p, predict_homebound)) %>%
  unnest_wider(predict_params_p, names_sep = "_", names_repair = "universal")

spatial_firing <- spatial_firing %>%
  mutate(offset_p = pmap_chr(list(normalised_rates_p, predict_params_p_lwr, predict_params_p_upr), offset_test),
         predict_diff_p = map2_dbl(normalised_rates_p, predict_params_p_fit, calc_predict_diff))

```


Now, we can classify cells based on their predicted activity. 

1. Function to classify neurons based on offset (Matt code that does it based on prediction)

Use function 'mark_reset_group_predict' defined in Figure 5.

2. Run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reset_group_p = map(offset_p, mark_reset_group_predict))

```

4. Classify neurons based on absolute difference between predicted and real as either "Continuous" or "Reset"

## catagorised based on predict alone, ignoring slope?

Now, we can classify cells based on their predicted activity. 

1. Function to classify neurons based on predict mean _this is defined in Figure 5_

2. Run on all cells
```{r}
# spatial_firing <- spatial_firing %>%
#   mutate(reset_group_p = map(predict_diff_p, mark_reset_group))
```




### ------------------------------------------------------------------------------------------ ### 

## plot bar chart of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone


1. extract only neurons that are positive or negative in the outbound zone (as determined by Figure 2) and subset based on position encoding (Figure 3) and are ++ or -- in beaconed trials
```{r}
df <- spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(track_category == "pospos" | track_category == "negneg") 
  
```

2. Plot bar charts 
```{r}
ggplot(data=subset(df,lm_group_b == "Negative"), aes(x = unlist(predict_diff_p), fill=as.factor(unlist(reset_group_p)))) +
  coord_cartesian(xlim=c(-5,5)) +
  geom_histogram(aes(y=..count..), alpha=0.5) +
  scale_fill_manual(values=c("grey","violetred2")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  labs(y="Count", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_homebound_mean_PInegative_pi.png",width = 4, height = 2.5)
}

ggplot(data=subset(df, lm_group_b == "Positive"), aes(x = unlist(predict_diff_p), fill=as.factor(unlist(reset_group_p)))) +
  coord_cartesian(xlim=c(-5,5)) +
  geom_histogram(aes(y=..count..), alpha=0.5) +
  scale_fill_manual(values=c("grey","chartreuse3")) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
  labs(y="Count", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_homebound_mean_PIpositive_pi.png",width = 4, height = 2.5)
}
```

### ------------------------------------------------------------------------------------------ ### 


## plot outbound and homebound slopes for each neuron - seperated by whether they reset or are continuous 
1. Subset neurons for positive or negative slope in the outbound zone, position encoding (Figure 3) and reset activity in probe trials
```{r}
slope_df <- spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>% 
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```


2. Plot scatter of slopes on beaconed&probe
```{r}
ggplot() + 
    geom_point(data=subset(slope_df, track_category == "pospos" | track_category == "negneg"),
               aes(x = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_p_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), alpha=0.8) +
    geom_point(data=subset(slope_df, track_category == "posneg" | track_category == "negpos"),
               aes(x = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_p_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), shape=2, alpha=0.8) +
    geom_point(data=subset(slope_df, track_category == "posnon" | track_category == "negnon"),
               aes(x = as.numeric(unlist(asr_b_h_rewarded_fit_slope)), 
                   y = as.numeric(unlist(asr_p_h_rewarded_fit_slope)), 
                   color=factor(unlist(lm_group_b))), shape=3, alpha=0.8) +  
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    xlab("Beaconed slope") +
    ylab("Probe slope") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3", "grey")) +
    theme(axis.text.x = element_text(size=17),
          axis.text.y = element_text(size=17),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
 ggsave(file = "plots/slope_comparison_probe_reset.png", width = 4, height = 4) 
}
```
Calculate r2 and p value for liner correlation of the above data
```{r}
pi_data_for_regression <- spatial_firing %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>% 
  select(asr_b_h_rewarded_fit_slope, asr_p_h_rewarded_fit_slope)

model <- lm(asr_b_h_rewarded_fit_slope ~ asr_p_h_rewarded_fit_slope, data = pi_data_for_regression)
summary(model)
# get the model parameters
params <- select(glance(model), r.squared, p.value)

```


1. Subset neurons for positive or negative slope in the outbound zone, position encoding (Figure 3) and reset activity in probe trials and ++ or -- on beaconed trials
```{r}
offset_df <- spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(track_category == "pospos" | track_category == "negneg")

```

2. Plot scatter of offset on beacconed&probe
```{r}
ggplot() + 
    geom_jitter(data=offset_df,aes(x = as.numeric(predict_diff), y = as.numeric(predict_diff_p), color=factor(unlist(track_category))),alpha=0.8) +
    #coord_cartesian(ylim = c(-5,5), xlim = c(-5,5)) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    xlab("Beaconed offset") +
    ylab("Probe offset") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3", "grey")) +
    theme(axis.text.x = element_text(size=17),
          axis.text.y = element_text(size=17),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
 ggsave(file = "plots/offset_comparison.png", width = 4, height = 4) 
}
```

Calculate r2 and p value for liner correlation of the above data
```{r}
pi_data_for_offset_regression <- spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>% 
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(track_category == "pospos" | track_category == "negneg") %>% 
  select(predict_diff, predict_diff_p)

model <- lm(predict_diff ~ predict_diff_p, data = pi_data_for_offset_regression)
summary(model)
# get the model parameters
params_offset <- select(glance(model), r.squared, p.value)
```

### -------------------------------------------------------------------------------------------------------------------------------------------------- ###


## Plot average firing rates for each cue_group of neuron

Now we want to plot population rate across whole track for diff groups so we can visualise the average firing rate

cue_groups are as follows :

outbound homebound  reset
    +       +         n
    +       +         y
    +       -         -
    +      non        -
    -       +         -
    -       -         n
    -       -         y
    -      non        -





# go into dataframe and from each average_rates column : just path integration neurons
```{r}
extract_cols_for_plot <- function(df){
 df <- tibble(Position = rep(1:200, times=nrow(df)), 
             Rates = unlist(df$Rates_averaged_rewarded_p),
             Rates_c = unlist(df$Rates_averaged_rewarded_b),
             Outbound_beaconed_b = rep(df$lm_group_b, each=200), 
             Homebound_beaconed_b = rep(df$lm_group_b_h, each=200), 
             Outbound_beaconed_p = rep(df$lm_group_p, each=200), 
             Homebound_beaconed_p = rep(df$lm_group_p_h, each=200), 
             cue_group_o = rep(df$cue_group_o, each=200), 
             reset_group = rep(as.character(df$reset_group), each=200), 
             reset_group_p = rep(as.character(df$reset_group_p), each=200)) 
}

```


Use the pipe to subset data:
1. Cue-independent neurons
2. Position neurons
3. Extra columns of interest
4. -/- neurons
5. Continous firing
6. Group
7. Plot

Function to add extra trace in Rates_c to a mean_SEM_plot.
```{r}
mean_SEM_plots_comp <- function(df, colour1 = "blue", colour2 = "black"){
  plot <- mean_SEM_plots(df, colour1)
  
  plot +
    geom_ribbon(aes(x=Position, y=mean_c, ymin = mean_c - sem_c, ymax = mean_c + sem_c), fill = colour2, alpha=0.2) +
    geom_line(aes(y=mean_c, x=Position), color = colour2) 
}
```



```{r}
# -/- on probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_p == "Negative" & Homebound_beaconed_p == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/Negneg_reset_probe_JustP.png", width = 3.5, height = 2.5)
}

# -/- on beaconed and probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Negative" & Homebound_beaconed_b == "Negative") %>%
  filter(Outbound_beaconed_p == "Negative" & Homebound_beaconed_p == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()


if (save_figures == 1) {
  ggsave(file = "plots/Negneg_reset_probe_BandP.png", width = 3.5, height = 2.5)
}

# -/- on beaconed and probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Negative" & Homebound_beaconed_b == "Negative") %>%
  filter(Outbound_beaconed_p == "Negative" & Homebound_beaconed_p == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()


if (save_figures == 1) {
  ggsave(file = "plots/Negneg_all_probe_BandP.png", width = 3.5, height = 2.5)
}


# -/- on beaconed but not probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Negative" & Homebound_beaconed_b == "Negative") %>%
  filter(Outbound_beaconed_p != "Negative" | Homebound_beaconed_p != "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()



if (save_figures == 1) {
  ggsave(file = "plots/Negneg_reset_probe_JustB.png", width = 3.5, height = 2.5)
}


```




```{r}
# -/+ on probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_p == "Negative" & Homebound_beaconed_p == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/NegPos_reset_probe_JustP.png", width = 3.5, height = 2.5)
}

# -/+ on beaconed and probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Negative" & Homebound_beaconed_b == "Positive") %>%
  filter(Outbound_beaconed_p == "Negative" & Homebound_beaconed_p == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()


if (save_figures == 1) {
  ggsave(file = "plots/Negpos_reset_probe_BandP.png", width = 3.5, height = 2.5)
}


# -/+ on beaconed but not probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Negative" & Homebound_beaconed_b == "Positive") %>%
  filter(Outbound_beaconed_p != "Negative" | Homebound_beaconed_p != "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/Negpos_reset_probe_JustB.png", width = 3.5, height = 2.5)
}
```





```{r}
# +/+ on probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_p == "Positive" & Homebound_beaconed_p == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/Pospos_reset_probe_JustP.png", width = 3.5, height = 2.5) 
}

#+/+ on beaconed and probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Positive" & Homebound_beaconed_b == "Positive") %>%
  filter(Outbound_beaconed_p == "Positive" & Homebound_beaconed_p == "Positive") %>%
  filter(reset_group == "Reset") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()


if (save_figures == 1) {
  ggsave(file = "plots/Pospos_reset_probe_BandP.png", width = 3.5, height = 2.5) 
}

#+/+ on beaconed and probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Positive" & Homebound_beaconed_b == "Positive") %>%
  filter(Outbound_beaconed_p == "Positive" & Homebound_beaconed_p == "Positive") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()


if (save_figures == 1) {
  ggsave(file = "plots/Pospos_all_probe_BandP.png", width = 3.5, height = 2.5) 
}
```



```{r}
# +/- on probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_p == "Positive" & Homebound_beaconed_p == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/Posneg_reset_probe_JustP.png", width = 3.5, height = 2.5)
}

# +/- on beaconed and probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Positive" & Homebound_beaconed_b == "Negative") %>%
  filter(Outbound_beaconed_p == "Positive" & Homebound_beaconed_p == "Negative") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()


if (save_figures == 1) {
  ggsave(file = "plots/Posneg_reset_probe_BandP.png", width = 3.5, height = 2.5)
}
```


```{r}
# +/UC on probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_p == "Positive" & Homebound_beaconed_p == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/posnon_reset_probe_JustB.png", width = 3.5, height = 2.5)
}
```



```{r}
# -/UC on probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_p == "Negative" & Homebound_beaconed_p == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()

if (save_figures == 1) {
  ggsave(file = "plots/negnon_reset_probe_JustP.png", width = 3.5, height = 2.5)
}
```
```{r}
# -/- on beaconed but not probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Negative" & Homebound_beaconed_b == "Negative") %>%
  filter(Outbound_beaconed_p == "Negative" | Homebound_beaconed_p == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()



if (save_figures == 1) {
  ggsave(file = "plots/Negneg_reset_probe_negUNonProbe.png", width = 3.5, height = 2.5)
}

# -/- on beaconed but not probe trials
spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA") %>%
  extract_cols_for_plot() %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(Outbound_beaconed_b == "Positive" & Homebound_beaconed_b == "Positive") %>%
  filter(Outbound_beaconed_p == "Positive" | Homebound_beaconed_p == "Unclassified") %>%
  group_by(Position) %>%
  dplyr::summarise(mean_r = mean(Rates, na.rm = TRUE),
                   sem_r = std.error(Rates, na.rm = TRUE),
                   mean_c = mean(Rates_c, na.rm = TRUE),
                   sem_c = std.error(Rates_c, na.rm = TRUE)) %>%
  mutate(Position = rep(-30:169)) %>%
  mean_SEM_plots_comp()



if (save_figures == 1) {
  ggsave(file = "plots/Pospos_reset_probe_negUNonProbe.png", width = 3.5, height = 2.5)
}

```


### ------------------------------------------------------------------------------------------------------------------- ###

We want to know about whether the slope classification of neurons on beaconed trials is maintained on probe trials.

We first ask this question for all neurons whose classification is independent of the reward zone cue.

1. Split by path integrating neurons (Figure 4)
```{r}
pi_data <- subset(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

2. subset based on position encoding neurons (Figure 3)
```{r}
pi_data <-subset(pi_data, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

The groups we want to consider are +/+(O), +/+(C), +/-, -/-(O), -/-(C) and -/+. In addition for probe trials there will be a group 'other' for activity that is no longer in one of these categories.

3. Split by linear model result (figure 2) in outbound and homebound region for beaconed trials
```{r}
pospos <-subset(pi_data, track_category == "pospos")
posneg <-subset(pi_data,track_category == "posneg")
negpos <-subset(pi_data, track_category == "negpos")
negneg <-subset(pi_data, track_category == "negneg")
posnon <-subset(pi_data, track_category == "posnon")
negnon <-subset(pi_data, track_category == "negnon")

```

3. Split by linear model result (figure 5) in outbound and homebound region for beaconed trials
```{r}
# Beaconed: pospos
# stays the same
pospos_pospos <-nrow(subset(pospos, track_category_p == "pospos"))

# homebound changes
pospos_posneg <-nrow(subset(pospos, track_category_p == "posneg"))
pospos_posnon <-nrow(subset(pospos, track_category_p == "posnon"))

# outbound changes
pospos_negpos <-nrow(subset(pospos, track_category_p == "negpos"))
pospos_negnon <-nrow(subset(pospos, track_category_p == "negnon"))
pospos_negneg <-nrow(subset(pospos, track_category_p == "negneg"))


# Beaconed: posneg
posneg_posneg <-nrow(subset(posneg, track_category_p == "posneg"))

posneg_posnon <-nrow(subset(posneg, track_category_p == "posnon"))
posneg_pospos <-nrow(subset(posneg, track_category_p == "pospos"))

posneg_negpos <-nrow(subset(posneg, track_category_p == "negpos"))
posneg_negnon <-nrow(subset(posneg, track_category_p == "negnon"))
posneg_negneg <-nrow(subset(posneg, track_category_p == "negneg"))


# Beaconed: negneg
# stays the same
negneg_negneg <-nrow(subset(negneg, track_category_p == "negneg"))

# homebound changes
negneg_negpos <-nrow(subset(negneg, track_category_p == "negpos"))
negneg_negnon <-nrow(subset(negneg, track_category_p == "negnon"))

# outbound changes
negneg_posneg <-nrow(subset(negneg, track_category_p == "posneg"))
negneg_posnon <-nrow(subset(negneg,track_category_p == "posnon"))
negneg_pospos <-nrow(subset(negneg, track_category_p == "pospos"))


# Beaconed: negpos
# stays the same
negpos_negpos <-nrow(subset(negpos, track_category_p == "negpos"))

# homebound changes
negpos_negnon <-nrow(subset(negpos, track_category_p == "negnon"))
negpos_negneg <-nrow(subset(negpos, track_category_p == "negneg"))

# Outbound changes
negpos_posneg <-nrow(subset(negpos, track_category_p == "posneg"))
negpos_posnon <-nrow(subset(negpos, track_category_p == "posnon"))
negpos_pospos <-nrow(subset(negpos, track_category_p == "pospos"))


# Beaconed: posnon
posnon_posneg <-nrow(subset(posnon, track_category_p == "posneg"))

posnon_posnon <-nrow(subset(posnon, track_category_p == "posnon"))
posnon_pospos <-nrow(subset(posnon, track_category_p == "pospos"))

posnon_negpos <-nrow(subset(posnon, track_category_p == "negpos"))
posnon_negnon <-nrow(subset(posnon, track_category_p == "negnon"))
posnon_negneg <-nrow(subset(posnon, track_category_p == "negneg"))

# Beaconed: negnon
# stays the same
negnon_negpos <-nrow(subset(negnon, track_category_p == "negpos"))

# homebound changes
negnon_negnon <-nrow(subset(negnon, track_category_p == "negnon"))
negnon_negneg <-nrow(subset(negnon, track_category_p == "negneg" ))

# Outbound changes
negnon_posneg <-nrow(subset(negnon, track_category_p == "posneg"))
negnon_posnon <-nrow(subset(negnon, track_category_p == "posnon"))
negnon_pospos <-nrow(subset(negnon, track_category_p == "pospos"))

```



```{r}

data_long <-
  tibble(
    value = c(
    
      posneg_pospos,
      posneg_posneg,
      posneg_negpos,
      posneg_posnon,
      posneg_negnon,
      posneg_negneg,
      
      pospos_pospos,
      pospos_posneg,
      pospos_negpos,
      pospos_posnon,
      pospos_negnon,
      pospos_negneg,
      
      negpos_pospos,
      negpos_posneg,
      negpos_negpos,
      negpos_posnon,
      negpos_negnon,
      negpos_negneg,
      
      negneg_pospos,
      negneg_posneg,
      negneg_negpos,
      negneg_posnon,
      negneg_negnon,
      negneg_negneg
    ),
    
    source = c(
      "+ -",
      "+ -",
      "+ -",
      "+ -",
      "+ -",
      "+ -",
      "+ + R",
      "+ + R",
      "+ + R",
      "+ + R",
      "+ + R",
      "+ + R",
      "- +",
      "- +",
      "- +",
      "- +",
      "- +",
      "- +",
      "- - R",
      "- - R",
      "- - R",
      "- - R",
      "- - R",
      "- - R"
    ),
    
    target = c(
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -",
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -",
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -",
      " + +",
      " + -",
      " - +" ,
      " + non",
      " - non",
      " - -"
    )
  )


data_long <- data_long %>%
  filter(value > 0)                           
                    
```


```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)

if (save_figures == 1) {
  ggsave(file = "plots/model_movement.png", width = 24, height = 18)
}
```





### ------------------------------------------------------------------------------------------ ### 

## Calculate number of neurons that areset/switch/continuous across outbound and homebound


1. First, select cells that are position encoding (figure 3)
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Select cells that are path integrating i.e. have slopes on both the beaconed and non-beaconed (Figure 4)
```{r}
position_cells <- subset(position_cells, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

3. For this group of neurons, find numbers of cells that fit different patterns of outbound/homebound slope
```{r}

pospos <-subset(position_cells, track_category == "pospos")
negneg <-subset(position_cells, track_category == "negneg")

posneg <-subset(position_cells, track_category == "posneg")
negpos <-subset(position_cells, track_category == "negpos")

posnon <-subset(position_cells, track_category == "posnon")
negnon <-subset(position_cells, track_category == "negnon")

```

```{r}
total_cells <- (nrow(pospos) + nrow(negneg))
```

5. for +- and -+ groups as classified on beaconed trials, how many are the same on probe?
```{r}
posneg_same_probe <-subset(posneg, track_category_p == "posneg")
negpos_same_probe <-subset(negpos, track_category_p == "negpos")

negneg_same_probe <-subset(negneg, track_category_p == "negneg")
pospos_same_probe <-subset(pospos, track_category_p == "pospos")

posnon_same_probe <-subset(posnon, track_category_p == "posnon")
negnon_same_probe <-subset(negnon, track_category_p == "negnon")

```

```{r}
total_cells_same_on_probe <- (nrow(pospos_same_probe) + nrow(negneg_same_probe))
```

6. for +- and -+ groups as classified on beaconed trials, how many unclassified on probe?
```{r}
posneg_un_probe <-subset(posneg, lm_group_p == "Positive" & lm_group_p_h == "Unclassified" | lm_group_p_h == "NA")
negpos_un_probe <-subset(negpos, lm_group_p == "Negative" & lm_group_p_h == "Unclassified" | lm_group_p_h == "NA")

```

7. 
```{r}
pospos_r <-subset(position_cells, track_category == "pospos" & reset_group == "Reset")
pospos_c <-subset(position_cells, track_category == "pospos" & reset_group == "Continuous")
negneg_r <-subset(position_cells, track_category == "negneg" & reset_group == "Reset")
negneg_c <-subset(position_cells, track_category == "negneg" & reset_group == "Continuous")

```

```{r}
pospos_r_same <-subset(pospos_r, track_category_p == "pospos")
negneg_r_same <-subset(negneg_r, track_category_p == "negneg")

```

```{r}
pospos_r_switch <-subset(pospos_r, track_category_p == "pospos" & reset_group_p == "Continuous")
negneg_r_switch <-subset(negneg_r, track_category_p == "negneg" & reset_group_p == "Continuous")

pospos_r_same <-subset(pospos_r, track_category_p == "posnon")
negneg_r_same <-subset(negneg_r, track_category_p == "negnon")

```

4. calculate number of neurons that switch slope, stay the same or are reset/continuous
```{r}
switch_slope <- nrow(posneg) + nrow(negpos)
only_outbound_slope <- nrow(posnon) + nrow(negnon)
same_slope <- nrow(pospos) + nrow(negneg)
same_slope_reset <- nrow(pospos_r) + nrow(negneg_r)
same_slope_continuous <- nrow(pospos_c) + nrow(negneg_c)

```


