---
title: "CueAnalysis"
author: "Sarah Tennant"
date: "02/02/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### -------------------------------------------------------------------------------------------------------- ###


## Script runs analysis that compares cued (beaconed) trials to uncued (non-beaconed/probe) (Figure 4)

_note : focuses on activity in outbound region_

### -------------------------------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons has the following pattern ramp activity :

1. both cued and uncued (PI)
2. just cued (cue)
3. just uncued (onlypi)

To classify cells into these catagories above, we will use the criteria established in Figure 2 using linear modelling. 

1. make function to classify cells based on activity in beaconed / non-beaconed&probe trials 
```{r}
mark_neurons <- function(beac, probe){
  if (is.na(beac) | is.na(probe) ) {
    return( "None" )
  } else if( beac == "Positive" & probe == "Positive") {
    return( "Positive-PI" )
  } else if( beac == "Negative" & probe == "Negative") {
    return( "Negative-PI" )
  } else if( beac == "Positive" & probe == "Unclassified") {
    return( "Positive-cue" )
  } else if( beac == "Negative" & probe == "Unclassified") {
    return( "Negative-cue" )
  } else if( beac == "Unclassified" & probe == "Positive") {
    return( "Positive-onlypi" )
  } else if( beac == "Unclassified" & probe == "Negative") {
    return( "Negative-onlypi" )
    } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(group = map2(slope_criteria_pval, slope_criteria_pval_nb, mark_neurons))

```


### -------------------------------------------------------------------------------------------------------- ###


Now I want to visualise the proportion of cells that fit these above criteria. I'm going to do this by plotting a pie chart. 

1. subset neurons by group _just looking at cue dependant or independant for now_
```{r}
ramps <-subset(spatial_firing, slope_criteria_pval == "Positive" | group == "Negative")

# positive homebound slopes
pi <-nrow(subset(ramps, group == "Positive-PI" | group == "Negative-PI"))/nrow(ramps)*100
cue <-nrow(subset(ramps, group == "Positive-cue" | group == "Negative-cue"))/nrow(ramps)*100
pionly <-nrow(subset(spatial_firing, group == "Positive-onlypi" | group == "Negative-onlypi"))/nrow(spatial_firing)*100
none <-nrow(subset(spatial_firing, group == "None" | group == "None"))/nrow(spatial_firing)*100

# positive homebound slopes
pi_num <-nrow(subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI"))
cue_num <-nrow(subset(spatial_firing, group == "Positive-cue" | group == "Negative-cue"))
pionly_num <-nrow(subset(spatial_firing, group == "Positive-onlypi" | group == "Negative-onlypi"))
none_num <-nrow(subset(spatial_firing, group == "None" | group == "None"))

```

2. Put results into tibble
```{r}

proportions_mixed_ramps <- tibble(perc=c(pi, cue, pionly, none), num=c(pi_num, cue_num, pionly_num, none_num), ramp_id= c("Cue-independant", "Cue-dependant", "Path-Integration-only", "None"),ramp_type = c("Cue-independant", "Cue-dependant", "Path-Integration-only", "None"))

```

3. Plot a pie chart of results, 
_note : pie segments represent the proportions with real values in text_
```{r}

# Create Data
data <- data.frame(
  group=LETTERS[1:4],
  value=c(pi,cue,pionly,none)
)

# Compute the position of labels
data <- proportions_mixed_ramps %>% 
  arrange(desc(ramp_id)) %>%
  mutate(prop = perc) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
ggplot(data, aes(x="", y=prop, fill=ramp_id)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  #theme(legend.position="none") +
  
  geom_text(aes(y = ypos, label = num), color = "white", size=3) +
  scale_fill_brewer(palette="Set1")

ggsave(file = "plots/CueComparison_proportions.png", width = 4, height = 4)

```

4. Also just a quick look at the numbers - how many positive and negative of each (cue/PI)
```{r}
ramps <- subset(spatial_firing, slope_criteria_pval == "Positive" | slope_criteria_pval_nb == "Negative")

pi_neg <-nrow(subset(ramps, group == "Negative-PI"))/nrow(ramps)*100
cue_neg <-nrow(subset(ramps, group == "Negative-cue"))/nrow(ramps)*100
pi_pos <-nrow(subset(ramps, group == "Positive-PI"))/nrow(ramps)*100
cue_pos <-nrow(subset(ramps, group == "Positive-cue"))/nrow(ramps)*100

```



### -------------------------------------------------------------------------------------------------------- ###

We also want to see the movement of neurons from cue to uncued trials, do this using a Sankey plot
_note : we focus only on cue independant / path integrating neurons here_


1. Subset based on cue dependancy
```{r}
# positive homebound slopes
pi <-subset(spatial_firing, group == "Positive-PI" | group == "Negative-PI")
cue <-subset(spatial_firing, group == "Positive-cue" | group == "Negative-cue")
pionly <-subset(spatial_firing, group == "Positive-onlypi" | group == "Negative-onlypi")

pi_neg <-subset(spatial_firing, group == "Negative-PI")
cue_neg <-subset(spatial_firing,  group == "Negative-cue")
pi_pos <-subset(spatial_firing, group == "Positive-PI" )
cue_pos <-subset(spatial_firing, group == "Positive-cue" )

```

2. Subset based on non-beaconed activity
```{r}

pi_positive <-subset(spatial_firing, slope_criteria_pval == "Positive")
pi_negative <-subset(spatial_firing, slope_criteria_pval == "Negative")
pi_none <-subset(spatial_firing, slope_criteria_pval == "None")

pi_positive_pos <-nrow(subset(pi_positive, slope_criteria_pval_nb == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, slope_criteria_pval_nb == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, slope_criteria_pval_nb == "None"))
pi_negative_pos <-nrow(subset(pi_negative, slope_criteria_pval_nb == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, slope_criteria_pval_nb == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, slope_criteria_pval_nb == "None"))
pi_none_pos <-nrow(subset(pi_none, slope_criteria_pval_nb == "Positive"))
pi_none_neg <-nrow(subset(pi_none, slope_criteria_pval_nb == "Negative"))
pi_none_none <-nrow(subset(pi_none, slope_criteria_pval_nb == "None"))

```

```{r}

data_long <- tibble(value=c(pi_positive_pos, pi_positive_neg, pi_positive_none, pi_negative_pos,pi_negative_neg, pi_negative_none, pi_none_pos, pi_none_neg, pi_none_none), 
                    
                      source= c("Positive","Positive", "Positive", "Negative", "Negative", "Negative", "None","None", "None"),
                     target= c(" Positive"," Negative", " None"," Positive"," Negative", " None"," Positive"," Negative", " None"))


data_long <- data_long %>% 
  filter(value > 0)                           
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=0, nodePadding=30)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```


_ numbers for sankey above_
```{r}
pi_positive <-subset(spatial_firing, slope_criteria_pval == "Positive")
pi_negative <-subset(spatial_firing, slope_criteria_pval == "Negative")
pi_none <-subset(spatial_firing, slope_criteria_pval == "None")

pi_positive_pos <-nrow(subset(pi_positive, slope_criteria_pval_nb == "Positive"))
pi_positive_neg <-nrow(subset(pi_positive, slope_criteria_pval_nb == "Negative"))
pi_positive_none <-nrow(subset(pi_positive, slope_criteria_pval_nb == "None" ))
pi_negative_pos <-nrow(subset(pi_negative, slope_criteria_pval_nb == "Positive"))
pi_negative_neg <-nrow(subset(pi_negative, slope_criteria_pval_nb == "Negative"))
pi_negative_none <-nrow(subset(pi_negative, slope_criteria_pval_nb == "None"))
pi_none_pos <-nrow(subset(pi_none, slope_criteria_pval_nb == "Positive"))
pi_none_neg <-nrow(subset(pi_none, slope_criteria_pval_nb == "Negative"))
pi_none_none <-nrow(subset(pi_none, slope_criteria_pval_nb == "None"))

```





### -------------------------------------------------------------------------------------------------------- ###


Now i want to visualise the average firing rate for each of the groups

### Plot average firing rate for groups


First we need to scale firing rates

1. Scale firing rate for beaconed trials

```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates)
  return(x)
}
```

2. Scale firing rate for non-beaconed/probe trials
_note: scale based on beaconed trials_
```{r}
normalise_nb_rates <- function(df, df2){
  df <- tibble(Rates = c(unlist(df2), unlist(df)), Position = rep(1:200, times=2), Types= rep(c("Beaconed", "Non-beaconed"), each=200))
  x <- scale(df$Rates)
  return(x[0:200])
}

spatial_firing <- spatial_firing %>%
  mutate(normalised_rates = map(Rates_averaged_rewarded_b, normalise_rates))  %>%
  mutate(normalised_rates_nb = map2(Rates_averaged_rewarded_b, Rates_averaged_rewarded_nb, normalise_nb_rates))
  #mutate(normalised_rates_p = map(Rates_averaged_p, normalise_rates)) 
```


# go into dataframe and from each average_rates column,
```{r}
df <- tibble(Position = rep(1:200, times=nrow(spatial_firing)), Rates = unlist(spatial_firing$Rates_averaged),Rates_nb = unlist(spatial_firing$Rates_averaged_p), norm_rates = unlist(spatial_firing$normalised_rates), norm_rates_nb = unlist(spatial_firing$normalised_rates_nb), Outbound_beaconed = rep(spatial_firing$lm_result_o_rewarded, each=200), Outbound_nonbeaconed = rep(spatial_firing$lm_result_o_rewarded_p, each=200), group = rep(as.character(spatial_firing$group), each=200))

```

3. Extract all data into tibble 
```{r}
df <- tibble(Position = rep(1:200, times=nrow(spatial_firing)), Rates = unlist(spatial_firing$Rates_averaged_rewarded_b),Rates_nb = unlist(spatial_firing$Rates_averaged_rewarded_nb), norm_rates = unlist(spatial_firing$normalised_rates), norm_rates_nb = unlist(spatial_firing$normalised_rates_nb), Outbound_beaconed = rep(spatial_firing$slope_criteria_pval, each=200), Outbound_nonbeaconed = rep(spatial_firing$slope_criteria_pval_nb, each=200), group = rep(as.character(spatial_firing$group), each=200))

```

4. Subset data by group then average rates for plotting          **Negative Cue**
```{r}
df_neg_cue <- df %>%
  subset(Outbound_beaconed == "Negative" & Outbound_nonbeaconed == "None") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates
```{r}
ggplot(data=df_neg_cue) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_negative_cue_cells_outbound_raw3.png", width = 3.5, height = 2.5)

```


4. Subset data by group then average rates for plotting          **Positive Cue**

```{r}
df_pos_cue <- df %>%
  subset(Outbound_beaconed == "Positive" & Outbound_nonbeaconed == "None") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  #summarise(mean = mean(Rates)) %>%
  #summarise(position = median(Position))
  
```

5. Plot average rates

```{r}
ggplot(data=df_pos_cue) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_positive_cue_cells_outbound_raw3.png", width = 3.5, height = 2.5)


```




4. Subset data by group then average rates for plotting          **Positive PI**

```{r}
df_pos_pi <- df %>%
  subset(Outbound_beaconed == "Positive" & Outbound_nonbeaconed == "Positive") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))

```

5. Plot average rates

```{r}
ggplot(data=df_pos_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_positive_pi_cells_outbound_raw3.png", width = 3.5, height = 2.5)


```




4. Subset data by group then average rates for plotting          **Negative PI**

```{r}
df_neg_pi <- df %>%
  subset(Outbound_beaconed == "Negative" & Outbound_nonbeaconed == "Negative") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates

```{r}
ggplot(data=df_neg_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic()  +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_negative_pi_cells_outbound_raw3.png",width = 3.5, height = 2.5)


```


4. Subset data by group then average rates for plotting          **Negative PI only**

```{r}
df_neg_pi <- df %>%
  subset(Outbound_beaconed == "None" & Outbound_nonbeaconed == "Negative") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates

```{r}
ggplot(data=df_neg_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic()  +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_negative_pionly_cells_outbound_raw.png",width = 3.5, height = 2.5)


```




4. Subset data by group then average rates for plotting          **Positive PI only**

```{r}
df_neg_pi <- df %>%
  subset(Outbound_beaconed == "None" & Outbound_nonbeaconed == "Positive") %>%
  group_by(Position) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  mutate(Position = rep(0:60))
  
```

5. Plot average rates

```{r}
ggplot(data=df_neg_pi) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_nb, ymin = mean_nb - sd_nb, ymax = mean_nb + sd_nb), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_nb, x=Position), color = "Red2") +
  theme_classic()  +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_positive_pionly_cells_outbound_raw.png",width = 3.5, height = 2.5)


```



### ---------------------------------------------------------------------------------------- ### 


Now, i want to visualise cue dependant and indpedant on the same plot so i can compare them

1. Subset data by group then average rates for plotting          **Negative slopes only**

```{r}

df_neg <- df %>%
  group_by(Position, group) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale_b = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale_b = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  subset(group != "None" & group == "Negative-cue" | group == "Negative-PI") #%>%
  #mutate(Position = rep(0:60))
  
```

2. Plot data 
```{r}
ggplot(data=df_neg) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b, fill=group), alpha=0.2) +
  geom_line(aes(y=mean_b, x=Position, color=group)) +
  theme_classic() +
  scale_color_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  scale_fill_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_cells_negative_outbound_raw.png", width = 6, height = 3)


```


3. Subset data by group then average rates for plotting          **Positive slopes only**


```{r}

df_pos <- df %>%
  group_by(Position, group) %>%
  subset(Position >= 30 & Position <= 90) %>%
  summarise(mean_b = mean(Rates,na.rm = TRUE), mean_nb = mean(Rates_nb,na.rm = TRUE), sd_b = std.error(Rates, na.rm = TRUE), sd_nb = std.error(Rates_nb, na.rm = TRUE), mean_scale_b = mean(norm_rates, na.rm = TRUE), mean_scale_nb = mean(norm_rates_nb, na.rm = TRUE), sd_scale_b = std.error(norm_rates, na.rm = TRUE), sd_scale_nb = std.error(norm_rates_nb, na.rm = TRUE)) %>%
  subset(group != "None" & group == "Positive-cue" | group == "Positive-PI")
  #mutate(Position = rep(0:60))
  
```


```{r}
ggplot(data=df_pos) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - sd_b, ymax = mean_b + sd_b, fill=group), alpha=0.2) +
  geom_line(aes(y=mean_b, x=Position, color=group)) +
  theme_classic() +
  scale_color_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  scale_fill_manual(values=c("deeppink1", "steelblue3", "chartreuse3")) +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
ggsave(file = "plots/overlaid_cells_positive_outbound_raw.png", width = 6, height = 3)

```





### -------------------------------------------------------------------------------------------------------- ###



### import ramp score and correlate with... 

```{r}
concat_firing_start <- as_tibble(select(na.omit(start_ramps), new_cluster_id, ramp_score))

```

```{r}
ggplot(data = concat_firing_start, aes(x = 0.2,y=new_cluster_id)) +
  geom_tile(aes(fill = as.numeric(ramp_score)))
ggsave(file = "plots/stack_ramp_score_negative.png", width = 3, height = 5)

```


```{r}
concat_firing_start <- as_tibble(select(na.omit(start_ramps), new_cluster_id, ramp_score))

```

```{r}
ggplot(data = concat_firing_start, aes(x = 0.2,y=new_cluster_id)) +
  geom_tile(aes(fill = as.numeric(ramp_score)))
ggsave(file = "plots/stack_ramp_score_positive.png", width = 3, height = 5)

```





### -------------------------------------------------------------------------------------------------------- ###


### Kinamatic scores according to group

###

```{r}

# extracting diff models 

cueindepedant <-subset(spatial_firing, group == "Positive-PI" | group == "Positive-PI")
cuedepedant <-subset(spatial_firing, group == "Negative-cue" | group == "Positive-cue")


```


```{r}

P_cue <- nrow(subset(cuedepedant, final_model_o_b == "P"))/nrow(cuedepedant)*100
P_pi <- nrow(subset(cueindepedant,final_model_o_b == "P"))/nrow(cueindepedant)*100

S_cue <- nrow(subset(cuedepedant,final_model_o_b == "S"))/nrow(cuedepedant)*100
S_pi <- nrow(subset(cueindepedant,final_model_o_b == "S"))/nrow(cueindepedant)*100

A_cue <- nrow(subset(cuedepedant,final_model_o_b == "A"))/nrow(cuedepedant)*100
A_pi <- nrow(subset(cueindepedant,final_model_o_b == "A"))/nrow(cueindepedant)*100

P_S_cue <- nrow(subset(cuedepedant,final_model_o_b == "PS"))/nrow(cuedepedant)*100
P_S_pi <- nrow(subset(cueindepedant,final_model_o_b == "PS"))/nrow(cueindepedant)*100

P_A_cue <- nrow(subset(cuedepedant ,final_model_o_b == "PA"))/nrow(cuedepedant)*100
P_A_pi <- nrow(subset(cueindepedant,final_model_o_b == "PA"))/nrow(cueindepedant)*100

S_A_cue <- nrow(subset(cuedepedant ,final_model_o_b == "SA"))/nrow(cuedepedant)*100
S_A_pi <- nrow(subset(cueindepedant,final_model_o_b == "SA"))/nrow(cueindepedant)*100

P_S_A_cue <- nrow(subset(cuedepedant ,final_model_o_b == "PSA"))/nrow(cuedepedant)*100
P_S_A_pi <- nrow(subset(cueindepedant ,final_model_o_b == "PSA"))/nrow(cueindepedant)*100

None_cue <- nrow(subset(cuedepedant ,final_model_o_b == "None"))/nrow(cuedepedant)*100
None_pi <- nrow(subset(cueindepedant ,final_model_o_b == "None"))/nrow(cueindepedant)*100



```



```{r}
mixed_ramps <- tibble(perc=c(P_cue,P_pi,S_cue,S_pi, A_cue,A_pi,P_S_cue,P_S_pi, P_A_cue,P_A_pi,S_A_cue,S_A_pi, P_S_A_cue,P_S_A_pi, None_cue, None_pi), 
                      
                      ramp_id= c("P","P",
                                 "S", "S",
                                 "A", "A",
                                 "PS", "PS",
                                 "PA", "PA",
                                 "SA", "SA",
                                 "PAS", "PAS",
                                 "None", "None"), 
                      ramp_type= c("Cue", "PI", "Cue", "PI", "Cue", "PI", "Cue", "PI", "Cue", "PI", "Cue", "PI", "Cue", "PI", "Cue", "PI"))


```


7. Plot model results

```{r}
# plot data
level_order <- c("P", "S", "A", "PS", "PA", "SA", "PAS", "None")
ggplot(mixed_ramps, aes(x= factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons identified using LM") +
  scale_fill_manual(values=c("deeppink1","indianred3", "steelblue3", "darkred", "orchid", "lightseagreen", "darkgreen", "grey32")) +

  #scale_fill_brewer(palette= "RdYlBu") +
  theme_classic() +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/cell_proportions-slope_groups_fig4.png", width = 4, height = 4.5)


```





```{r}
# positive homebound slopes
P <-subset(neg_cue, final_model_o_b == "P")
S <-subset(neg_cue, final_model_o_b == "S")
PS <-subset(neg_cue, final_model_o_b == "PS")
PSA <-subset(neg_cue, final_model_o_b == "PSA")
A <-subset(neg_cue, final_model_o_b == "A")
PA <-subset(neg_cue, final_model_o_b == "PA")
None <-subset(neg_cue, final_model_o_b == "None")

```

```{r}

pos_s <-nrow(subset(P, final_model_o_nb == "S"))
pos_p <-nrow(subset(P, final_model_o_nb == "P"))
pos_pa <-nrow(subset(P, final_model_o_nb == "PA"))
pos_ps <-nrow(subset(P, final_model_o_nb == "PS"))
pos_pas <-nrow(subset(P, final_model_o_nb == "PSA"))
pos_a <-nrow(subset(P, final_model_o_nb == "A"))
pos_none <-nrow(subset(P, final_model_o_nb == "None"))

speed_s <-nrow(subset(S, final_model_o_nb == "S"))
speed_p <-nrow(subset(S, final_model_o_nb == "P"))
speed_pa <-nrow(subset(S, final_model_o_nb == "PA"))
speed_ps <-nrow(subset(S, final_model_o_nb == "PS"))
speed_pas <-nrow(subset(S, final_model_o_nb == "PSA"))
speed_a <-nrow(subset(S, final_model_o_nb == "A"))
speed_none <-nrow(subset(S, final_model_o_nb == "None"))

pos_speed_s <-nrow(subset(PS, final_model_o_nb == "S"))
pos_speed_p <-nrow(subset(PS, final_model_o_nb == "P"))
pos_speed_pa <-nrow(subset(PS, final_model_o_nb == "PA"))
pos_speed_ps <-nrow(subset(PS, final_model_o_nb == "PS"))
pos_speed_pas <-nrow(subset(PS, final_model_o_nb == "PSA"))
pos_speed_a <-nrow(subset(PS, final_model_o_nb == "A"))
pos_speed_none <-nrow(subset(PS, final_model_o_nb == "None"))

pos_int_s <-nrow(subset(PA, final_model_o_nb == "S"))
pos_int_p <-nrow(subset(PA, final_model_o_nb == "P"))
pos_int_pa <-nrow(subset(PA, final_model_o_nb == "PA"))
pos_int_ps <-nrow(subset(PA, final_model_o_nb == "PS"))
pos_int_pas <-nrow(subset(PA, final_model_o_nb == "PSA"))
pos_int_a <-nrow(subset(PA, final_model_o_nb == "A"))
pos_int_none <-nrow(subset(PA, final_model_o_nb == "None"))

pos_speed_int_s <-nrow(subset(PSA, final_model_o_nb == "S"))
pos_speed_int_p <-nrow(subset(PSA, final_model_o_nb == "P"))
pos_speed_int_pa <-nrow(subset(PSA, final_model_o_nb == "PA"))
pos_speed_int_ps <-nrow(subset(PSA, final_model_o_nb == "PS"))
pos_speed_int_pas <-nrow(subset(PSA, final_model_o_nb == "PSA"))
pos_speed_int_a <-nrow(subset(PSA, final_model_o_nb == "A"))
pos_speed_int_none <-nrow(subset(PSA, final_model_o_nb == "None"))

int_s <-nrow(subset(A, final_model_o_nb == "S"))
int_p <-nrow(subset(A, final_model_o_nb == "P"))
int_pa <-nrow(subset(A, final_model_o_nb == "PA"))
int_ps <-nrow(subset(A, final_model_o_nb == "PS"))
int_pas <-nrow(subset(A, final_model_o_nb == "PSA"))
int_a <-nrow(subset(A, final_model_o_nb == "A"))
int_none <-nrow(subset(A, final_model_o_nb == "None"))

none_s <-nrow(subset(None, final_model_o_nb == "S"))
none_p <-nrow(subset(None, final_model_o_nb == "P"))
none_pa <-nrow(subset(None, final_model_o_nb == "PA"))
none_ps <-nrow(subset(None, final_model_o_nb == "PS"))
none_pas <-nrow(subset(None, final_model_o_nb == "PSA"))
none_a <-nrow(subset(None, final_model_o_nb == "A"))
none_none <-nrow(subset(None, final_model_o_nb == "None"))
```

```{r}

data_long <- tibble(value=c(pos_s,pos_p,pos_ps, pos_pa, pos_pas, pos_a, pos_none, speed_s,speed_p,speed_ps, speed_pa, speed_pas, speed_a, speed_none,pos_speed_s, pos_speed_p,pos_speed_ps, pos_speed_pa, pos_speed_pas, pos_speed_a, pos_speed_none,pos_speed_int_s, pos_speed_int_p,pos_speed_int_ps, pos_speed_int_pa, pos_speed_int_pas, pos_speed_int_a, pos_speed_int_none, pos_int_s, pos_int_p,pos_int_ps, pos_int_pa, pos_int_pas, pos_int_a, pos_int_none, int_s, int_p,int_ps, int_ps, int_pas, int_a, int_none, none_s, none_p,int_ps, none_pa, none_pas, none_a, none_none), 
                    
                      source= c("P","P", "P", "P", "P", "P", "P","S", "S", "S", "S", "S", "S", "S", "PS", "PS", "PS", "PS", "PS", "PS", "PS", "PS", "PSA", "PSA", "PSA", "PSA", "PSA", "PSA","PA", "PA", "PA", "PA", "PA", "PA", "PA","A", "A", "A", "A", "A", "A", "A","none", "none", "none", "none", "none", "none", "none"),
                     target= c(" S"," P", " PS", " PA", " PSA", " A", " None"," S"," P", " PS", " PA", " PSA", " A", " None", " S"," P", " PS", " PA", " PSA", " A", " None"," S"," P", " PS", " PA", " PSA", " A", " None", " S"," P", " PS", " PA", " PSA", " A", " None", " S"," P", " PS", " PA", " PSA", " A", " None"," S"," P", " PS", " PA", " PSA", " A", " None"))


data_long <- data_long %>% 
  filter(value > 0)                    
                    
```

```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
```

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
```

```{r}
# prepare colour scale
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'

# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", LinkGroup='source',
              sinksRight=FALSE, colourScale=ColourScal,
              nodeWidth=40, fontSize=13, nodePadding=20)
#ggsave(file = "plots/model_movement.png", width = 24, height = 18)

```


















