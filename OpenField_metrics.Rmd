---
title: "OpenFieldMetrics"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### --------------------------------------------------------------------------------- ###


## Runs analysis that compares ramp scores to open field spatial scores. 

_note : Dataframe contains the open field metrics, the shuffled analysis cutoffs and the classsification of the cell based on those cut offs. Harry has used the same methods for labelling a cell a grid, hd, border, spatial cells the same as in this paper (https://www.sciencedirect.com/science/article/pii/S0896627317301873). The only difference is this dataset doesn't have the half session rate map comparison scores in the shuffled analysis so a spatial cell is only defined based on the spatial information score. _


### --------------------------------------------------------------------------------- ###


First, we are interested to see what proportion of neurons have the following patterns of activity in the open field:

1. Grid cells
2. Head direction
3. Border

To classify cells into these categories above, we will use the classification established in (https://www.sciencedirect.com/science/article/pii/S0896627317301873). 


1. Label neurons as border based on 95% cut off from the shuffled analysis
```{r}
label_border_identity <- function(score, shuff){
  print(as.numeric(unlist(shuff)))
  if (is.na(score) | is.na(shuff) ) {
    return( "None" )
  } else if( as.numeric(unlist(score)) > as.numeric(unlist(shuff))) {
    return( "1" )
  } else if( as.numeric(unlist(score)) <= as.numeric(unlist(shuff))) {
    return( "0" )
  } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(border_cell = map2(border_score, border_threshold, label_border_identity))

```


### ----------------------------------------------------------------------------------------- ###


1. Label neurons as grid based on 95% cut off from the shuffled analysis
```{r}
label_grid_identity <- function(score, shuff){
  if (is.na(score) | is.na(shuff) ) {
    return( "None" )
  } else if( as.numeric(unlist(score)) > as.numeric(unlist(shuff))) {
    return( "1" )
  } else if( as.numeric(unlist(score)) <= as.numeric(unlist(shuff))) {
    return( "0" )
  } else {
    return("None")
  }

}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(grid_cell = map2(grid_score, grid_threshold, label_grid_identity))

```

### ----------------------------------------------------------------------------------------- ###


1. Label neurons as grid based on 95% cut off from the shuffled analysis
```{r}
label_hd_identity <- function(score, shuff){
  if (is.na(score) | is.na(shuff) ) {
    return( "None" )
  } else if( as.numeric(unlist(score)) > as.numeric(unlist(shuff))) {
    return( "1" )
  } else if( as.numeric(unlist(score)) <= as.numeric(unlist(shuff))) {
    return( "0" )
  } else {
    return("None")
  }

}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(hd_cell = map2(hd_score, hd_threshold, label_hd_identity))

```

### ----------------------------------------------------------------------------------------- ###


1. Label neurons as grid based on 95% cut off from the shuffled analysis
```{r}
label_speed_identity <- function(score, shuff){
  if (is.na(score) | is.na(shuff) ) {
    return( "None" )
  } else if( as.numeric(unlist(score)) > as.numeric(unlist(shuff))) {
    return( "1" )
  } else if( as.numeric(unlist(score)) <= as.numeric(unlist(shuff))) {
    return( "0" )
  } else {
    return("None")
  }

}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(speed_cell = map2(speed_score, speed_threshold_pos, label_speed_identity))

```

### ----------------------------------------------------------------------------------------- ###


1. Label neurons as grid based on 95% cut off from the shuffled analysis
```{r}
label_rayleigh_identity <- function(score, shuff){
  if (is.na(score) | is.na(shuff) ) {
    return( "None" )
  } else if( as.numeric(unlist(score)) > as.numeric(unlist(shuff))) {
    return( "1" )
  } else if( as.numeric(unlist(score)) <= as.numeric(unlist(shuff))) {
    return( "0" )
  } else {
    return("None")
  }

}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(rayleigh_cell = map2(rayleigh_score, rayleigh_threshold, label_rayleigh_identity))

```



### ----------------------------------------------------------------------------------------- ###


1. Label neurons as grid based on 95% cut off from the shuffled analysis
```{r}
label_spatial_identity <- function(score, shuff){
  if (is.na(score) | is.na(shuff) ) {
    return( "None" )
  } else if( as.numeric(unlist(score)) > as.numeric(unlist(shuff))) {
    return( "1" )
  } else if( as.numeric(unlist(score)) <= as.numeric(unlist(shuff))) {
    return( "0" )
  } else {
    return("None")
  }

}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(spatial_cell = map2(spatial_information_score, spatial_threshold, label_spatial_identity))

```



### ----------------------------------------------------------------------------------------- ###


1. Label neurons as grid based on 95% cut off from the shuffled analysis
```{r}
classify_of_cell <- function(spatial_cell, grid_cell, border_cell, rayleigh_cell, speed_cell, hd_cell){
  if (is.na(spatial_cell) | is.na(grid_cell) ) {
    return( "None" )
  } else if( spatial_cell == 0 & speed_cell == 0) {
    return( "Non-spatial" )
  } else if( grid_cell == 1) {
    return( "Grid cell" )
  } else if( border_cell == 1) {
    return( "Border cell" )
  } else if( hd_cell == 1) {
    return( "HD cell" )
  } else if( speed_cell == 1) {
    return( "Speed cell" )
  } else if( rayleigh_cell == 1) {
    return( "Rayleigh cell" )
  } else if( spatial_cell == 1) {
    return( "Spatial cell" )
  } else {
    return("None")
  }

}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(of_classifier = pmap(list(spatial_cell, grid_cell, border_cell, rayleigh_cell, speed_cell, hd_cell), classify_of_cell))

```


### ----------------------------------------------------------------------------------------- ###



1. extract neurons that are ++ or -- on beaconed trials, position encoding (Figure 3) and driven by path integration (Figure 4)
```{r}
position_data <- spatial_firing %>%
  #filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")  #%>% 
  #filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA"| final_model_o_b == "PSA")
  #filter(final_model_o_b == "S" | final_model_o_b == "SA" | final_model_o_b == "A")
  filter(final_model_o_b == "S")
  
```

2. plot proportion of positive and negative ramps that are grid/non-grid

1. extract proportion of cells that meet each criteria
```{r}
start <- subset(position_data, lm_group_b == "Negative")
reward <- subset(position_data, lm_group_b == "Positive")
nonslope <- subset(position_data, lm_group_b == "Unclassified")
```


```{r}
start_grid <- nrow(subset(start, of_classifier == "Grid cell"))/nrow(start)*100
reward_grid <- nrow(subset(reward, of_classifier == "Grid cell"))/nrow(reward)*100
nonslope_grid <- nrow(subset(nonslope, of_classifier == "Grid cell"))/nrow(nonslope)*100

start_border <- nrow(subset(start, of_classifier == "Border cell"))/nrow(start)*100
reward_border <- nrow(subset(reward, of_classifier == "Border cell"))/nrow(reward)*100
nonslope_border <- nrow(subset(nonslope, of_classifier == "Border cell"))/nrow(nonslope)*100

start_speed <- nrow(subset(start, of_classifier == "Speed cell"))/nrow(start)*100
reward_speed <- nrow(subset(reward, of_classifier == "Speed cell"))/nrow(reward)*100
nonslope_speed <- nrow(subset(nonslope, of_classifier == "Speed cell"))/nrow(nonslope)*100

start_hd <- nrow(subset(start, of_classifier == "HD cell"))/nrow(start)*100
reward_hd <- nrow(subset(reward, of_classifier == "HD cell"))/nrow(reward)*100
nonslope_hd <- nrow(subset(nonslope, of_classifier == "HD cell"))/nrow(nonslope)*100

start_rayleigh <- nrow(subset(start, of_classifier == "Rayleigh cell"))/nrow(start)*100
reward_rayleigh <- nrow(subset(reward, of_classifier == "Rayleigh cell"))/nrow(reward)*100
nonslope_rayleigh <- nrow(subset(nonslope, of_classifier == "Rayleigh cell"))/nrow(nonslope)*100

start_spatial <- nrow(subset(start, of_classifier == "Spatial cell"))/nrow(start)*100
reward_spatial <- nrow(subset(reward, of_classifier == "Spatial cell"))/nrow(reward)*100
nonslope_spatial <- nrow(subset(nonslope, of_classifier == "Spatial cell"))/nrow(nonslope)*100

start_non <- nrow(subset(start, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(start)*100
reward_non <- nrow(subset(reward, of_classifier == "Non-spatial"| of_classifier == "None"))/nrow(reward)*100
nonslope_non <- nrow(subset(nonslope, of_classifier == "Non-spatial"| of_classifier == "None"))/nrow(nonslope)*100

```

3. Put into a tibble 
```{r}
proportions_mixed_ramps <- tibble(
  perc=c(start_grid, reward_grid, nonslope_grid, start_border, reward_border, nonslope_border, start_speed, reward_speed, nonslope_speed, start_hd, reward_hd, nonslope_hd, start_rayleigh, reward_rayleigh, nonslope_rayleigh, start_spatial, reward_spatial,nonslope_spatial, start_non,  reward_non, nonslope_non), 
  ramp_id= c("Negative", "Positive", "Unclassified", "Negative", "Positive", "Unclassified", "Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified"),
  ramp_type = c("Grid", "Grid", "Grid", "Border", "Border", "Border", "Speed", "Speed", "Speed", "HD", "HD", "HD", "Rayleigh", "Rayleigh", "Rayleigh", "Spatial", "Spatial", "Spatial", "Non-spatial", "Non-spatial", "Non-spatial"))
```

3. Plot bar graph of proportions
```{r}
ggplot(proportions_mixed_ramps, aes(x= ramp_id, y = perc, fill=factor(ramp_type))) +
  geom_bar(stat="identity",width = 0.9, alpha = .4) +
  labs(y = "Percent", x="") +
  scale_fill_manual(values=c("violetred2", "chartreuse3", "deepskyblue3", "grey1", "blueviolet", "darkorange", "brown1")) +
  #geom_text(aes(label = num), hjust = 1.5, vjust = 0.5, srt=90, size = 6, position = position_dodge(-0.5)) +
  theme_classic() +
  theme(axis.text.x = element_text(size=19),
        axis.text.y = element_text(size=20),
        legend.position="right", 
        legend.title = element_blank(),
        text = element_text(size=19), 
        legend.text=element_text(size=19), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
if (save_figures == 1) {
  ggsave(file = "plots/OF_Analysis_proportions_justScells.png", width = 5, height = 5.5)
}
```





1. extract neurons that are ++ or -- on beaconed trials, position encoding (Figure 3) and driven by path integration (Figure 4)
```{r}
position_data <- spatial_firing %>%
  #filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")  #%>% 
  #filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA"| final_model_o_b == "PSA")
  #filter(final_model_o_b == "S" | final_model_o_b == "SA" | final_model_o_b == "A")
  #filter(final_model_o_b == "S")
  
```

2. plot proportion of positive and negative ramps that are grid/non-grid

1. extract proportion of cells that meet each criteria
```{r}
pospos <- subset(spatial_firing, track_category == "pospos")
negneg <- subset(spatial_firing, track_category == "negneg")
posneg <- subset(spatial_firing, track_category == "posneg")
negpos <- subset(spatial_firing, track_category == "negpos")
posnon <- subset(spatial_firing, track_category == "posnon")
negnon <- subset(spatial_firing, track_category == "negnon")

```


```{r}
pospos_grid <- nrow(subset(pospos, of_classifier == "Grid cell"))/nrow(pospos)*100
negneg_grid <- nrow(subset(negneg, of_classifier == "Grid cell"))/nrow(negneg)*100
posneg_grid <- nrow(subset(posneg, of_classifier == "Grid cell"))/nrow(posneg)*100
negpos_grid <- nrow(subset(negpos, of_classifier == "Grid cell"))/nrow(negpos)*100
negnon_grid <- nrow(subset(negnon, of_classifier == "Grid cell"))/nrow(negnon)*100
posnon_grid <- nrow(subset(posnon, of_classifier == "Grid cell"))/nrow(posnon)*100

pospos_border <- nrow(subset(pospos, of_classifier == "Border cell"))/nrow(pospos)*100
negneg_border <- nrow(subset(negneg, of_classifier == "Border cell"))/nrow(negneg)*100
posneg_border <- nrow(subset(posneg, of_classifier == "Border cell"))/nrow(posneg)*100
negpos_border <- nrow(subset(negpos, of_classifier == "Border cell"))/nrow(negpos)*100
negnon_border <- nrow(subset(negnon, of_classifier == "Border cell"))/nrow(negnon)*100
posnon_border <- nrow(subset(posnon, of_classifier == "Border cell"))/nrow(posnon)*100

pospos_speed <- nrow(subset(pospos, of_classifier == "Speed cell"))/nrow(pospos)*100
negneg_speed <- nrow(subset(negneg, of_classifier == "Speed cell"))/nrow(negneg)*100
posneg_speed <- nrow(subset(posneg, of_classifier == "Speed cell"))/nrow(posneg)*100
negpos_speed <- nrow(subset(negpos, of_classifier == "Speed cell"))/nrow(negpos)*100
negnon_speed <- nrow(subset(negnon, of_classifier == "Speed cell"))/nrow(negnon)*100
posnon_speed <- nrow(subset(posnon, of_classifier == "Speed cell"))/nrow(posnon)*100

pospos_hd <- nrow(subset(pospos, of_classifier == "HD cell"))/nrow(pospos)*100
negneg_hd <- nrow(subset(negneg, of_classifier == "HD cell"))/nrow(negneg)*100
posneg_hd <- nrow(subset(posneg, of_classifier == "HD cell"))/nrow(posneg)*100
negpos_hd <- nrow(subset(negpos, of_classifier == "HD cell"))/nrow(negpos)*100
negnon_hd <- nrow(subset(negnon, of_classifier == "HD cell"))/nrow(negnon)*100
posnon_hd <- nrow(subset(posnon, of_classifier == "HD cell"))/nrow(posnon)*100

pospos_rayleigh <- nrow(subset(pospos, of_classifier == "Rayleigh cell"))/nrow(pospos)*100
negneg_rayleigh <- nrow(subset(negneg, of_classifier == "Rayleigh cell"))/nrow(negneg)*100
posneg_rayleigh <- nrow(subset(posneg, of_classifier == "Rayleigh cell"))/nrow(posneg)*100
negpos_rayleigh <- nrow(subset(negpos, of_classifier == "Rayleigh cell"))/nrow(negpos)*100
negnon_rayleigh <- nrow(subset(negnon, of_classifier == "Rayleigh cell"))/nrow(negnon)*100
posnon_rayleigh <- nrow(subset(posnon, of_classifier == "Rayleigh cell"))/nrow(posnon)*100

pospos_spatial <- nrow(subset(pospos, of_classifier == "Spatial cell"))/nrow(pospos)*100
negneg_spatial <- nrow(subset(negneg, of_classifier == "Spatial cell"))/nrow(negneg)*100
posneg_spatial <- nrow(subset(posneg, of_classifier == "Spatial cell"))/nrow(posneg)*100
negpos_spatial <- nrow(subset(negpos, of_classifier == "Spatial cell"))/nrow(negpos)*100
negnon_spatial <- nrow(subset(negnon, of_classifier == "Spatial cell"))/nrow(negnon)*100
posnon_spatial <- nrow(subset(posnon, of_classifier == "Spatial cell"))/nrow(posnon)*100

pospos_non <- nrow(subset(pospos, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(pospos)*100
negneg_non <- nrow(subset(negneg, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(negneg)*100
posneg_non <- nrow(subset(posneg, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(posneg)*100
negpos_non <- nrow(subset(negpos, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(negpos)*100
negnon_non <- nrow(subset(negnon, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(negnon)*100
posnon_non <- nrow(subset(posnon, of_classifier == "Non-spatial" | of_classifier == "None"))/nrow(posnon)*100

```

3. Put into a tibble 
```{r}
proportions_mixed_ramps <- tibble(
  perc=c(pospos_grid, negneg_grid, posneg_grid, negpos_grid, negnon_grid, posnon_grid, 
         pospos_border, negneg_border, posneg_border, negpos_border, negnon_border, posnon_border,
         pospos_speed, negneg_speed, posneg_speed, negpos_speed, negnon_speed, posnon_speed,
         pospos_hd, negneg_hd, posneg_hd, negpos_hd, negnon_hd, posnon_hd,
         pospos_rayleigh, negneg_rayleigh, posneg_rayleigh, negpos_rayleigh, negnon_rayleigh, posnon_rayleigh,
         pospos_spatial, negneg_spatial, posneg_spatial, negpos_spatial, negnon_spatial, posnon_spatial,
         pospos_non, negneg_non, posneg_non, negpos_non, negnon_non, posnon_non), 
  ramp_id= c("pospos", "negneg", "posneg", "negpos", "negnon", "posnon", "pospos", "negneg", "posneg", "negpos", "negnon", "posnon","pospos", "negneg", "posneg", "negpos", "negnon", "posnon","pospos", "negneg", "posneg", "negpos", "negnon", "posnon","pospos", "negneg", "posneg", "negpos", "negnon", "posnon","pospos", "negneg", "posneg", "negpos", "negnon", "posnon","pospos", "negneg", "posneg", "negpos", "negnon", "posnon"),
  ramp_type = c("Grid", "Grid", "Grid", "Grid", "Grid", "Grid", "Border", "Border", "Border", "Border", "Border", "Border", "Speed", "Speed", "Speed", "Speed", "Speed", "Speed", "HD", "HD", "HD", "HD", "HD", "HD", "Rayleigh", "Rayleigh", "Rayleigh", "Rayleigh", "Rayleigh", "Rayleigh", "Spatial", "Spatial", "Spatial", "Spatial", "Spatial", "Spatial", "Non-spatial", "Non-spatial", "Non-spatial", "Non-spatial", "Non-spatial", "Non-spatial"))
```

3. Plot bar graph of proportions
```{r}
ggplot(proportions_mixed_ramps, aes(x= ramp_id, y = perc, fill=factor(ramp_type))) +
  geom_bar(stat="identity",width = 0.9, alpha = .4) +
  labs(y = "Percent", x="") +
  scale_fill_manual(values=c("violetred2", "chartreuse3", "deepskyblue3", "grey1", "blueviolet", "darkorange", "brown1")) +
  #geom_text(aes(label = num), hjust = 1.5, vjust = 0.5, srt=90, size = 6, position = position_dodge(-0.5)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 70)) +
  theme(axis.text.x = element_text(size=19),
        axis.text.y = element_text(size=20),
        legend.position="right", 
        legend.title = element_blank(),
        text = element_text(size=19), 
        legend.text=element_text(size=19), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
if (save_figures == 1) {
  ggsave(file = "plots/OF_Analysis_proportions_groups.png", width = 7, height = 4)
}
```



### ----------------------------------------------------------------------------------------- ###


1. extract neurons that are ++ or -- on beaconed trials, position encoding (Figure 3) and driven by path integration (Figure 4)
```{r}
position_data <- spatial_firing %>%
  #filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")  #%>% 
  #filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA"| final_model_o_b == "PSA")
  filter(final_model_o_b == "S" | final_model_o_b == "SA" | final_model_o_b == "A")
  #filter(final_model_o_b == "P")
  
```

2. plot proportion of positive and negative ramps that are grid/non-grid

1. extract proportion of cells that meet each criteria
```{r}
grid <- subset(position_data, of_classifier == "Grid cell")
border <- subset(position_data, of_classifier == "Border cell")
speed <- subset(position_data, of_classifier == "Speed cell")
hd <- subset(position_data, of_classifier == "HD cell")
rayleigh <- subset(position_data, of_classifier == "Rayleigh cell")
spatial <- subset(position_data, of_classifier == "Spatial cell")
nonspatial <- subset(position_data, of_classifier == "Non-spatial" | of_classifier == "None")
```


```{r}
start_grid <- nrow(subset(grid, lm_group_b == "Negative"))/nrow(grid)*100
reward_grid <- nrow(subset(grid, lm_group_b == "Positive"))/nrow(grid)*100
nonslope_grid <- nrow(subset(grid, lm_group_b == "Unclassified"))/nrow(grid)*100

start_border <- nrow(subset(border, lm_group_b == "Negative"))/nrow(border)*100
reward_border <- nrow(subset(border, lm_group_b == "Positive"))/nrow(border)*100
nonslope_border <- nrow(subset(border, lm_group_b == "Unclassified" | lm_group_b == "None"))/nrow(border)*100

start_speed <- nrow(subset(speed, lm_group_b == "Negative"))/nrow(speed)*100
reward_speed <- nrow(subset(speed, lm_group_b == "Positive"))/nrow(speed)*100
nonslope_speed <- nrow(subset(speed, lm_group_b == "Unclassified"))/nrow(speed)*100

start_hd <- nrow(subset(hd, lm_group_b == "Negative"))/nrow(hd)*100
reward_hd <- nrow(subset(hd, lm_group_b == "Positive"))/nrow(hd)*100
nonslope_hd <- nrow(subset(hd, lm_group_b == "Unclassified"))/nrow(hd)*100

start_rayleigh <- nrow(subset(rayleigh, lm_group_b == "Negative"))/nrow(rayleigh)*100
reward_rayleigh <- nrow(subset(rayleigh, lm_group_b == "Positive"))/nrow(rayleigh)*100
nonslope_rayleigh <- nrow(subset(rayleigh, lm_group_b == "Unclassified"))/nrow(rayleigh)*100

start_spatial <- nrow(subset(spatial, lm_group_b == "Negative"))/nrow(spatial)*100
reward_spatial <- nrow(subset(spatial, lm_group_b == "Positive"))/nrow(spatial)*100
nonslope_spatial <- nrow(subset(spatial, lm_group_b == "Unclassified"))/nrow(spatial)*100

start_non <- nrow(subset(nonspatial, lm_group_b == "Negative" ))/nrow(nonspatial)*100
reward_non <- nrow(subset(nonspatial, lm_group_b == "Positive"))/nrow(nonspatial)*100
nonslope_non <- nrow(subset(nonspatial, lm_group_b == "Unclassified"))/nrow(nonspatial)*100

```

3. Put into a tibble 
```{r}
proportions_mixed_ramps <- tibble(
  perc=c(start_grid, reward_grid, nonslope_grid, start_border, reward_border, nonslope_border, start_speed, reward_speed, nonslope_speed, start_hd, reward_hd, nonslope_hd, start_rayleigh, reward_rayleigh, nonslope_rayleigh, start_spatial, reward_spatial,nonslope_spatial, start_non,  reward_non, nonslope_non), 
  ramp_id= c("Negative", "Positive", "Unclassified", "Negative", "Positive", "Unclassified", "Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified","Negative", "Positive", "Unclassified"),
  ramp_type = c("Grid", "Grid", "Grid", "Border", "Border", "Border", "Speed", "Speed", "Speed", "HD", "HD", "HD", "Rayleigh", "Rayleigh", "Rayleigh", "Spatial", "Spatial", "Spatial", "Non-spatial", "Non-spatial", "Non-spatial"))
```

3. Plot bar graph of proportions
```{r}
ggplot(proportions_mixed_ramps, aes(x= ramp_type, y = perc, fill=factor(ramp_id))) +
  geom_bar(stat="identity",width = 0.9, alpha = .4) +
  labs(y = "Percent", x="") +
  scale_fill_manual(values=c("violetred2", "chartreuse3", "grey36")) +
  #geom_text(aes(label = num), hjust = 1.5, vjust = 0.5, srt=90, size = 6, position = position_dodge(-0.5)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 70)) +
  theme(axis.text.x = element_text(size=19),
        axis.text.y = element_text(size=20),
        legend.position="right", 
        legend.title = element_blank(),
        text = element_text(size=19), 
        legend.text=element_text(size=19), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
if (save_figures == 1) {
  ggsave(file = "plots/OF_Analysis_proportions2_allspeedcells.png", width = 6, height = 4)
}
```
### ----------------------------------------------------------------------------------------- ###




### ----------------------------------------------------------------------------------------- ###




### ------------------------------------------------------------------------------------------ ### 


## now plot scatter of slopes for outbound and slopes for homebound with neurons marked accordng to whether they are reset or continuous

1. Here we subset neurons based on position encoding (Figure 3) and path integrating (Figure 4) and either reset or contiuous firing. 
```{r}
position_neurons <- spatial_firing  %>% 
  filter(final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")  #%>% 
  #filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")


```


2. Plot scatter plot
```{r}

ggplot() + 
    geom_point(data=spatial_firing,
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(spatial_information_score)), 
                   color=factor(unlist(lm_group_b))), alpha=0.8) +

    coord_cartesian(ylim = c(0,1), xlim = c(-.5,.5)) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    #geom_abline(intercept = 0, slope = -1, colour = "grey", linetype = "dashed") +
    xlab("Outbound slope") +
    ylab("Spatial Information Score") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3", "Grey72", "Grey2")) +
    theme(axis.text.x = element_text(size=18),
          axis.text.y = element_text(size=18),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=17), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
 ggsave(file = "plots/Slope_vs_SpatialInformation_score.png", width = 4, height = 4) 
}
```

2. Plot scatter plot
```{r}

ggplot() + 
    geom_point(data=subset(position_neurons, track_category == "pospos" | track_category == "negneg"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(spatial_information_score)), 
                   color=factor(unlist(lm_group_b))), alpha=0.8) +
    geom_point(data=subset(position_neurons, track_category == "posneg" | track_category == "negpos"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(spatial_information_score)), 
                   color=factor(unlist(lm_group_b))), shape=2, alpha=0.8) +
    geom_point(data=subset(position_neurons, track_category == "posnon" | track_category == "negnon"),
               aes(x = as.numeric(unlist(asr_b_o_rewarded_fit_slope)), 
                   y = as.numeric(unlist(spatial_information_score)), 
                   color=factor(unlist(lm_group_b))), shape=3, alpha=0.8) +  

    coord_cartesian(ylim = c(0,1), xlim = c(-.5,.5)) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    #geom_abline(intercept = 0, slope = -1, colour = "grey", linetype = "dashed") +
    xlab("Outbound slope") +
    ylab("Spatial Information Score") +
    theme_classic() +
    scale_color_manual(values=c("violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=18),
          axis.text.y = element_text(size=18),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=17), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 

if (save_figures == 1) {
 ggsave(file = "plots/Slope_vs_SpatialInformation_score_groups.png", width = 4, height = 4) 
}
```