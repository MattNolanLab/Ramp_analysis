---
title: "Figure7"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### --------------------------------------------------------------------------------------- ###

## Differences in spatial firing between hit/rewarded and miss/unrewarded trials

We might want to see differences in the relationship between firing rate and position along the track between rewarded and non rewarded trials (i.e. hit and miss trials)


### --------------------------------------------------------------------------------------- ###

## Run average rates and compare hit and miss via an anova 


1. first combine hit and miss trials together with an indicator of rewarded/not rewarded
```{r}
join_rates <- function(hit, run, try, session_id, cluster_id) {
  if (any(is.na(hit)) | any(is.na(run)) | any(is.na(try))) { 
    return(
      df <- tibble(Rates = rep(NA, times=600), 
               Position = rep(NA, times=600),
               Reward_indicator = c(rep("Rewarded", times=200), rep("Run Through", times=200), rep("Try", times=200)))
    )
  }
  df <- tibble(Rates = c(unlist(hit), unlist(run), unlist(try)), Reward_indicator = c(rep("Rewarded", times=200), rep("Run Through", times=200), rep("Try", times=200)), Position = c(rep(1:200), rep(1:200), rep(1:200)))
  return (df)
}

spatial_firing <- spatial_firing %>%
  mutate(avg_both_asr_b = pmap(list(Rates_averaged_rewarded_b, Rates_averaged_runthru_b, Rates_averaged_try_b, session_id, cluster_id), join_rates))

```

2. Run lm and compare models without reward to models with via anova
_extract both slope and intercept significance_
matt : this could probably be reduced to one function using your unnest_wider function. 
```{r}
compare_models_slope <- function(df, run,try){
 # Check for NAs
  if (any(is.na(run)) | any(is.na(try))) { 
    return(NA)
  }
 df <- df %>%
  filter(Position > 30, Position < 90)
  fit <- lme4::lmer(Rates ~ Position * Reward_indicator + (Position||Reward_indicator), data = df, na.action = na.omit, REML = FALSE) # more complicated model
  prtAnova <- car::Anova(fit, type="II")
  return (prtAnova$"Pr(>Chisq)"[3][1])
}
```

3. Run lm on all cells and extract anova pval
```{r}
spatial_firing <- spatial_firing %>%
  mutate(avg_pval_slope = pmap(list(avg_both_asr_b, Rates_averaged_runthru_b, Rates_averaged_try_b), compare_models_slope))

```


### tag cells based on either slope or intercept significance
1. make function
```{r}
mark_neurons_sig <- function(pval){
  if (any(is.na(pval))) {
    return(NA)
  }
  if( pval < 0.01) {
    return( "Significant" )
  } else if( pval >= 0.01) {
    return( "Not-Significant" )
  } else {
    return("None")
  }
}
```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reward_interaction_id = map(avg_pval_slope, mark_neurons_sig))
```


### ----------------------------------------------------------------------------- ###

## extract slope, r.squared vlaue and pval for failed trials

# Run simple linear model to examine relationship between firing rate and position in failed trials
_note:for now we are only interested in the outbound region of the track (30 - 90 cm)_

1. Average trials with no reward
1. Write function to add position
```{r}
add_position <- function(df, session_id, cluster_id) {
  if(all(is.na(df))){
    print(paste0("All NAs. Session: ", session_id, ". Cluster:", cluster_id))
    df <- tibble(Rates = rep(NA, times=200), 
                 Position = rep(NA, times=200))
    return(df)
    }
  df <- tibble(Rates = unlist(df), Position = rep(1:200)) 
  return(df)
}
```
input columns: 
Rates_averaged_failed_b = beaconed trials
```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_try = pmap(list(Rates_averaged_try_b, session_id, cluster_id), add_position)
         )
```

```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_run = pmap(list(Rates_averaged_runthru_b, session_id, cluster_id), add_position)
         )
```




3. run lm on all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_try_fit_')) %>%
  select(-contains('asr_b_run_fit_')) %>%
  mutate(asr_b_try_fit = pmap(list(asr_b_try, 30, 90), lm_helper)) %>%
  mutate(asr_b_run_fit = pmap(list(asr_b_run, 30, 90), lm_helper)) %>%
  unnest_wider(asr_b_try_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_b_run_fit, names_sep = "_", names_repair = "universal")

```

Linear model results are stored in:
spatial_firing$asr_b_o_failed_fit_pval
spatial_firing$asr_b_o_failed_fit_slope
spatial_firing$asr_b_o_failed_fit_r.squared

4. subset by outbound ramps
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
```

5. Plot slope coefficient from linear model for both failed and rewarded trials
```{r}
ggplot(data=ramps, aes(x = asr_b_o_rewarded_fit_slope,
                                y = asr_b_run_fit_slope, 
                                fill = factor(unlist(reward_interaction_id)),
                                color = factor(unlist(reward_interaction_id)))) +
    coord_cartesian(xlim=c(-0.55,0.55), y=c(-0.55,0.55)) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red", "blue")) +
    scale_color_manual(values=c("grey", "red", "blue")) +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/SlopeScatter_reward_vs_run.png", width = 4, height = 4)
```
,5. Plot slope coefficient from linear model for both failed and rewarded trials
```{r}
ggplot(data=ramps, aes(x = asr_b_o_rewarded_fit_slope,
                                y = asr_b_try_fit_slope, 
                                fill = factor(unlist(reward_interaction_id)),
                                color = factor(unlist(reward_interaction_id)))) +
    coord_cartesian(xlim=c(-0.55,0.55), y=c(-0.55,0.55)) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red", "blue")) +
    scale_color_manual(values=c("grey", "red", "blue")) +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/SlopeScatter_reward_vs_try.png", width = 4, height = 4)
```

### ----------------------------------------------------------------------------------------- ###

## Now we want to examine if there are differences in the reset activity between failed and rewarded trials

To do this, we can plot population rate for rewarded and failed trials across whole track 

1. Split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in these neurons here
```{r}
position_neurons <- filter(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI", final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA" )
```
## final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA"
Function to plot data mean and SD of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SD_plots <- function(df, group_b, group_h, track_group, x_start = 30, x_end = 90){

 df <- df %>%
  filter(lm_group_b == group_b,
         lm_group_b_h == group_h, 
         reset_group == track_group) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b))
 
 df$Rates <- as.double(df$Rates)

 df <- df %>%
   group_by(Position, Reward_indicator) %>%
   dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE),
             se_b = std.error(Rates, na.rm = TRUE))
 
 ggplot(data=df) +
  annotate("rect", xmin=0, xmax=30, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=170, xmax=200, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=90, xmax=110, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b,
                  fill=factor(Reward_indicator)), alpha=0.1) +
   geom_line(aes(y=mean_b, x=Position, color=factor(Reward_indicator)), alpha=0.5) +
   scale_fill_manual(values=c("black", "red", "blue")) +
   scale_color_manual(values=c("black", "red", "blue")) +
   theme_classic() +
   labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
   theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```

2. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
(NegNegC_plot <- mean_SD_plots(position_neurons, "Negative", "Negative", "Continuous",  0, 200))
ggsave(file = "plots/NegNeg_Continuous_failed_PI_speed.png", width = 4.5, height = 2.5)
```
2. Subset data by group then average rates for plotting          **Negative Negative Reset**
```{r}
(NegNegR_plot <- mean_SD_plots(position_neurons, "Negative", "Negative", "Reset",  0, 200))
ggsave(file = "plots/NegNeg_Reset_failed_PI_speed.png", width = 4.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
(PosPosC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Continuous", 0, 200))
ggsave(file = "plots/PosPos_Continuous_failed_PI_speed.png", width = 4.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive Positive Reset**
```{r}
(PosPosR_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Reset", 0, 200))
ggsave(file = "plots/PosPos_Reset_failed_PI_speed.png", width = 4.5, height = 2.5)
```


```{r}
mean_SD_plots <- function(df, group_b, group_h, x_start = 30, x_end = 90){
 print(length(df))

 df <- df %>%
  filter(lm_group_b == group_b,
         lm_group_b_h == group_h) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b))
 
 df$Rates <- as.double(df$Rates)

 df <- df %>%
   group_by(Position, Reward_indicator) %>%
   dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE),
             se_b = std.error(Rates, na.rm = TRUE))
 
 ggplot(data=df) +
  annotate("rect", xmin=0, xmax=30, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=170, xmax=200, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=90, xmax=110, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b,
                  fill=factor(Reward_indicator)), alpha=0.1) +
   geom_line(aes(y=mean_b, x=Position, color=factor(Reward_indicator)), alpha=0.5) +
   scale_fill_manual(values=c("black", "red", "blue")) +
   scale_color_manual(values=c("black", "red", "blue")) +
   theme_classic() +
   labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
   theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```

4. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Negative", 0, 200))
ggsave(file = "plots/PosNeg_failed_PI_speed.png", width = 4.5, height = 2.5)
```
4. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Positive", 0, 200))
ggsave(file = "plots/NegPos_failed_PI_speed.png", width = 4.5, height = 2.5)
```





### ------------------------------------------------------------------------------------ ###

## average speed vs location

First average speed for each cluster

```{r}

average_speed <- function(df, TT=0) {
  df <-
    tibble(
      Rates = as.numeric(Re(df[[1]])),
      Position = as.integer(Re(df[[2]])),
      Acceleration = as.numeric(Re(df[[3]])),
      Speed = as.numeric(Re(df[[4]])),
      Trials = as.factor(df[[5]]),
      Types = as.factor(df[[6]]))
  

  df <- df %>%
    subset(Speed > 2 & Types == TT) %>%
    select(Position, Speed ) %>%
    group_by(Position) %>%
    dplyr::summarise(mean_b = mean(Speed, na.rm=TRUE), sd_b = std.error(Speed, na.rm=TRUE))
  return(df)
  
}
```


```{r}
spatial_firing <- spatial_firing  %>%
  mutate(mean_speed = map2(spikes_in_time, 0, average_speed))

```

Then average over selected neurons 

1. Split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in these neurons here
```{r}
position_neurons <- filter(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI", final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA" )
```
## final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA"
Function to plot data mean and SD of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_speed_plots <- function(df, x_start = 30, x_end = 90){

 df <- df %>%
   select(mean_speed) %>%
   unnest(c(mean_speed))
 
 df <- df %>%
   group_by(Position) %>%
   dplyr::summarise(mean_b = mean(mean_b, na.rm = TRUE),
             se_b = std.error(mean_b, na.rm = TRUE))
 
 ggplot(data=df) +
  coord_cartesian(ylim=c(0,100)) +
  annotate("rect", xmin=0, xmax=30, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=170, xmax=200, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=90, xmax=110, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b), alpha=0.1) +
   geom_smooth(aes(y=mean_b, x=Position), alpha=0.5, n= 100, span=0.2) +
   scale_fill_manual(values=c("black", "red", "blue")) +
   scale_color_manual(values=c("black", "red", "blue")) +
   theme_classic() +
   labs(y = "Mean speed (cm/s)", x = "Position") +
   xlim(x_start, x_end) +
   theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
 
}
```

2. Subset data by group then average rates for plotting          
```{r}
(Pos_speed_plot <- mean_speed_plots(position_neurons,  0, 200))
ggsave(file = "plots/PI_speed.png", width = 4.5, height = 2.5)
```



1. Split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in these neurons here
```{r}
speed_neurons <- filter(spatial_firing, final_model_o_b == "S" | final_model_o_b == "A" | final_model_o_b == "SA")
```

2. Subset data by group then average rates for plotting          
```{r}
(Speed_speed_plot <- mean_speed_plots(speed_neurons,  0, 200))
ggsave(file = "plots/Sp_speed.png", width = 4.5, height = 2.5)
```