---
title: "Figure7"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### --------------------------------------------------------------------------------------- ###

## Differences in the positional dependance of firing between rewarded trials, run through trials and trials where the animal "tries" 


trial types :
1. rewarded = animal recieves a reward
2. try = speed in the reward zone is within the 95% confidence interval of speed in the reward zone in
rewarded trials
3. run through = speed in the reward zone is outside the 95% confidence interval of speed in the reward zone in rewarded trials


### --------------------------------------------------------------------------------------- ###


## To address low trial numbers in run through and try catagories, first lets create a new dataset with only high trial numbers. 

First extract number of trials for each type
```{r}
trial_adder <- function(df) {
  df <-
  tibble(
    Rates = as.numeric(df[[1]]),
    Position = as.numeric(df[[3]]),
    Trials = as.numeric(df[[4]])
  )
  
  trials <- length(unique(df$Trials))
  return(trials)
}


spatial_firing <- spatial_firing %>%
  mutate(try_trials_number = map(spikes_in_time_try,trial_adder),
         run_trials_number = map(spikes_in_time_run,trial_adder))
```


### --------------------------------------------------------------------------------------- ###

Then combine hit and miss trials together with an indicator of trial type (hit, try, run)

First, function that extracts data into a tibble, saves space in the function below

```{r}
extract_to_tibble <- function(df) {
  df <-
  tibble(
    Rates = as.numeric(Re(df[[1]])),
    Position = as.numeric(Re(df[[3]])),
    Trials = as.numeric(Re(df[[4]]))
  )
  return (df)
}

```

Function to join firing rates from different trial types and add indicator of the type of trial
```{r}

join_rates <- function(hit, run, try, session_id, cluster_id) {
  if (any(is.na(hit)) | any(is.na(run)) | any(is.na(try))) { 
    return(NA)
  }
  
  hit_df <- extract_to_tibble(hit)
  run_df <- extract_to_tibble(run)
  try_df <- extract_to_tibble(try)
 
  df <- tibble(Rates = c(hit_df$Rates, 
                         run_df$Rates,
                         try_df$Rates), 
               Reward_indicator = c(rep("Rewarded", times=nrow(hit_df)), 
                                    rep("Run", times=nrow(run_df)), 
                                    rep("Try", times=nrow(try_df))), 
               Position = c(hit_df$Position, 
                            run_df$Position, 
                            try_df$Position), 
               Trials = c(hit_df$Trials,
                          run_df$Trials,
                          try_df$Trials))

  return (df)
}

```

1. Generate firing rate tibble for each cell
```{r}
spatial_firing <- spatial_firing %>%
  mutate(both_asr_b_by_trial = pmap(list(spikes_in_time_reward, spikes_in_time_run, spikes_in_time_try, session_id, cluster_id), join_rates))

```


Function to run linear model that takes trial type (hit, try, run) into account and use the car package to extract slope significance
```{r}
compare_models_slope_lm <- function(df, run,try){
 # Check for NAs
  if (any(is.na(run)) | any(is.na(try)) | any(is.na(df))) { 
    return(NA)
  }
 df <- df %>%
 filter(Position >= 30, Position <= 90)
 fit <- lme4::lmer(Rates ~ scale(Position) * Reward_indicator + (1+scale(Position) | Trials), data = df, na.action=na.omit)
 modelAnova <- car::Anova(fit)
 
 return (modelAnova$"Pr(>Chisq)"[[3]])
}
```

2. Run linear model on all cells and extract pval
To test just use the first two rows
```{r}
spatial_firing <- spatial_firing %>%
  mutate(pval_slope = pmap(list(both_asr_b_by_trial, Avg_FiringRate_RunTrials, Avg_FiringRate_TryTrials), compare_models_slope_lm))
```

Now we can classify cells based on their significance in the above model

First make function to classify neurons
```{r}
mark_neurons_sig <- function(pval){
  if (any(is.na(pval))) {
    return(NA)
  }
  if( pval < 0.01) {
    return( "Significant" )
  } else if( pval >= 0.01) {
    return( "Not-Significant" )
  } else {
    return("None")
  }
}
```

3. Make new column to identify whether cells are significant
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reward_interaction_id = map(pval_slope, mark_neurons_sig))
```

### ----------------------------------------------------------------------------- ###


## Figure 7 stats

Find proportion & numbers of neurons that are significant/non-significiant

```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
ramps_with_enough_trials <- subset(ramps, reward_interaction_id != "None" & reward_interaction_id != "NA")
```

```{r}
sig_ramps <- nrow(subset(ramps, reward_interaction_id == "Significant"))/nrow(ramps_with_enough_trials)*100
nonsig_ramps <- nrow(subset(ramps, reward_interaction_id == "Not-Significant"))/nrow(ramps_with_enough_trials)*100
```
```{r}
sig_ramps <- nrow(subset(ramps, reward_interaction_id == "Significant"))
nonsig_ramps <- nrow(subset(ramps, reward_interaction_id == "Not-Significant"))
```



### ----------------------------------------------------------------------------- ###

We also want to run a simple linear model for each trial type separately so we can extract the coefficients for each variable. 

First, add position to each of the firing rates individually (before we put them all in one tibble, here we make a seperate one for each and add it back into the dataframe)


Function to add position for individual trial type, returns NAs if those trials are not present 
```{r}
add_position <- function(df, session_id, cluster_id) {
  if(all(is.na(df))){
    print(paste0("All NAs. Session: ", session_id, ". Cluster:", cluster_id))
    df <- tibble(Rates = rep(NA, times=200), 
                 Position = rep(NA, times=200))
    return(df)
    }
  df <- tibble(Rates = unlist(df), Position = rep(1:200)) 
  return(df)
}
```

1. Run this on all animals for try and run through trials (we already have coefficients for rewarded data from Figure 2)
```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_try = pmap(list(Avg_FiringRate_TryTrials, session_id, cluster_id), add_position),
         asr_b_run = pmap(list(Avg_FiringRate_RunTrials, session_id, cluster_id), add_position)
         )
```

2. run lm on all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_try_fit_')) %>%
  select(-contains('asr_b_run_fit_')) %>%
  mutate(asr_b_try_fit = pmap(list(asr_b_try, 30, 90), lm_helper)) %>%
  mutate(asr_b_run_fit = pmap(list(asr_b_run, 30, 90), lm_helper)) %>%
  unnest_wider(asr_b_try_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_b_run_fit, names_sep = "_", names_repair = "universal")

```

Linear model results are stored in:
spatial_firing$asr_b_try_fit_pval
spatial_firing$asr_b_try_fit_slope
spatial_firing$asr_b_try_fit_r.squared


First, filter dataset for having enough trials
```{r}
spatial_firing_enoughtrials <- spatial_firing %>%
  filter(run_trials_number > 3 & try_trials_number > 3)
```


Now we can plot the slope coefficients for each trial type, marked by whether or not the cells are significantly modulated by trial type (hit, try, run)

1. subset by outbound ramps (Figure 2) and cells that are modulated by position alone (Figure 3)

```{r}
ramps <- subset(spatial_firing_enoughtrials, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI")
```

```{r}
just_position_ramps <- subset(ramps, final_model_o_b == "P")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}
plot_slope_comparison <- function(slope1, slope2, factor1){
  df <- tibble(x_slope = slope1, y_slope = slope2, fac = factor1)
  ggplot(data=df, aes(x = x_slope,
                                y = y_slope, 
                                fill = factor(unlist(fac)),
                                color = factor(unlist(fac)))) +
    coord_cartesian(xlim=c(-0.55,0.55), y=c(-0.55,0.55)) +
    #coord_cartesian(xlim=c(-0.35,0.35), y=c(-0.35,0.35)) +
    geom_point(alpha=0.3) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    scale_fill_manual(values=c("black", "red", "blue")) +
    scale_color_manual(values=c("black", "red", "blue")) +
    xlab("slope") +
    ylab(expression("slope")) +
    theme_classic() +
    theme(axis.text.x = element_text(size=14),
          axis.text.y = element_text(size=14),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=14), 
          legend.text=element_text(size=14), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
}

plot_slope_comparison (just_position_ramps$asr_b_o_rewarded_fit_slope, just_position_ramps$asr_b_run_fit_slope, just_position_ramps$reward_interaction_id)


if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_run_justposition.png", width = 4, height = 3.5)
}

```

3. Plot slope coefficients for rewarded trials and trials where the animal tries to stop
```{r}
plot_slope_comparison (just_position_ramps$asr_b_o_rewarded_fit_slope, just_position_ramps$asr_b_try_fit_slope, just_position_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_try_justposition.png", width = 4, height = 3.5)
}

```


Do the same as above but for cells that are modulated by position in any way (P,PA,PS,PSA) as determined by Figure 3 (Figure3_Analysis.Rmd)

1. subset by cells that are modulated by position in any way (P,PA,PS,PSA) 
```{r}
all_position_ramps <- subset(ramps, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}
plot_slope_comparison (all_position_ramps$asr_b_o_rewarded_fit_slope, all_position_ramps$asr_b_run_fit_slope, all_position_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_run_allposition.png", width = 4, height = 3.5)
}
```

3. Plot slope coefficients for rewarded trials and trials where the animal tries to stop
```{r}
plot_slope_comparison (all_position_ramps$asr_b_o_rewarded_fit_slope, all_position_ramps$asr_b_try_fit_slope, all_position_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_try_allposition.png", width = 4, height = 3.5)
}

```


Do the same as above but for cells that are modulated by speed as determined by Figure 3 (Figure3_Analysis.Rmd)

1. subset by outbound ramps (Figure 2) and cells that are modulated by speed (Figure 3)
```{r}
ramps <- subset(spatial_firing_enoughtrials, lm_group_b == "Negative" | lm_group_b == "Positive")
```

```{r}
speed_ramps <- subset(ramps, final_model_o_b == "S")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}

plot_slope_comparison (speed_ramps$asr_b_o_rewarded_fit_slope, speed_ramps$asr_b_run_fit_slope, speed_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_run_speed.png", width = 4, height = 3.5)
}

```

3. Plot slope coefficients for rewarded trials and trials where the animal tries to stop
```{r}
plot_slope_comparison (speed_ramps$asr_b_o_rewarded_fit_slope, speed_ramps$asr_b_try_fit_slope, speed_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_try_speed.png", width = 4, height = 3.5)
}

```



Do the same as above but for ALL cells that are modulated by speed as determined by Figure 3 (Figure3_Analysis.Rmd), regardless of classification in Figure 2

1. subset by outbound ramps (Figure 2) and cells that are modulated by acceleration (Figure 3)
```{r}
allspeed_ramps <- subset(spatial_firing_enoughtrials, final_model_o_b == "S")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}
plot_slope_comparison (allspeed_ramps$asr_b_o_rewarded_fit_slope, allspeed_ramps$asr_b_run_fit_slope, allspeed_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_run_allspeed.png", width = 4, height = 3.5)
}

```

3. Plot slope coefficients for rewarded trials and trials where the animal tries to stop
```{r}
plot_slope_comparison (allspeed_ramps$asr_b_o_rewarded_fit_slope, allspeed_ramps$asr_b_try_fit_slope, allspeed_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_try_allspeed.png", width = 4, height = 3.5)
}

```


Do the same as above but for cells that are modulated by acceleration as determined by Figure 3 (Figure3_Analysis.Rmd)

1. subset by outbound ramps (Figure 2) and cells that are modulated by acceleration (Figure 3)
```{r}
acceleration_ramps <- subset(ramps, final_model_o_b == "A")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}
plot_slope_comparison (acceleration_ramps$asr_b_o_rewarded_fit_slope, acceleration_ramps$asr_b_run_fit_slope, acceleration_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_run_accel.png", width = 4, height = 3.5)
}

```

3. Plot slope coefficients for rewarded trials and trials where the animal tries to stop
```{r}
plot_slope_comparison (acceleration_ramps$asr_b_o_rewarded_fit_slope, acceleration_ramps$asr_b_try_fit_slope, acceleration_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_try_accel.png", width = 4, height = 3.5)
}
```



Do the same as above but for ALL cells that are modulated by acceleration as determined by Figure 3 (Figure3_Analysis.Rmd), regardless of classification in Figure 2

1. subset by outbound ramps (Figure 2) and cells that are modulated by acceleration (Figure 3)
```{r}
allacceleration_ramps <- subset(spatial_firing_enoughtrials, final_model_o_b == "A")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}
plot_slope_comparison (allacceleration_ramps$asr_b_o_rewarded_fit_slope, allacceleration_ramps$asr_b_run_fit_slope, allacceleration_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_run_allaccel.png", width = 4, height = 3.5)
}

```

3. Plot slope coefficients for rewarded trials and trials where the animal tries to stop
```{r}
plot_slope_comparison (allacceleration_ramps$asr_b_o_rewarded_fit_slope, allacceleration_ramps$asr_b_try_fit_slope, allacceleration_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/SlopeScatter_reward_vs_try_allaccel.png", width = 4, height = 3.5)
}
```

### ----------------------------------------------------------------------------------------- ###

## Calculate and plot offset 

Now, we want to find out if within the speed group - is their firing rate reset or continue across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 

First, normalise firing rates. 

1. make function to load rates and normalise
```{r}
normalise_rates <- function(df){
  df <- tibble(Rates = unlist(df), Position = rep(1:200))
  x <- scale(df$Rates, center=TRUE, scale=TRUE)
  return(x)
}

```

2. run on all cells
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_try = map(Avg_FiringRate_TryTrials, normalise_rates), 
         normalised_rates_run = map(Avg_FiringRate_RunTrials, normalise_rates))
```

Then, predict firing rate in homebound region based on fit from real data in outbound region

Predict mean and confidence intervals for firing rate at the start of the homebound zone (track positions 110 to 115 cm) based on firing in the outbound zone (30 to 90 cm).

2. Run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_try_')) %>%
  select(-contains('predict_params_run_')) %>%
  mutate(predict_params_try = map(normalised_rates_try, predict_homebound),
         predict_params_run = map(normalised_rates_run, predict_homebound)) %>%
  unnest_wider(predict_params_try, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(predict_params_run, names_sep = "_", names_repair = "universal") 

spatial_firing <- spatial_firing %>%
  mutate(
         predict_diff_try = map2_dbl(normalised_rates_try, predict_params_try_fit, calc_predict_diff),
         predict_diff_run = map2_dbl(normalised_rates_run, predict_params_run_fit, calc_predict_diff))

```

1. subset by outbound ramps (Figure 2) and cells that are modulated by speed (Figure 3)
```{r}
ramps <- subset(spatial_firing_enoughtrials, lm_group_b == "Negative" | lm_group_b == "Positive")
```

1. subset by outbound ramps (Figure 2) and cells that are modulated by position (Figure 3)
```{r}
position_ramps <- subset(ramps, final_model_o_b == "P")
```

2. Plot slope coefficient for rewarded trials and run through trials
```{r}
plot_offset_comparison <- function(offset1, offset2, factor1){
  df <- tibble(x_offset = unlist(offset1), y_offset = unlist(offset2), fac = factor1)
  ggplot(data=df, aes(x = x_offset,
                                y = y_offset, 
                                fill = factor(unlist(fac)),
                                color = factor(unlist(fac)))) +
    coord_cartesian(xlim=c(-5,5), y=c(-5,5)) +
    geom_point(alpha=0.8) +
    geom_abline(intercept = 0, slope = 1, colour = "grey", linetype = "dashed") +
    scale_fill_manual(values=c("firebrick1", "darkorange", "darkorchid1", "darkslategray")) +
    scale_color_manual(values=c("firebrick1", "darkorange", "darkorchid1", "darkslategray")) +
    xlab("offset(rewarded)") +
    ylab(expression("offset")) +
    theme_classic() +
    theme(axis.text.x = element_text(size=14),
          axis.text.y = element_text(size=14),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=14), 
          legend.text=element_text(size=14), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
}

```
  scale_fill_manual(values=c("firebrick1","gold", "dodgerblue2", "darkorange", "darkorchid1", "chartreuse3", "darkslategray", "grey78")) +

2. Plot offset for rewarded trials and run through trials
```{r}
plot_offset_comparison (position_ramps$predict_diff, position_ramps$predict_diff_run, position_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/OffsetScatter_reward_vs_run_justposition.png", width = 4, height = 3.5)
}
```


3. Plot offset for rewarded trials and trials where the animal tries to stop
```{r}
plot_offset_comparison (position_ramps$predict_diff, position_ramps$predict_diff_try, position_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/OffsetScatter_reward_vs_try_justposition.png", width = 4, height = 3.5)
}

```

Do the same as above but for ALL cells that are modulated by position as determined by Figure 3 (Figure3_Analysis.Rmd) i.e. PS, P, PA, PSA

1. subset by outbound ramps (Figure 2) and cells that are modulated by position (Figure 3)
```{r}
allposition_ramps <- subset(ramps, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Plot offset for rewarded trials and run through trials
```{r}
plot_offset_comparison (allposition_ramps$predict_diff, allposition_ramps$predict_diff_run, allposition_ramps$final_model_o_b)

if (save_figures == 1) {
  ggsave(file = "plots/OffsetScatter_reward_vs_run_allposition.png", width = 4, height = 3.5)
}
```

3. Plot offset for rewarded trials and trials where the animal tries to stop
```{r}
plot_offset_comparison (allposition_ramps$predict_diff, allposition_ramps$predict_diff_try, allposition_ramps$final_model_o_b)

if (save_figures == 1) {
  ggsave(file = "plots/OffsetScatter_reward_vs_try_allposition.png", width = 4, height = 3.5)
}

```



Do the same as above but for ALL cells that are modulated by speed as determined by Figure 3 (Figure3_Analysis.Rmd), regardless of classification in Figure 2 i.e. S

1. subset by outbound ramps (Figure 2) and cells that are modulated by acceleration (Figure 3)
```{r}
allspeed_ramps <- subset(spatial_firing_enoughtrials, final_model_o_b == "S")
```

2. Plot offset for rewarded trials and run through trials
```{r}
plot_offset_comparison (allspeed_ramps$predict_diff, allspeed_ramps$predict_diff_run, allspeed_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/OffsetScatter_reward_vs_run_allspeed.png", width = 4, height = 3.5)
}

```

3. Plot offset for rewarded trials and trials where the animal tries to stop
```{r}
plot_offset_comparison (allspeed_ramps$predict_diff, allspeed_ramps$predict_diff_try, allspeed_ramps$reward_interaction_id)

if (save_figures == 1) {
  ggsave(file = "plots/OffsetScatter_reward_vs_try_allspeed.png", width = 4, height = 3.5)
}

```



### ----------------------------------------------------------------------------------------- ###


Now we want to examine if there are differences in the reset activity between trial types (hit, try, run). To do this, we can plot population rate for rewarded and failed trials across whole track. 

Function to join firing rates from different trial types and add indicator of the type of trial

First combine hit and miss trials together with an indicator of trial type (hit, try, run)

Function to join firing rates from different trial types and add indicator of the type of trial
```{r}
join_average_rates <- function(hit, run, try, session_id, cluster_id) {
  if (any(is.na(hit)) | any(is.na(run)) | any(is.na(try))) { 
    return(
      df <- tibble(Rates = rep(NA, times=600), 
               Position = rep(NA, times=600),
               Reward_indicator = c(rep("Rewarded", times=200), rep("Run Through", times=200), rep("Try", times=200)))
    )
  }
  df <- tibble(Rates = c(unlist(hit), unlist(run), unlist(try)), Reward_indicator = c(rep("Rewarded", times=200), rep("Run Through", times=200), rep("Try", times=200)), Position = c(rep(1:200), rep(1:200), rep(1:200)))
  return (df)
}
```

1. Generate firing rate tibble for each cell
```{r}
spatial_firing <- spatial_firing %>%
  mutate(avg_both_asr_b = pmap(list(Avg_FiringRate_HitTrials, Avg_FiringRate_RunTrials, Avg_FiringRate_TryTrials, session_id, cluster_id), join_average_rates))
```


Generic function to plot firing rate ± SEM as a function of position and colour coded according to trial outcome. The function expects to receive the unnested mean firing rates for all neurons that are to be plotted. Conditions for selection should be given before calling the function. Column names of the input data frame should be 'Rates', 'Position' and 'Reward_indicator'.
```{r}
mean_SEM_plots_by_Outcome <- function(df, x_start = 00, x_end = 200) {
  df$Rates <- as.double(df$Rates)

 df <- df %>%
   group_by(Position, Reward_indicator) %>%
   dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE),
             se_b = std.error(Rates, na.rm = TRUE))
 
 ggplot(data=df) +
  annotate("rect", xmin=0, xmax=30, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=170, xmax=200, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=90, xmax=110, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b,
                  fill=factor(Reward_indicator)), alpha=0.1) +
   geom_line(aes(y=mean_b, x=Position, color=factor(Reward_indicator)), alpha=0.5) +
   scale_fill_manual(values=c("black", "red", "blue")) +
   scale_color_manual(values=c("black", "red", "blue")) +
   theme_classic() +
   labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
   #ylim(7,20) +
   theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```



1. Split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in position neurons here
```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative", final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA"| final_model_o_b == "PSA")
```


3. Subset data by group then average rates for plotting          **Negative Negative Reset**
```{r}
(NegNegR_plot <- position_neurons %>%
  filter(lm_group_b == "Negative",
         lm_group_b_h == "Negative") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
 ggsave(file = "plots/NegNeg_Reset_PI_allposition.png", width = 4.5, height = 2.5) 
}

```


5. Subset data by group then average rates for plotting          **Positive Positive Reset**
```{r}
(PosPosR_plot <- position_neurons %>%
  filter(lm_group_b == "Positive",
         lm_group_b_h == "Positive") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/PosPos_Reset_PI_allposition.png", width = 4.5, height = 2.5)
}

```

6. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(PosUC_plot <- position_neurons %>%
  filter(lm_group_b == "Positive",
         lm_group_b_h == "Negative") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))


if (save_figures==1) {
  ggsave(file = "plots/PosNeg_PI_allposition.png", width = 4.5, height = 2.5)
}

```

7. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(NegUC_plot <- position_neurons %>%
  filter(lm_group_b == "Negative",
         lm_group_b_h == "Positive") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))



if (save_figures==1) {
  ggsave(file = "plots/NegPos_PI_allposition.png", width = 4.5, height = 2.5)
}

```




Repeat above for just position neurons

1. Split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in position neurons here
```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative", final_model_o_b == "P")
```


_note: no neurons for this group so will not run_
2. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
#(NegNegC_plot <- position_neurons %>%
#  filter(lm_group_b == "Negative",
#         lm_group_b_h == "Negative",
#         reset_group == "Continuous") %>%
#  select(avg_both_asr_b) %>%
#  unnest(c(avg_both_asr_b)) %>%
#  mean_SEM_plots_by_Outcome(0,200))

#if (save_figures==1) {
#  ggsave(file = "plots/NegNeg_Continuous_PI_justposition.png", width = 4.5, height = 2.5)
#}

```

3. Subset data by group then average rates for plotting          **Negative Negative Reset**
```{r}
(NegNegR_plot <- position_neurons %>%
  filter(lm_group_b == "Negative",
         lm_group_b_h == "Negative",
         reset_group == "Reset") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
 ggsave(file = "plots/NegNeg_Reset_PI_justposition.png", width = 4.5, height = 2.5) 
}

```

4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
(PosPosC_plot <- position_neurons %>%
  filter(lm_group_b == "Positive",
         lm_group_b_h == "Positive",
         reset_group == "Continuous") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))


if (save_figures==1) {
  ggsave(file = "plots/PosPos_Continuous_PI_justposition.png", width = 4.5, height = 2.5)
}

```

5. Subset data by group then average rates for plotting          **Positive Positive Reset**
```{r}
(PosPosR_plot <- position_neurons %>%
  filter(lm_group_b == "Positive",
         lm_group_b_h == "Positive",
         reset_group == "Reset") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/PosPos_Reset_PI_justposition.png", width = 4.5, height = 2.5)
}

```

6. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(PosUC_plot <- position_neurons %>%
  filter(lm_group_b == "Positive",
         lm_group_b_h == "Negative") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))


if (save_figures==1) {
  ggsave(file = "plots/PosNeg_PI_justposition.png", width = 4.5, height = 2.5)
}

```

7. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(NegUC_plot <- position_neurons %>%
  filter(lm_group_b == "Negative",
         lm_group_b_h == "Positive") %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))



if (save_figures==1) {
  ggsave(file = "plots/NegPos_PI_justposition.png", width = 4.5, height = 2.5)
}

```






Repeat above plots but for acceleration encoding neurons

1. Split data based on cue independant/cue dependant (Figure 5) and acceleration encoding group (Figure 3) as we are only interested in these neurons here
```{r}
accel_neurons <- filter(spatial_firing, final_model_o_b == "A",  lm_group_b == "Positive" | lm_group_b == "Negative")
```

2. separate based on whether they have a positive or negative relationship with acceleration
```{r}
accel_neurons_pos <- filter(accel_neurons, o_b_mod_coefs_accel > 0)
accel_neurons_neg <- filter(accel_neurons, o_b_mod_coefs_accel < 0)
```


3. Subset data by group then average rates for plotting  **Negative coefficient with acceleration**
```{r}
(Accel_Neg_plot <- accel_neurons %>%
  filter(o_b_mod_coefs_accel < 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/negative_relationship_waccel.png", width = 4.5, height = 2.5)
}

```


3. Subset data by group then average rates for plotting **Positive coefficient with acceleration**
```{r}
(Accel_Pos_plot <- accel_neurons %>%
  filter(o_b_mod_coefs_accel > 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/positive_relationship_waccel.png", width = 4.5, height = 2.5)
}
```







Repeat above plots but for all acceleration encoding neurons, regardless of Figure 2 classification

1. Split data based on acceleration encoding group (Figure 3) as we are only interested in these neurons here
```{r}
all_accel_neurons <- filter(spatial_firing, final_model_o_b == "A")
```

2. separate based on whether they have a positive or negative relationship with acceleration
```{r}
accel_neurons_pos <- filter(all_accel_neurons, o_b_mod_coefs_accel > 0)
accel_neurons_neg <- filter(all_accel_neurons, o_b_mod_coefs_accel < 0)
```



3. Subset data by group then average rates for plotting **Negative coefficient with acceleration**
```{r}
(All_Accel_Neg_plot <- all_accel_neurons %>%
  filter(o_b_mod_coefs_accel < 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))


if (save_figures==1) {
  ggsave(file = "plots/negative_relationship_wallaccel.png", width = 4.5, height = 2.5)
}

```


3. Subset data by group then average rates for plotting **Positive coefficient with acceleration**
```{r}
(All_Accel_Pos_plot <- all_accel_neurons %>%
  filter(o_b_mod_coefs_accel > 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/positive_relationship_wallaccel.png", width = 4.5, height = 2.5)
}
```





Repeat above plots but for speed encoding neurons

1. Split data based on positive/negative slope (Figure2) and speed encoding group (Figure 3) as we are only interested in these neurons here
```{r}
speed_neurons <- filter(spatial_firing, final_model_o_b == "S",  lm_group_b == "Positive" | lm_group_b == "Negative")
```

2.seperate based on whether they have a positive or negative relationship with speed
```{r}
speed_neurons_pos <- filter(speed_neurons, o_b_mod_coefs_speed > 0)
speed_neurons_neg <- filter(speed_neurons, o_b_mod_coefs_speed < 0)
```


3. Subset data by group then average rates for plotting          **Negative coefficient with speed**
```{r}
(Speed_Neg_plot <- speed_neurons %>%
  filter(o_b_mod_coefs_speed < 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/negative_relationship_wspeed.png", width = 4.5, height = 2.5)
}

```


3. Subset data by group then average rates for plotting          **Positive coefficient with speed**
```{r}
(Speed_Pos_plot <- speed_neurons %>%
  filter(o_b_mod_coefs_speed > 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/positive_relationship_wspeed.png", width = 4.5, height = 2.5)
}
```




Repeat above plots but for speed encoding neurons, regardless of classification in Figure 2.

1. Split data based on speed encoding group (Figure 3) as we are only interested in these neurons here
```{r}
all_speed_neurons <- filter(spatial_firing, final_model_o_b == "S" | final_model_o_b == "SA" | final_model_o_b == "A")
```

2.seperate based on whether they have a positive or negative relationship with speed
```{r}
all_speed_neurons_pos <- filter(all_speed_neurons, o_b_mod_coefs_speed > 0)
all_speed_neurons_neg <- filter(all_speed_neurons, o_b_mod_coefs_speed < 0)
```


3. Subset data by group then average rates for plotting          **Negative coefficient with speed**
```{r}
(All_Speed_Neg_plot <- all_speed_neurons %>%
  filter(o_b_mod_coefs_speed < 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/negative_relationship_wallspeed.png", width = 4.5, height = 2.5)
}
```


3. Subset data by group then average rates for plotting          **positive coefficient with speed**
```{r}
(All_Speed_Pos_plot <- all_speed_neurons %>%
  filter(o_b_mod_coefs_speed > 0) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b)) %>%
  mean_SEM_plots_by_Outcome(0,200))

if (save_figures==1) {
  ggsave(file = "plots/positive_relationship_wallspeed.png", width = 4.5, height = 2.5)
}
```





### ------------------------------------------------------------------------------------------ ### 

## plot violin plots of mean apsolute difference between predicted and real

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone


1. extract only neurons that are positive or negative in the outbound zone (as determined by Figure 2) and subset based on position encoding (Figure 3) and are ++ or -- in beaconed trials
```{r}
df <- spatial_firing %>%
  filter(final_model_o_b == "P") %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(track_category == "pospos" | track_category == "negneg") 
  
```


```{r}
data <- tibble(session_id = rep(unlist(df$unique_id), times=3), 
                    cluster_id = rep(df$cluster_id, times=3), 
                    predict = c(as.numeric(df$predict_diff),
                             as.numeric(df$predict_diff_run),
                             as.numeric(df$predict_diff_try)),
                    type = rep(c("Hit", "Run", "Try"),
                                    each = nrow(df)),
                    lm_group_b = rep(as.character(df$lm_group_b), times=3))

```

2. Plot bar charts 
```{r}
ggplot(data=subset(data,lm_group_b == "Negative"), aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-3.5,5.5)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_fig7_neg_JustPosition.png",width = 4, height = 2.5)
}


ggplot(data=subset(data, lm_group_b == "Positive"), aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-4,3)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_fig7_pos_JustPosition.png",width = 4, height = 2.5)
}
```


2. run anova
```{r}
data_pos <- data %>%
  filter(lm_group_b == "Positive") 

one.way <- aov(predict ~ type, data = data_pos)
summary(one.way)

data_neg <- data %>%
  filter(lm_group_b == "Negative") 

one.way <- aov(predict ~ type, data = data_neg)
summary(one.way)
```

```{r}
df <- spatial_firing %>%
  filter(final_model_o_b == "P" | final_model_o_b == "PA" | final_model_o_b == "PS" | final_model_o_b == "PSA") %>%
  filter(cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI") %>%
  filter(track_category == "pospos" | track_category == "negneg") 
  
```


```{r}
data <- tibble(session_id = rep(unlist(df$unique_id), times=3), 
                    cluster_id = rep(df$cluster_id, times=3), 
                    predict = c(as.numeric(df$predict_diff),
                             as.numeric(df$predict_diff_run),
                             as.numeric(df$predict_diff_try)),
                    type = rep(c("Hit", "Run", "Try"),
                                    each = nrow(df)),
                    lm_group_b = rep(as.character(df$lm_group_b), times=3))

```

2. Plot bar charts 
```{r}
ggplot(data=subset(data,lm_group_b == "Negative"), aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-3.5,5.5)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_fig7_neg_AllPosition.png",width = 4, height = 2.5)
}


ggplot(data=subset(data, lm_group_b == "Positive"), aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-4,3)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_fig7_pos_AllPosition.png",width = 4, height = 2.5)
}
```
2. run anova
```{r}
data_pos <- data %>%
  filter(lm_group_b == "Positive") 

one.way <- aov(predict ~ type, data = data_pos)
summary(one.way)

data_neg <- data %>%
  filter(lm_group_b == "Negative") 

one.way <- aov(predict ~ type, data = data_neg)
summary(one.way)
```

1. extract only neurons that are positive or negative in the outbound zone (as determined by Figure 2) and subset based on position encoding (Figure 3) and are ++ or -- in beaconed trials
```{r}
df <- spatial_firing %>%
  filter(final_model_o_b == "S" | final_model_o_b == "A" | final_model_o_b == "SA") %>%
  filter(track_category == "pospos" | track_category == "negneg") 

```


```{r}
data <- tibble(session_id = rep(unlist(df$unique_id), times=3), 
                    cluster_id = rep(df$cluster_id, times=3), 
                    predict = c(as.numeric(df$predict_diff),
                             as.numeric(df$predict_diff_run),
                             as.numeric(df$predict_diff_try)),
                    coef = c(as.numeric(df$o_b_mod_coefs_speed),
                             as.numeric(df$o_b_mod_coefs_speed),
                             as.numeric(df$o_b_mod_coefs_speed)),
                    type = rep(c("Hit", "Run", "Try"),
                                    each = nrow(df)),
                    lm_group_b = rep(as.character(df$lm_group_b), times=3))

```

2. Plot bar charts 
```{r}
ggplot(data=subset(data,lm_group_b == "Negative"), aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-3.5,5.5)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_fig7_neg_AllSpeed.png",width = 4, height = 2.5)
}

ggplot(data=subset(data,lm_group_b == "Positive"), aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-4,3)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=13), 
        legend.text=element_text(size=13), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))

if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_fig7_pos_AllSpeed.png",width = 4, height = 2.5)
}
```
2. run anova
```{r}
data_pos <- data %>%
  filter(lm_group_b == "Positive") 

one.way <- aov(predict ~ type, data = data_pos)
summary(one.way)

data_neg <- data %>%
  filter(lm_group_b == "Negative") 

one.way <- aov(predict ~ type, data = data_neg)
summary(one.way)
```