---
title: "Figure7"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### --------------------------------------------------------------------------------------- ###

## Differences in spatial firing between hit/rewarded and miss/unrewarded trials

We might want to see differences in the relationship between firing rate and position along the track between rewarded and non rewarded trials (i.e. hit and miss trials)


### --------------------------------------------------------------------------------------- ###

## Run average rates and compare hit and miss via an anova 


1. first combine hit and miss trials together with an indicator of rewarded/not rewarded
```{r}
join_rates <- function(hit, miss, session_id, cluster_id) {
  if (any(is.na(miss))) { 
    return(
      df <- tibble(Rates = NA, 
               Position = NA,
               Reward_indicator = NA)
    )
  }
  df <- tibble(Rates = c(unlist(hit), unlist(miss)), Reward_indicator = c(rep(1, times=200), rep(0, times=200)), Position = c(rep(1:200), rep(1:200)))
  return (df)
}

spatial_firing <- spatial_firing %>%
  mutate(avg_both_asr_b = pmap(list(Rates_averaged_rewarded_b,Rates_averaged_failed_b, session_id, cluster_id), join_rates))

```

2. Run lm and compare models without reward to models with via anova
_extract both slope and intercept significance_
matt : this could probably be reduced to one function using your unnest_wider function. 
```{r}
compare_models_slope <- function(df, miss){
 # Check for NAs
  if (any(is.na(miss))) {
    return(NA)
  }
 df <- df %>%
  filter(Position > 30, Position < 90)
  fit <- lme4::lmer(Rates ~ Position * Reward_indicator + (Position||Reward_indicator), data = df, na.action = na.omit, REML = FALSE) # more complicated model
  prtAnova <- car::Anova(fit, type="II")
  return (prtAnova$"Pr(>Chisq)"[3][1])
}
```

3. Run lm on all cells and extract anova pval
```{r}
spatial_firing <- spatial_firing %>%
  mutate(avg_pval_slope = map2(avg_both_asr_b, Rates_averaged_failed_b, compare_models_slope))

```


### tag cells based on either slope or intercept significance
1. make function
```{r}
mark_neurons_sig <- function(pval){
  if (any(is.na(pval))) {
    return(NA)
  }
  if( pval < 0.01) {
    return( "Significant" )
  } else if( pval >= 0.01) {
    return( "Not-Significant" )
  } else {
    return("None")
  }
}
```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reward_interaction_id = map(avg_pval_slope, mark_neurons_sig))
```


### ----------------------------------------------------------------------------- ###

## extract slope, r.squared vlaue and pval for failed trials

# Run simple linear model to examine relationship between firing rate and position in failed trials
_note:for now we are only interested in the outbound region of the track (30 - 90 cm)_

1. Average trials with no reward

input columns: 
Rates_averaged_failed_b = beaconed trials
```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_failed = pmap(list(Rates_averaged_failed_b, session_id, cluster_id), add_position)
         )
```

3. run lm on all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_o_failed_fit_')) %>%
  mutate(asr_b_o_failed_fit = pmap(list(asr_b_failed, 30, 90), lm_helper)) %>%
  unnest_wider(asr_b_o_failed_fit, names_sep = "_", names_repair = "universal")

```

Linear model results are stored in:
spatial_firing$asr_b_o_failed_fit_pval
spatial_firing$asr_b_o_failed_fit_slope
spatial_firing$asr_b_o_failed_fit_r.squared

4. subset by outbound ramps
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
```

5. Plot slope coefficient from linear model for both failed and rewarded trials
```{r}
ggplot(data=ramps, aes(x = asr_b_o_rewarded_fit_slope,
                                y = asr_b_o_failed_fit_slope, 
                                fill = factor(unlist(reward_interaction_id)),
                                color = factor(unlist(reward_interaction_id)))) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red")) +
    scale_color_manual(values=c("grey", "red")) +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/reward_vs_failed_slope_rampcells.png", width = 5, height = 5)
```
,

6. Plot slope coefficient from linear model for both failed and rewarded trials
_just looking at neurons that are significant for slope between rewarded/failed_
```{r}
ggplot(data=ramps, 
       aes(x = asr_b_o_rewarded_fit_slope,
           y = asr_b_o_failed_fit_slope, 
           fill = factor(unlist(reward_interaction_id)),
           color = factor(unlist(reward_interaction_id)))) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red")) +
    scale_color_manual(values=c("grey", "red")) +
    xlab("\nslope") +
    ylab("slope") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/reward_vs_failed_slope_slopesignificantcells.png", width = 5, height = 5)
```

### ----------------------------------------------------------------------------------------- ###

## Now we want to examine if there are differences in the reset activity between failed and rewarded trials

To do this, we can plot population rate for rewarded and failed trials across whole track 

1. Split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in these neurons here
```{r}
position_neurons <- filter(spatial_firing, cue_group_o == "Positive-PI" | cue_group_o == "Negative-PI",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

Function to plot data mean and SD of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SD_plots <- function(df, group_b, group_nb, track_group, x_start = 30, x_end = 90){

 df <- df %>%
  filter(lm_group_b == group_b,
         lm_group_nb == group_nb, 
         reset_group == track_group) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b))
 
 df$Rates <- as.double(df$Rates)

 df <- df %>%
   group_by(Position, Reward_indicator) %>%
   dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE),
             se_b = std.error(Rates, na.rm = TRUE))
 
 ggplot(data=df) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b,
                  fill=factor(Reward_indicator), color=factor(Reward_indicator)), alpha=0.2) +
   geom_line(aes(y=mean_b, x=Position, color=factor(Reward_indicator))) +
   scale_fill_manual(values=c("grey", "red")) +
   scale_color_manual(values=c("grey", "red")) +
   theme_classic() +
   labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
   theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```

2. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Negative", "Continuous",  0, 200))
ggsave(file = "plots/AverageRates_NegNeg_Continuous_failed_PI.png", width = 3.5, height = 2.5)
```
2. Subset data by group then average rates for plotting          **Negative Negative Reset**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Negative", "Reset",  0, 200))
ggsave(file = "plots/AverageRates_NegNeg_Reset_failed_PI.png", width = 3.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Continuous", 0, 200))
ggsave(file = "plots/AverageRates_PosPos_Continuous_failed.png", width = 3.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive Positive Reset**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Reset", 0, 200))
ggsave(file = "plots/AverageRates_PosPos_Reset_failed.png", width = 3.5, height = 2.5)
```


4. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(PosPos_plot <- mean_SD_plots(position_neurons, "Positive", "Unclassified", "Reset", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_PosPI.png", width = 3.5, height = 2.5)
```


Same as above but here we look at failed and rewarded with failed split into run through trials and trials where it tries to stop, but does not get rewarded. 

Here we are curious if the ramps exist on run through trials.

First combine hit, miss run through and try trials together with an indicator of rewarded type
```{r}
join_rates <- function(hit, miss, run, try, session_id, cluster_id) {
  if (any(is.na(miss)) | any(is.na(run)) | any(is.na(try))) { 
    return(
      df <- tibble(Rates = NA, 
               Position = NA,
               Reward_indicator = NA)
    )
  }
  df <- tibble(Rates = c(unlist(hit), unlist(miss), unlist(run), unlist(try)), Reward_indicator = c(rep(1, times=200), rep(0, times=200), rep(2, times=200), rep(3, times=200)), Position = c(rep(1:200), rep(1:200), rep(1:200), rep(1:200)))
  return (df)
}

spatial_firing <- spatial_firing %>%
  mutate(avg_both_asr_b = pmap(list(Rates_averaged_rewarded_b,Rates_averaged_failed_b, Rates_averaged_runthru_b, Rates_averaged_try_b, session_id, cluster_id), join_rates))

```


Now we want to examine if there are differences in the reset activity between these trials

To do this, we can plot population rate trials across whole track, split by reward id

1. First, split data based on cue independant/cue dependant (Figure 5) and encoding group (Figure 3) as we are only interested in these neurons here
```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative", final_model_o_b == "A" | final_model_o_b == "S" | final_model_o_b == "SA" )
```

#final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA"

Function to plot data mean and SD of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SD_plots <- function(df, group_b, group_nb, track_group, x_start = 30, x_end = 90){

 df <- df %>%
  filter(lm_group_b == group_b,
         lm_group_nb == group_nb, 
         reset_group == track_group) %>%
  select(avg_both_asr_b) %>%
  unnest(c(avg_both_asr_b))
 
 df$Rates <- as.double(df$Rates)

 df <- df %>%
   group_by(Position, Reward_indicator) %>%
   dplyr::summarise(mean_b = mean(Rates, na.rm = TRUE),
             se_b = std.error(Rates, na.rm = TRUE))
 
 ggplot(data=df) +
  annotate("rect", xmin=0, xmax=30, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=170, xmax=200, ymin=5,ymax=Inf, alpha=0.2, fill="Grey60") +
  annotate("rect", xmin=90, xmax=110, ymin=5,ymax=Inf, alpha=0.2, fill="Chartreuse4") +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b,
                  fill=factor(Reward_indicator)), alpha=0.1) +
   geom_line(aes(y=mean_b, x=Position, color=factor(Reward_indicator)), alpha=0.5) +
   scale_fill_manual(values=c("black", "red", "blue", "green")) +
   scale_color_manual(values=c("black", "red", "blue", "green")) +
   scale_x_continuous(breaks=seq(0,200,100), expand = c(0, 0)) +
   scale_y_continuous(breaks=seq(5,25,5), expand = c(0, 0)) +
   theme_classic() +
   labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
   theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```

2. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Negative", "Continuous",  0, 200))
ggsave(file = "plots/AverageRates_NegNeg_Continuous_Speed_cells.png", width = 3.5, height = 2.5)
```

3. Subset data by group then average rates for plotting          **Negative Negative Reset**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Negative", "Reset",  0, 200))
ggsave(file = "plots/AverageRates_NegNeg_Reset_Speed_cells.png", width = 3.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Continuous", 0, 200))
ggsave(file = "plots/AverageRates_PosPos_Continuous_Speed_cells.png", width = 3.5, height = 2.5)
```

5. Subset data by group then average rates for plotting          **Positive Positive Reset**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Reset", 0, 200))
ggsave(file = "plots/AverageRates_PosPos_Reset_Speed_cells.png", width = 3.5, height = 2.5)
```