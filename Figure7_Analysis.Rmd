---
title: "Figure7"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### --------------------------------------------------------------------------------------- ###

## Differences in spatial firing between hit/rewarded and miss/unrewarded trials

We might want to see differences in the relationship between firing rate and position along the track between rewarded and non rewarded trials (i.e. hit and miss trials)


### --------------------------------------------------------------------------------------- ###

# 1st method : Trial by trial 
Here we combine hit and miss trials in a dataframe and mark by reward. Then run a linear mixed effect model which accounts for reward indicator and variation over trials

1. Write function to combine hit and miss trials in a dataframe and mark by reward 
```{r}
join_rates <- function(hit, miss, session_id, cluster_id) {
  if (ncol(miss) <= 2) { 
    print(paste0("No failed trials. Session: ", session_id, ". Cluster:", cluster_id))
    return(
      df <- tibble(Rates = NA, 
               Position = NA,
               Reward_indicator = NA,
               Trials = NA)
    )
  }
  df <- tibble(Rates = c(as.vector(hit), 
                         as.vector(miss)), 
               Position = c(rep(1:200, times = ncol(hit)), 
                            rep(1:200, times = ncol(miss))),
               Reward_indicator = c(rep(1, times=ncol(hit)*nrow(hit)), 
                                    rep(0, times=ncol(miss)*nrow(miss))),
               Trials = c(rep(1:ncol(hit), times = 200),
                         rep(1:ncol(miss), times = 200))
               )
  
  return (df)
}

```

2. run on all cells _just beaconed trials_
```{r}
spatial_firing <- spatial_firing %>%
  mutate(both_asr_b = pmap(list(Firing_rate_rewarded_b, Firing_rate_failed_b, session_id, cluster_id), join_rates))
```

3. Run lmer and extract slope significance / pvals using car Anova package.
_here we are looking to see if the slope is significantly different between rewarded and non rewarded trials_
```{r}
return_slope_interaction <- function(df, miss) {
 # Check for NAs
  if (any(is.na(df$Rates))) {
    return(NA)
  }
  if (ncol(miss) <= 2) { # check if there is 2 or less failed trials
    return(NA)
  }
  df <- df %>%
    subset(Position >= 30 & Position <= 90)
  fit <- lme4::lmer(Rates ~ Position * Reward_indicator + (Position||Reward_indicator) + (1|Trials), data = df, na.action = na.omit, REML = FALSE) 
  prtAnova <- car::Anova(fit, type="II")
  return(prtAnova$"Pr(>Chisq)"[3][1])
}

```

4. Run lm on all cells  & extract pvql for slope 
```{r}
spatial_firing <- spatial_firing %>%
  mutate(pval_slope_interaction = map2(both_asr_b, Firing_rate_failed_b, return_slope_interaction))

```

5. Run lmer and extract intercept significance / pvals using car Anova package.
_here we are looking to see if the intercept is significantly different between rewarded and non rewarded trials_
```{r}
return_intercept_interaction <- function(df, miss) {
 # Check for NAs
  if (any(is.na(df$Rates))) {
    return(NA)
  }
  if (ncol(miss) <= 2) { # check if there is 2 or less failed trials
    return(NA)
  }
  # Run lmer
  df <- df %>%
    subset(Position >= 30 & Position <= 90)
  fit <- lme4::lmer(Rates ~ Position * Reward_indicator + (Position||Reward_indicator)+ (1|Trials), data = df, na.action = na.omit, REML = FALSE) 
  prtAnova <- car::Anova(fit, type="II")
  return(prtAnova$"Pr(>Chisq)"[2][1])
}
```

6. Run lm on all cells & extract pvql for intercept 
```{r}
spatial_firing <- spatial_firing %>%
  mutate(pval_intercept_interaction = map2(both_asr_b, Firing_rate_failed_b, return_intercept_interaction))

```


### Classify cells based on significance
Now we want to see which cells have significantly different firing rates between rewarded/notrewarded trials. Taking into account slope and intercept significance 

1. make function
```{r}
mark_significance <- function(pval){
 # Check for NAs
  if (is.na(pval)) {
    return(NA)
  }

    if( pval < 0.05) {
    return( "Significant" )
  } else if( pval >= 0.05) {
    return( "Not-Significant" )
  } else {
    return("None")
  }
}

```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(sig_slope = map(pval_slope_interaction, mark_significance)) %>%
  mutate(sig_intercept = map(pval_intercept_interaction, mark_significance))

```


### -------------------------------------------------------------------------------------------- ###


## Plot distribution of slopes of significant and non signifncant ramps

1. First extract significant ramps
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
significant_ramps <- subset(ramps, sig_slope == "Significant" | sig_intercept == "Significant")

```

2. extract data for all ramp cells in a tibble

```{r}
lm_results <- tibble(Ramp_type = as.character(ramps$lm_group_b),
    Slopes = ramps$asr_b_o_rewarded_fit_slope, 
    r2 = ramps$asr_b_o_rewarded_fit_r.squared, 
    id = ramps$cluster_id)
```

3. do the same for significant ramps
```{r}
lm_results_ramps <- tibble(Ramp_type = as.character(significant_ramps$lm_group_b),
    Slopes = significant_ramps$asr_b_o_rewarded_fit_slope, 
    r2 = significant_ramps$asr_b_o_rewarded_fit_r.squared, 
    id = significant_ramps$cluster_id)
```

4. Plot distribution of slope and r.squared values for all data, marked by whether the cells are significantly influenced by reward
```{r}
lm_plot_end <- ggplot(data=lm_results_ramps, aes(x = Slopes, y = r2, color=factor(Ramp_type))) + 
    coord_cartesian(xlim = c(-0.6,0.6), ylim = c(0,1)) +
    geom_point() +
    geom_point(data=lm_results, aes(x = Slopes, y = r2), color='grey') +
    geom_point(data=lm_results_ramps, aes(x = Slopes, y = r2, color=factor(Ramp_type))) +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    scale_color_manual(values=c("red", "red", "red")) +
    theme(axis.text.x = element_text(size=16),
          axis.text.y = element_text(size=16),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/lm_plot_rewards.png", width = 5, height = 6)
```


## Find proportions for above - significiant and non-significant 

1. extract outbound ramps
```{r}
# extracting diff models 
pos <-subset(spatial_firing, lm_group_b == "Positive")
neg <-subset(spatial_firing, lm_group_b == "Negative")
none <-subset(spatial_firing, lm_group_b == "Unclassified")

```

2. extract significant ramps
```{r}
sig_positive<- nrow(subset(pos, sig_slope == "Significant" |  sig_intercept == "Significant"))/nrow(pos)*100
notsig_positive <- nrow(subset(pos, sig_slope != "Significant" &  sig_intercept != "Significant" ))/nrow(pos)*100

sig_negative <- nrow(subset(neg, sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(neg)*100
notsig_negative <- nrow(subset(neg, sig_slope != "Significant" &  sig_intercept != "Significant" ))/nrow(neg)*100
```

3. Put in tibble
```{r}
proportions_mixed_ramps <- tibble(perc=c(sig_negative, notsig_negative, sig_positive, notsig_positive), ramp_id= c("Sig", "Not", "Sig", "Not"),ramp_type = c("Negative", "Negative", "Positive", "Positive"))

```

4. Plot results
```{r}
ggplot(proportions_mixed_ramps, aes(x= ramp_type, y = perc, fill=factor(ramp_id))) +
  coord_cartesian(ylim = c(0,100), xlim=(NULL)) +
  geom_bar(stat="identity",width = 0.9, alpha = .4) +
  labs(y = "Percent") +
  scale_fill_manual(values=c("grey62", "red")) +
  theme_classic() +
  theme(axis.text.x = element_text(size=18),
        axis.text.y = element_text(size=18),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=18), 
        legend.text=element_text(size=18), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/LMStart_cellproportions_hitmiss.png", width = 3, height = 6)

```


## plot same as above, but with cells colored by their group (P, PA etc)
1. subset by encoding models 
```{r}
pos <-subset(spatial_firing, final_model_o_b == "P")
speed <-subset(spatial_firing, final_model_o_b == "S")
ccel<-subset(spatial_firing, final_model_o_b == "A")
posspeed <-subset(spatial_firing, final_model_o_b == "PS")
posaccel <-subset(spatial_firing, final_model_o_b == "PA")
speedaccel <-subset(spatial_firing, final_model_o_b == "SA")
posspeedaccel <-subset(spatial_firing, final_model_o_b == "PSA")

```

2. find proportions.
```{r}
sig_p <- nrow(subset(pos, sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(pos)*100
sig_s <- nrow(subset(speed, sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(speed)*100
sig_a <- nrow(subset(ccel, sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(ccel)*100
sig_ps <- nrow(subset(posspeed,sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(posspeed)*100
sig_pa <- nrow(subset(posaccel, sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(posaccel)*100
sig_sa <- nrow(subset(speedaccel, sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(speedaccel)*100
sig_psa <- nrow(subset(posspeedaccel,sig_slope == "Significant" |  sig_intercept == "Significant" ))/nrow(posspeedaccel)*100

notsig_p <- nrow(subset(pos, sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(pos)*100
notsig_s <- nrow(subset(speed, sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(speed)*100
notsig_a <- nrow(subset(ccel, sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(ccel)*100
notsig_ps <- nrow(subset(posspeed, sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(posspeed)*100
notsig_pa <- nrow(subset(posaccel, sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(posaccel)*100
notsig_sa <- nrow(subset(speedaccel,sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(speedaccel)*100
notsig_psa <- nrow(subset(posspeedaccel, sig_slope != "Significant" &  sig_intercept != "Significant"))/nrow(posspeedaccel)*100

```

3. put into tibble
```{r}
mixed_ramps <- tibble(perc=c(sig_p,notsig_p,sig_s, notsig_s, sig_a,notsig_a,  sig_ps, notsig_ps, sig_pa, notsig_pa, sig_sa, notsig_sa, sig_psa,notsig_psa), 
                      
                      ramp_id= c("P","P", 
                                 "S", "S", 
                                 "A", "A",
                                 "PS", "PS", 
                                 "PA", "PA", 
                                 "SA", "SA", 
                                 "PAS", "PAS"), 
                      ramp_type= c("Sig", "Not Sig","Sig", "Not Sig", "Sig", "Not Sig","Sig", "Not Sig","Sig", "Not Sig","Sig", "Not Sig", "Sig", "Not Sig" ))


```

4. Plot model results
```{r}
# plot data
level_order <- c("P", "S", "A", "PS", "PA", "SA", "PAS", "None")
ggplot(mixed_ramps, aes(x= factor(ramp_id, level = level_order), y = perc, fill=factor(ramp_type))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons identified using LM") +
  scale_fill_manual(values=c("grey","red")) +
  theme_classic() +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/cell_proportions-lmmodel_signeurons.png", width = 3, height =5)


```


### -------------------------------------------------------------------------------------------- ###

We might also want to visualise the coefficients for the significant and non significant datasets as a histogram.

1. First seperate significant and non significant ramps
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
significant_ramps <- subset(ramps, sig_slope == "Significant" | sig_intercept == "Significant")
nonsignificant_ramps <- subset(ramps, sig_slope != "Significant" & sig_intercept != "Significant")

```

2. Then make stacked histogram of slope values for significant dataset
```{r}
ggplot(data=significant_ramps, aes(x= asr_b_o_rewarded_fit_slope, fill="red")) +
  coord_cartesian(xlim = c(-0.6,0.6)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01) +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/Histogram_sig_slopes.png", width = 4.5, height = 2)

```

3. same as above but for not significant datasets
```{r}
ggplot(data=nonsignificant_ramps, aes(x= asr_b_o_rewarded_fit_slope, fill="grey")) +
  coord_cartesian(xlim = c(-0.6,0.6)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01, fill="Grey") +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
ggsave(file = "plots/Histogram_notsig_slopes.png", width = 4.5, height = 2)
```


4. Make stacked histogram of rsquared values for significant dataset
```{r}
ggplot(data=significant_ramps, aes(x= asr_b_o_rewarded_fit_r.squared, fill="red")) +
  coord_cartesian(xlim = c(0,1)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01) +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/sig_r2_histogram.png", width = 4.5, height = 2)


```

4. Same as above but for shuffled datasets

```{r}
ggplot(data=nonsignificant_ramps, aes(x= asr_b_o_rewarded_fit_r.squared, fill="Grey")) +
  coord_cartesian(xlim = c(0,1)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01, fill="Grey") +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/nonsig_r2_histogram.png", width = 4.5, height = 2)
```



### -------------------------------------------------------------------------------------------- ###

### -------------------------------------------------------------------------------------------- ###



## Method 2 : Run average rates and compare hit and miss via an anova 


1. first combine hit and miss trials together with an indicator of rewarded/not rewarded
```{r}
join_rates <- function(hit, miss, session_id, cluster_id) {
  if (any(is.na(miss))) { 
    return(
      df <- tibble(Rates = NA, 
               Position = NA,
               Reward_indicator = NA)
    )
  }
  df <- tibble(Rates = c(unlist(hit[31:90]), unlist(miss[31:90])), Reward_indicator = c(rep(1, times=60), rep(0, times=60)), Position = c(rep(31:90), rep(31:90)))
  return (df)
}

spatial_firing <- spatial_firing %>%
  mutate(avg_both_asr_b = pmap(list(Rates_averaged_rewarded_b,Rates_averaged_failed_b, session_id, cluster_id), join_rates))

```

2. Run lm and compare models without reward to models with via anova
_extract both slope and intercept significance_
matt : this could probably be reduced to one function using your unnest_wider function. 
```{r}
compare_models_slope <- function(df, miss){
 # Check for NAs
  if (any(is.na(miss))) {
    return(NA)
  }
  fit <- lme4::lmer(Rates ~ Position * Reward_indicator + (Position||Reward_indicator), data = df, na.action = na.omit, REML = FALSE) # more complicated model
  prtAnova <- car::Anova(fit, type="II")
  return (prtAnova$"Pr(>Chisq)"[3][1])
}

compare_models_intercept <- function(df, miss){
   # Check for NAs
  if (any(is.na(miss))) {
    return(NA)
  }
  fit <- lme4::lmer(Rates ~ Position * Reward_indicator + (Position||Reward_indicator), data = df, na.action = na.omit, REML = FALSE) 
  prtAnova <- car::Anova(fit, type="II")
  return (prtAnova$"Pr(>Chisq)"[2][1])
}
```

3. Run lm on all cells and extract anova pval
```{r}
spatial_firing <- spatial_firing %>%
  mutate(avg_pval_slope = map2(avg_both_asr_b, Rates_averaged_failed_b, compare_models_slope)) %>%
  mutate(avg_pval_intercept = map2(avg_both_asr_b, Rates_averaged_failed_b, compare_models_intercept))

```


### tag cells based on either slope or intercept significance
1. make function
```{r}
mark_neurons_sig <- function(pval){
  if (any(is.na(pval))) {
    return(NA)
  }
  if( pval < 0.01) {
    return( "Significant" )
  } else if( pval >= 0.01) {
    return( "Not-Significant" )
  } else {
    return("None")
  }
}
```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(avg_sig_slope = map(avg_pval_slope, mark_neurons_sig)) %>%
  mutate(avg_sig_intercept = map(avg_pval_intercept, mark_neurons_sig))

```

### overall tag - tag whether cells are significant regardless of slope or intercept
1. make function
```{r}
mark_neurons_sig <- function(slope, intercept){
  if (any(is.na(slope))) {
    return(NA)
  }
  if( slope == "Significant" | intercept == "Significant") {
    return( "Significant" )
  } else if( slope != "Significant" & intercept != "Significant" ) {
    return( "Not-Significant" )
  } else {
    return("None")
  }
}
```

2. run on all neurons
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reward_interaction_id = map2(avg_sig_slope, avg_sig_intercept, mark_neurons_sig))

```


### --------------------------------------------------------------------------------------------- ###

## Plot distribution of slopes of significant and non signifncant ramps

1. First extract all ramps, and then selectively significant ramps into different dataframes
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
significant_ramps <- subset(ramps, avg_sig_slope == "Significant" | sig_intercept == "Significant")

```

2. extract data for all ramp cells in a tibble
```{r}
lm_results <- tibble(Ramp_type = as.character(ramps$lm_group_b),
    Slopes = ramps$asr_b_o_rewarded_fit_slope, 
    r2 = ramps$asr_b_o_rewarded_fit_r.squared, 
    id = ramps$cluster_id)
```

3. do the same for just significant ramps
```{r}
lm_results_ramps <- tibble(Ramp_type = as.character(significant_ramps$lm_group_b),
    Slopes = significant_ramps$asr_b_o_rewarded_fit_slope, 
    r2 = significant_ramps$asr_b_o_rewarded_fit_r.squared, 
    id = significant_ramps$cluster_id)
```

4. Plot distribution of slope and r.squared values for all data, marked by whether the cells are significantly influenced by reward
```{r}
lm_plot_end <- ggplot(data=lm_results_ramps, aes(x = Slopes, y = r2, color=factor(Ramp_type))) + 
    coord_cartesian(xlim = c(-0.6,0.6), ylim = c(0,1)) +
    geom_point() +
    geom_point(data=lm_results, aes(x = Slopes, y = r2), color='grey') +
    geom_point(data=lm_results_ramps, aes(x = Slopes, y = r2, color=factor(Ramp_type))) +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    scale_color_manual(values=c("red", "red", "red")) +
    theme(axis.text.x = element_text(size=16),
          axis.text.y = element_text(size=16),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=16), 
          legend.text=element_text(size=16), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/lm_plot_rewards_m2.png", width = 5, height = 6)
```


5. Visualise the proportion of cells that fit the above criteria.  

We will focus here only on neurons classified as having a positive or negative slope in Figure 2. 

Function to return a tibble with proportions of neurons classified as significant or none-significant.
```{r}
calc_props_sig_dep <- function(reward_group, outbound){
  cue_group <- as.character(reward_group)
  num_positive_cells <- length(which(outbound == "Positive"))
  num_negative_cells <- length(which(outbound == "Negative"))

  sig_positive_num <- length(which(reward_group == "Significant" & outbound == "Positive"))
  sig_negative_num <- length(which(reward_group == "Significant" & outbound == "Negative"))
  notsig_positive_num <- length(which(reward_group != "Significant" & outbound == "Positive"))
  notsig_negative_num <- length(which(reward_group != "Significant" & outbound == "Negative"))
  
  sig_pos <- (sig_positive_num / num_positive_cells) *100
  sig_neg <- (sig_negative_num / num_negative_cells) *100
  notsig_pos <- (notsig_positive_num / num_positive_cells) *100
  notsig_neg <- (notsig_negative_num / num_negative_cells) *100

proportions_mixed_ramps <- tibble(perc=c(sig_neg, notsig_neg, sig_pos, notsig_pos), 
                                  ramp_id= c("Sig", "Not", "Sig", "Not"),
                                  ramp_type = c("Negative", "Negative", "Positive", "Positive"))
}
```

Calculate proportions for neurons with +/- ramps on beaconed trials.
```{r}
proportions_mixed_ramps <- calc_props_sig_dep(spatial_firing$reward_interaction_id, spatial_firing$lm_group_b)
```

6. Plot results
```{r}
ggplot(proportions_mixed_ramps, aes(x= ramp_type, y = perc, fill=factor(ramp_id))) +
  coord_cartesian(ylim = c(0,100), xlim=(NULL)) +
  geom_bar(stat="identity",width = 0.9, alpha = .4) +
  labs(y = "Percent") +
  scale_fill_manual(values=c("grey62", "red")) +
  theme_classic() +
  theme(axis.text.x = element_text(size=18),
        axis.text.y = element_text(size=18),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=18), 
        legend.text=element_text(size=18), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/LMStart_cellproportions_hitmiss_m2.png", width = 3, height = 6)

```


## plot same as above, but with cells colored by their group (P, PA etc)
1. subset by encoding models 
```{r}
pos <-subset(spatial_firing, final_model_o_b == "P")
speed <-subset(spatial_firing, final_model_o_b == "S")
ccel<-subset(spatial_firing, final_model_o_b == "A")
posspeed <-subset(spatial_firing, final_model_o_b == "PS")
posaccel <-subset(spatial_firing, final_model_o_b == "PA")
speedaccel <-subset(spatial_firing, final_model_o_b == "SA")
posspeedaccel <-subset(spatial_firing, final_model_o_b == "PSA")

```

2. find proportions.
```{r}
sig_p <- nrow(subset(pos, avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(pos)*100
sig_s <- nrow(subset(speed, avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(speed)*100
sig_a <- nrow(subset(ccel, avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(ccel)*100
sig_ps <- nrow(subset(posspeed,avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(posspeed)*100
sig_pa <- nrow(subset(posaccel, avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(posaccel)*100
sig_sa <- nrow(subset(speedaccel, avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(speedaccel)*100
sig_psa <- nrow(subset(posspeedaccel,avg_sig_slope == "Significant" |  avg_sig_intercept == "Significant" ))/nrow(posspeedaccel)*100

notsig_p <- nrow(subset(pos, avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(pos)*100
notsig_s <- nrow(subset(speed, avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(speed)*100
notsig_a <- nrow(subset(ccel, avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(ccel)*100
notsig_ps <- nrow(subset(posspeed, avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(posspeed)*100
notsig_pa <- nrow(subset(posaccel, avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(posaccel)*100
notsig_sa <- nrow(subset(speedaccel,avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(speedaccel)*100
notsig_psa <- nrow(subset(posspeedaccel, avg_sig_slope != "Significant" &  avg_sig_intercept != "Significant"))/nrow(posspeedaccel)*100

```

3. put into tibble
```{r}
mixed_ramps <- tibble(perc=c(sig_p,notsig_p,sig_s, notsig_s, sig_a,notsig_a,  sig_ps, notsig_ps, sig_pa, notsig_pa, sig_sa, notsig_sa, sig_psa,notsig_psa), 
                      
                      ramp_id= c("P","P", 
                                 "S", "S", 
                                 "A", "A",
                                 "PS", "PS", 
                                 "PA", "PA", 
                                 "SA", "SA", 
                                 "PAS", "PAS"), 
                      ramp_type= c("Sig", "Not Sig","Sig", "Not Sig", "Sig", "Not Sig","Sig", "Not Sig","Sig", "Not Sig","Sig", "Not Sig", "Sig", "Not Sig" ))


```

4. Plot model results
```{r}
# plot data
level_order <- c("P", "S", "A", "PS", "PA", "SA", "PAS", "None")
ggplot(mixed_ramps, aes(x= factor(ramp_id, level = level_order), y = perc, fill=factor(ramp_type))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons identified using LM") +
  scale_fill_manual(values=c("grey","red")) +
  theme_classic() +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/cell_proportions-lmmodel_signeurons_m2.png", width = 3, height =5)


```


### -------------------------------------------------------------------------------------------- ###



We might also want to visualise the coefficients for the significant and non significant datasets as a histogram.

1. First seperate significant and non significant ramps
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
significant_ramps <- subset(ramps, avg_sig_slope == "Significant" | avg_sig_intercept == "Significant")
nonsignificant_ramps <- subset(ramps, avg_sig_slope != "Significant" & avg_sig_intercept != "Significant")

```

2. Then make stacked histogram of slope values for significant dataset
```{r}
ggplot(data=significant_ramps, aes(x= asr_b_o_rewarded_fit_slope, fill="red")) +
  coord_cartesian(xlim = c(-0.6,0.6)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01) +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/Histogram_sig_slopes_m2.png", width = 4.5, height = 2)

```

3. same as above but for not significant datasets
```{r}
ggplot(data=nonsignificant_ramps, aes(x= asr_b_o_rewarded_fit_slope, fill="grey")) +
  coord_cartesian(xlim = c(-0.6,0.6)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01, fill="Grey") +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
ggsave(file = "plots/Histogram_notsig_slopes_m2.png", width = 4.5, height = 2)
```


4. Make stacked histogram of rsquared values for significant dataset
```{r}
ggplot(data=significant_ramps, aes(x= asr_b_o_rewarded_fit_r.squared, fill="red")) +
  coord_cartesian(xlim = c(0,1)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01) +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/sig_r2_histogram_m2.png", width = 4.5, height = 2)


```

4. Same as above but for shuffled datasets

```{r}
ggplot(data=nonsignificant_ramps, aes(x= asr_b_o_rewarded_fit_r.squared, fill="Grey")) +
  coord_cartesian(xlim = c(0,1)) +
  geom_histogram(aes(y=..count../sum(..count..)), binwidth=0.01, fill="Grey") +
  ylab("Proportion") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=14),
        legend.title = element_blank(),
        legend.position = "none",
        text = element_text(size=14),
        legend.text=element_text(size=14),
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/nonsig_r2_histogram_m2.png", width = 4.5, height = 2)
```



### ----------------------------------------------------------------------------- ###

## extract slope, r.squared vlaue and pval for failed trials

### ----------------------------------------------------------------------------------------- ###

# Run simple linear model to examine relationship between firing rate and position in failed trials
_note:for now we are only interested in the outbound region of the track (30 - 90 cm)_

## Average firing rate (for LM modelling)
1. Write function to add position
```{r}
add_position <- function(df, session_id, cluster_id) {
  df <- tibble(Rates = unlist(df), Position = rep(1:200)) 
  if(all(is.na(df$Rates))){print(paste0("All NAs. Session: ", session_id, ". Cluster:", cluster_id))}
  df
}
```

2. Run on dataframe : Average trials with reward

input columns: 
Rates_averaged_failed_b = beaconed trials
```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_failed = pmap(list(Rates_averaged_failed_b, session_id, cluster_id), add_position)
         )
```

3. run lm on all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_o_failed_fit_')) %>%
  mutate(asr_b_o_failed_fit = pmap(list(asr_b_failed, 30, 90), lm_helper)) %>%
  unnest_wider(asr_b_o_failed_fit, names_sep = "_", names_repair = "universal")

```

Linear model results are stored in:
spatial_firing$asr_b_o_failed_fit_pval
spatial_firing$asr_b_o_failed_fit_slope
spatial_firing$asr_b_o_failed_fit_r.squared

4. subset by outbound ramps
```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
```

5. Plot slope coefficient from linear model for both failed and rewarded trials
```{r}
ggplot(data=ramps, aes(x = asr_b_o_rewarded_fit_slope,
                                y = asr_b_o_failed_fit_slope, 
                                fill = factor(unlist(reward_interaction_id)),
                                color = factor(unlist(reward_interaction_id)))) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red")) +
    scale_color_manual(values=c("grey", "red")) +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/reward_vs_failed_slope_rampcells.png", width = 5, height = 5)
```
,

6. Plot slope coefficient from linear model for both failed and rewarded trials
_just looking at neurons that are significant for slope between rewarded/failed_
```{r}
ggplot(data=ramps, 
       aes(x = asr_b_o_rewarded_fit_slope,
           y = asr_b_o_failed_fit_slope, 
           fill = factor(unlist(avg_sig_slope)),
           color = factor(unlist(avg_sig_slope)))) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red")) +
    scale_color_manual(values=c("grey", "red")) +
    xlab("\nslope") +
    ylab("slope") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/reward_vs_failed_slope_slopesignificantcells.png", width = 5, height = 5)
```

7. Plot coefficients of model (slope and r2 value) for just intercept significant neurons
```{r}
ggplot(data=ramps, 
       aes(x = asr_b_o_rewarded_fit_intercept,
           y = asr_b_o_failed_fit_intercept, 
           fill = factor(unlist(avg_sig_intercept)),
           color = factor(unlist(avg_sig_intercept)))) +
    geom_point(alpha=0.3) +
    scale_fill_manual(values=c("grey", "red")) +
    scale_color_manual(values=c("grey", "red")) +
    xlab("\nintercept") +
    ylab("intercept") +
    theme_classic() +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/reward_vs_failed_slope_interceptsignificantcells.png", width = 5, height = 5)
```

### ----------------------------------------------------------------------------------------- ###

## Now we want to examine if there are differences in the reset activity between failed and rewarded trials

To do this, we can plot population rate for rewarded and failed trials across whole track 

Function to plot data mean and SD of the population data based on the classification, as per Figure 2, on beaconed and non-beaconed trials.
```{r}
mean_SD_plots <- function(df, group_b, group_nb, track_group, x_start = 30, x_end = 90){
  df <- df %>%
    filter(lm_group_b == group_b,
           lm_group_nb == group_nb, 
           reset_group == track_group) %>%
    select(Rates_averaged_rewarded_b, Rates_averaged_failed_b, cue_group_o) %>%
    unnest(c(Rates_averaged_rewarded_b, Rates_averaged_failed_b))
 df$Rates_averaged_rewarded_b <- as.double(df$Rates_averaged_rewarded_b)
 df$Rates_averaged_failed_b <- as.double(df$Rates_averaged_failed_b)
 df$cue_group_o <- as.character(df$cue_group_o)
 numcells <- length(df$Rates_averaged_failed_b)/200
 df$Position <- rep(1:200, times = numcells)
 
 df <- df %>%
   group_by(cue_group_o, Position) %>%
   summarise(mean_b = mean(Rates_averaged_rewarded_b, na.rm = TRUE),
             mean_failed = mean(Rates_averaged_failed_b, na.rm = TRUE),
             se_b = std.error(Rates_averaged_rewarded_b, na.rm = TRUE),
             se_failed = std.error(Rates_averaged_failed_b, na.rm = TRUE))
 
 ggplot(data=df) +
  geom_ribbon(aes(x=Position, y=mean_b, ymin = mean_b - se_b, ymax = mean_b + se_b), fill = "grey70", alpha=0.2) +
  geom_ribbon(aes(x=Position, y=mean_failed, ymin = mean_failed - se_failed, ymax = mean_failed + se_failed), fill = "Red2", alpha=0.05) +
  geom_line(aes(y=mean_b, x=Position), color = "Grey32") +
  geom_line(aes(y=mean_failed, x=Position), color = "Red2") +
  theme_classic() +
  labs(y = "Mean firing rate (Hz)", x = "Position") +
   xlim(x_start, x_end) +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        legend.title = element_blank(),
        text = element_text(size=12))
}
```

1. Split data based on cue independant/cue dependant (cue_groups are as described in Figure5) and encoding group
```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative",
                           final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

2. Subset data by group then average rates for plotting          **Negative Negative Continuous**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Unclassified", "Continuous",  0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_NegCue.png", width = 3.5, height = 2.5)
```
2. Subset data by group then average rates for plotting          **Negative Negative Reset**
```{r}
(NegUC_plot <- mean_SD_plots(position_neurons, "Negative", "Unclassified", "Reset",  0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_NegCue.png", width = 3.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive Positive Continuous**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Continuous", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_PosCue.png", width = 3.5, height = 2.5)
```
4. Subset data by group then average rates for plotting          **Positive Positive Reset**
```{r}
(PosUC_plot <- mean_SD_plots(position_neurons, "Positive", "Positive", "Reset", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_PosCue.png", width = 3.5, height = 2.5)
```


4. Subset data by group then average rates for plotting          **Positive Unclassified**
```{r}
(PosPos_plot <- mean_SD_plots(position_neurons, "Positive", "Unclassified", "Reset", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_PosPI.png", width = 3.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Negative Unclassified**
```{r}
(NegNeg_plot <- mean_SD_plots(position_neurons, "Negative", "Unclassifid", "Reset", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_NegPI.png", width = 3.5, height = 2.5)
```


4. Subset data by group then average rates for plotting          **Negative PI only**
These data are not in position neurons so make a new data frame containing these neurons.
```{r}
unclassified_neurons <- filter(spatial_firing, lm_group_b == "Unclassified")
```

```{r}
(UCNeg_plot <- mean_SD_plots(unclassified_neurons, "Unclassified", "Negative", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)
```

4. Subset data by group then average rates for plotting          **Positive PI only**
```{r}
(UCPos_plot <- mean_SD_plots(unclassified_neurons, "Unclassified", "Positive", 0, 200))
# ggsave(file = "plots/AverageRates_PositionCells_NegPIonly.png", width = 3.5, height = 2.5)
```
