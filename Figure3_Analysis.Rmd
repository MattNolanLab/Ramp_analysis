---
title: "RampCodes_Figure3"
author: "Sarah Tennant & Matt Nolan"
date: "20/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### --------------------------------------------------------------------------------------- ###

## Differences in the positional dependance of firing between rewarded trials, run through trials and trials where the animal "tries" 

trial types :
1. rewarded/hit = animal recieves a reward
2. try = speed in the reward zone is within the 95% confidence interval of speed in the reward zone in
rewarded trials
3. run through = speed in the reward zone is outside the 95% confidence interval of speed in the reward zone in rewarded trials


### --------------------------------------------------------------------------------------- ###



First combine hit and miss trials together with an indicator of trial type (hit, try, run)

1. Generate firing rate tibble for each cell
```{r}
spatial_firing <- spatial_firing %>%
  mutate(both_asr_b_by_trial = pmap(list(spikes_in_time_reward, spikes_in_time_run, spikes_in_time_try, session_id, cluster_id), join_rates))

```


2. Run linear model on all cells and extract pval
To test just use the first two rows
```{r}
spatial_firing <- spatial_firing %>%
  mutate(pval_slope = pmap(list(both_asr_b_by_trial, Avg_FiringRate_RunTrials, Avg_FiringRate_TryTrials), compare_models_slope_glm))
```

Now we can classify cells based on their significance in the above model


3. Make new column to identify whether cells firings rates are significantly related to trial outcome
```{r}
spatial_firing <- spatial_firing %>%
  mutate(reward_interaction_id = map(pval_slope, mark_neurons_sig))

# Number of significant neurons
length(which(spatial_firing$reward_interaction_id == "Significant"))

# Number of non-significant neurons
length(which(spatial_firing$reward_interaction_id == "Not-Significant"))

# Other neurons
length(which(spatial_firing$reward_interaction_id == "None"))
```


### ----------------------------------------------------------------------------- ###

We also want to fit a simple linear model for each trial outcome separately so we can assess the slope and reward zone offset for each neuron.

1. Add position to data for try and run through trials (we already have coefficients for rewarded data from Figure 1). Function is the same as used in Figure 1.
```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_try = pmap(list(Avg_FiringRate_TryTrials, session_id, cluster_id), add_position),
         asr_b_run = pmap(list(Avg_FiringRate_RunTrials, session_id, cluster_id), add_position)
         )
```

2. Fit lm to data from all cells.
Removes any previously generated results (select), fits the data (mutate) and then adds model outputs as columns to spatial firing (unnest_wider).
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('asr_b_try_fit_')) %>%
  select(-contains('asr_b_run_fit_')) %>%
  mutate(asr_b_try_fit = pmap(list(asr_b_try, 30, 90), lm_tidy_helper)) %>%
  mutate(asr_b_run_fit = pmap(list(asr_b_run, 30, 90), lm_tidy_helper)) %>%
  unnest_wider(asr_b_try_fit, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(asr_b_run_fit, names_sep = "_", names_repair = "universal")

```

Linear model results are stored in:
spatial_firing$asr_b_try_fit_pval
spatial_firing$asr_b_try_fit_slope
spatial_firing$asr_b_try_fit_r.squared


### ----------------------------------------------------------------------------- ###

## Calculate offset for run and try trials

We want to find out if within the position and speed groups, is their firing rate reset or ous across the reward region?

To do this, we will predict the firing rate on the homebound zone from the activity in the outbound. Then find the difference between the predicted and real data to determine if cells have reset or continued. 

First, normalise firing rates. 
```{r}
spatial_firing <- spatial_firing %>%
  mutate(normalised_rates_try = map(Avg_FiringRate_TryTrials, normalise_rates), 
         normalised_rates_run = map(Avg_FiringRate_RunTrials, normalise_rates),
         normalised_rates_hit = map(Avg_FiringRate_HitTrials, normalise_rates))
```

Then, predict firing rate in homebound region based on fit from real data in outbound region

Predict mean and confidence intervals for firing rate at the start of the homebound zone (track positions 110 to 115 cm) based on firing in the outbound zone (30 to 90 cm).

The function predict_homebound was used previously for analyses for Figure 1.
```{r}
spatial_firing <- spatial_firing %>%
  select(-contains('predict_params_try_')) %>%
  select(-contains('predict_params_run_')) %>%
  mutate(predict_params_try = map(normalised_rates_try, predict_homebound),
         predict_params_run = map(normalised_rates_run, predict_homebound)) %>%
  unnest_wider(predict_params_try, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(predict_params_run, names_sep = "_", names_repair = "universal") 

spatial_firing <- spatial_firing %>%
  mutate(
         predict_diff_try = map2_dbl(normalised_rates_try, predict_params_try_fit, calc_predict_diff),
         predict_diff_run = map2_dbl(normalised_rates_run, predict_params_run_fit, calc_predict_diff))

```


### ----------------------------------------------------------------------------- ###


### ----------------------------------------------------------------------------------------- ###


Now we want to examine if there are differences in the reset activity between trial types (hit, try, run). To do this, we can plot population rate for rewarded and failed trials across whole track. 

Function to join firing rates from different trial types and add indicator of the type of trial

First combine hit and miss trials together with an indicator of trial type (hit, try, run)



1. Generate firing tibble for each cell containing firing rates for all three trial outcomes. The rates for each outcome are combined in to a single data frame in tidy format and then normalized.
```{r}
spatial_firing <- spatial_firing %>%
  mutate(avg_both_asr_b = pmap(list(Avg_FiringRate_HitTrials,
                                    Avg_FiringRate_RunTrials,
                                    Avg_FiringRate_TryTrials,
                                    session_id,
                                    cluster_id),
                               join_average_rates))
```





_plots for conjunctive position encoding neurons (PA, PS, PSA)_

Look at all position encoding neurons (P,PS, PA, PSA)
```{r}
position_all_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative", final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
# Total number of cells (not neccessarily all used for plots as not all neurons have all outcomes)
dim(position_all_neurons)[1]
```

```{r}
position_all_neurons_plots <- all_plots_by_outome(position_all_neurons)
plot_grid(position_all_neurons_plots[[1]],
          position_all_neurons_plots[[2]],
          position_all_neurons_plots[[3]],
          position_all_neurons_plots[[4]])

if (save_figures==1) {
 ggsave(file = "plots/TrialOutcome_NegNeg_position_all.png", plot = position_all_neurons_plots[[1]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_NegPos_position_all.png", plot = position_all_neurons_plots[[2]], width = 3.6, height = 2.9)
  ggsave(file = "plots/TrialOutcome_PosPos_position_all.png", plot = position_all_neurons_plots[[3]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_PosNeg_position_all.png", plot = position_all_neurons_plots[[4]], width = 3.6, height = 2.9) 
}
```

plit data based on conjunctive position encoding (PA, PS, PSA) (Figure 2) as we are only interested in these neurons here

```{r}
conjunctive_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative", final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
# Total number of cells
dim(conjunctive_neurons)[1]
```

```{r}
conjunctive_neurons_plots <- all_plots_by_outome(conjunctive_neurons)
plot_grid(conjunctive_neurons_plots[[1]],
          conjunctive_neurons_plots[[2]],
          conjunctive_neurons_plots[[3]],
          conjunctive_neurons_plots[[4]])

if (save_figures==1) {
 ggsave(file = "plots/TrialOutcome_NegNeg_conjunctive.png", plot = conjunctive_neurons_plots[[1]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_NegPos_conjunctive.png", plot = conjunctive_neurons_plots[[2]], width = 3.6, height = 2.9)
  ggsave(file = "plots/TrialOutcome_PosPos_conjunctive.png", plot = conjunctive_neurons_plots[[3]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_PosNeg_conjunctive.png", plot = conjunctive_neurons_plots[[4]], width = 3.6, height = 2.9) 
}
```

_plots for pure position encoding neurons (P)_

Repeat above for just position neurons

1. Split data based position encoding group (P) (Figure 2) as we are only interested in position neurons here
```{r}
position_neurons <- filter(spatial_firing, lm_group_b == "Positive" | lm_group_b == "Negative", final_model_o_b == "P")
# Total number of cells
dim(position_neurons)[1]
```

```{r}
position_neurons_plots <- all_plots_by_outome(position_neurons)
plot_grid(position_neurons_plots[[1]],
          position_neurons_plots[[2]],
          position_neurons_plots[[3]],
          position_neurons_plots[[4]])

if (save_figures==1) {
 ggsave(file = "plots/TrialOutcome_NegNeg_justposition.png", plot = position_neurons_plots[[1]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_NegPos_justposition.png", plot = position_neurons_plots[[2]], width = 3.6, height = 2.9)
  ggsave(file = "plots/TrialOutcome_PosPos_justposition.png", plot = position_neurons_plots[[3]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_PosNeg_justposition.png", plot = position_neurons_plots[[4]], width = 3.6, height = 2.9) 
}
```




_plots for speed encoding neurons (S) with POSITIVE or NEGATIVE slopes_
Repeat above plots but for speed encoding neurons

Split data based on speed encoding group (Figure 2) as we are only interested in these neurons here
```{r}
speed_neurons <- filter(spatial_firing, lm_group_b == "Positive", final_model_o_b == "S" | final_model_o_b == "SA")
# Total number of cells
dim(speed_neurons)[1]
```

```{r}
speed_neurons_plots <- all_plots_by_outome(speed_neurons)
plot_grid(speed_neurons_plots[[1]],
          speed_neurons_plots[[2]],
          speed_neurons_plots[[3]],
          speed_neurons_plots[[4]])

if (save_figures==1) {
 ggsave(file = "plots/TrialOutcome_NegNeg_speed.png", plot = speed_neurons_plots[[1]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_NegPos_speed.png", plot = speed_neurons_plots[[2]], width = 3.6, height = 2.9)
  ggsave(file = "plots/TrialOutcome_PosPos_speed.png", plot = speed_neurons_plots[[3]], width = 3.6, height = 2.9) 
  ggsave(file = "plots/TrialOutcome_PosNeg_speed.png", plot = speed_neurons_plots[[4]], width = 3.6, height = 2.9) 
}
```



### ------------------------------------------------------------------------------------------ ### 

## plot violin plots of mean apsolute difference between predicted and real in the first 5 cm of the homebound region for hit, run and try trials. 

- do only for neurons that have slopes in outbound zone
- do this for both negative and positive slopes in the outbound zone


1. First extract data into a tibble
```{r}
data <- tibble(session_id = rep(unlist(spatial_firing$unique_id), times=3), 
                    cluster_id = rep(spatial_firing$cluster_id, times=3), 
                    predict = c(as.numeric(spatial_firing$predict_diff),
                             as.numeric(spatial_firing$predict_diff_run),
                             as.numeric(spatial_firing$predict_diff_try)),
                    coef = c(as.numeric(spatial_firing$o_b_mod_coefs_speed),
                             as.numeric(spatial_firing$o_b_mod_coefs_speed),
                             as.numeric(spatial_firing$o_b_mod_coefs_speed)),
                    type = rep(c("Hit", "Run", "Try"),
                                    each = nrow(spatial_firing)),
                    track_category = rep(as.character(spatial_firing$track_category), times=3),
                    final_model_o_b = rep(as.character(spatial_firing$final_model_o_b), times=3),
                    lm_group_b = rep(as.character(spatial_firing$lm_group_b), times=3),
                    lm_group_b_h = rep(as.character(spatial_firing$lm_group_b_h), times=3))

```

2. extract only neurons that are positive or negative in the outbound zone (as determined by Figure 1) and subset based on position encoding (Figure 2) and are ++ or -- in beaconed trials
```{r}
df <- data %>%
  filter(final_model_o_b == "P") %>%
  filter(lm_group_b == "Positive" | lm_group_b == "Negative") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative" ) 
  
```

3. Write function to make violin plot, do this seperatly for positive and negative slope neurons as the axis limits are different for these groups.
```{r}
standard_neg_violin_plot <- function(df) {
  ggplot(data=df, aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-3.5,5.5)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size=15),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=15), 
        legend.text=element_text(size=15), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
}


standard_pos_violin_plot <- function(df) {
  ggplot(data=df, aes(y = unlist(predict), x=as.factor(unlist(type)), fill=as.factor(unlist(type)))) +
  coord_cartesian(ylim=c(-5,3)) +
  geom_violin(aes(y = unlist(predict), x=as.factor(unlist(type))), alpha=0.5) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_point(alpha=0.3) +
  geom_hline(yintercept=0, linetype="dashed", color = "black") +
  scale_fill_manual(values=c("grey","red", "blue")) +
  labs(y="Offset", x="") +
  theme_classic() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size=15),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=15), 
        legend.text=element_text(size=15), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
}

```

_plots for just position encoding encoding neurons (P)_

4. Select cells classified in Figure 1 as having positive or negative slopes and plot
```{r}
data_pos <- df %>%
  subset(lm_group_b == "Positive" & lm_group_b_h == "Positive")

(pos_neg_coef_plot <- standard_pos_violin_plot(data_pos))
if (save_figures == 1) {
  ggsave(file = "plots/Violin_Predict_Positive_JustPosition.png",width = 3.2, height = 2.5)
}

data_pos <- df %>%
  subset(lm_group_b == "Negative" & lm_group_b_h == "Negative")

(pos_neg_coef_plot <- standard_neg_violin_plot(data_pos))
if (save_figures == 1) {
  ggsave(file = "plots/Violin_Predict_Negative_JustPosition.png",width = 3.2, height = 2.5)
}
  
```

_run statistical tests_

1. run anova to compare effect of trial type (hit, try, run) on offset values for ++ and -- neurons 
```{r}
data_pos <- df %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") 

one.way <- aov(predict ~ type, data = data_pos)
summary(one.way)

data_neg <- df %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") 

one.way <- aov(predict ~ type, data = data_neg)
summary(one.way)
```


2. One-sample ttest to see whether offsets are above 0 _positive neurons_

1. For run trials (not significant)
```{r}
data_pos_run <- data_pos %>%
  filter(type == "Run") 

res <- t.test(data_pos_run$predict, mu = 0)
res 
```

1. For hit trials (significant)
```{r}
data_pos_hit <- data_pos %>%
  filter(type == "Hit") 

res <- t.test(data_pos_hit$predict, mu = 0)
res 
```

1. For miss trials (not significant)
```{r}
data_pos_miss <- data_pos %>%
  filter(type == "Try") 

res <- t.test(data_pos_miss$predict, mu = 0)
res 
```



One-sample ttest _negative_

1. For run trials
```{r}
data_neg_run <- data_neg %>%
  filter(type == "Run") 

res <- t.test(data_neg_run$predict, mu = 0)
res 
```

1. For hit trials
```{r}
data_neg_hit <- data_neg %>%
  filter(type == "Hit") 

res <- t.test(data_neg_hit$predict, mu = 0)
res 
```

1. For miss trials
```{r}
data_neg_miss <- data_neg %>%
  filter(type == "Try") 

res <- t.test(data_neg_miss$predict, mu = 0)
res 
```




_plots for all position encoding encoding neurons (P, PS, PA, PSA)_

1. repeat plots above but for all position neurons (Figure 2) (P, PS, PA, PSA)
```{r}
df <- data %>%
  filter(final_model_o_b == "PA" | final_model_o_b == "PS" | final_model_o_b == "PSA") %>%
  filter(lm_group_b == "Positive" | lm_group_b == "Negative") %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive" | lm_group_b == "Negative" & lm_group_b_h == "Negative" ) 
  
```

2. Select cells classified in Figure 2 as having positive or negative slopes and plot
```{r}
data_pos <- df %>%
  subset(lm_group_b == "Positive" & lm_group_b_h == "Positive")

(pos_neg_coef_plot <- standard_pos_violin_plot(data_pos))
if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_pos_AllPosition.png",width = 3.2, height = 2.5)
}

data_pos <- df %>%
  subset(lm_group_b == "Negative" & lm_group_b_h == "Negative")

(pos_neg_coef_plot <- standard_neg_violin_plot(data_pos))
if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_neg_AllPosition.png",width = 3.2, height = 2.5)
}
  
```

2. run anova on data above
```{r}
data_pos <- df %>%
  filter(lm_group_b == "Positive" & lm_group_b_h == "Positive") 

one.way <- aov(predict ~ type, data = data_pos)
summary(one.way)

data_neg <- df %>%
  filter(lm_group_b == "Negative" & lm_group_b_h == "Negative") 

one.way <- aov(predict ~ type, data = data_neg)
summary(one.way)
```





2. One-sample ttest to see whether offsets are above 0 _positive neurons_

1. For run trials (not significant)
```{r}
data_pos_run <- data_pos %>%
  filter(type == "Run") 

res <- t.test(data_pos_run$predict, mu = 0)
res 
```

1. For hit trials (significant)
```{r}
data_pos_hit <- data_pos %>%
  filter(type == "Hit") 

res <- t.test(data_pos_hit$predict, mu = 0)
res 
```

1. For miss trials (not significant)
```{r}
data_pos_miss <- data_pos %>%
  filter(type == "Try") 

res <- t.test(data_pos_miss$predict, mu = 0)
res 
```



One-sample ttest _negative_

1. For run trials
```{r}
data_neg_run <- data_neg %>%
  filter(type == "Run") 

res <- t.test(data_neg_run$predict, mu = 0)
res 
```

1. For hit trials
```{r}
data_neg_hit <- data_neg %>%
  filter(type == "Hit") 

res <- t.test(data_neg_hit$predict, mu = 0)
res 
```

1. For miss trials
```{r}
data_neg_miss <- data_neg %>%
  filter(type == "Try") 

res <- t.test(data_neg_miss$predict, mu = 0)
res 
```





1. For run trials
```{r}
data_pos_run <- df %>%
  filter(type == "Run") 

res <- t.test(data_pos_run$predict, mu = 0)
res 
```





_plots for all speed encoding encoding neurons (S, A, SA)_

1. extract only neurons that are subset based on speed encoding (S, SA, A) (Figure 3) and are ++ or -- in beaconed trials
```{r}
df <- data %>%
  filter(final_model_o_b == "S" | final_model_o_b == "SA" ) %>%
  filter(track_category == "pospos" | track_category == "negneg") 

```


5. Select cells classified in Figure 2 as having positive or negative slopes and plot
```{r}
data_pos <- df %>%
  subset(lm_group_b == "Positive") 

(pos_neg_coef_plot <- standard_pos_violin_plot(data_pos))
if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_pos_AllSpeed.png",width = 4, height = 2.5)
}

data_pos <- df %>%
  subset(lm_group_b == "Negative")

(pos_neg_coef_plot <- standard_neg_violin_plot(data_pos))
if (save_figures == 1) {
  ggsave(file = "plots/PredictProbe_neg_AllSpeed.png",width = 4, height = 2.5)
}
  
```

2. run anova on above data
```{r}
data_pos <- df %>%
  filter(lm_group_b == "Positive") 


one.way <- lm(predict ~ type, data = data_pos)
car::Anova(one.way)
summary(one.way)

data_neg <- df %>%
  filter(lm_group_b == "Negative") 


#one.way <- lm(predict ~ type, data = data_neg)
#car::Anova(one.way)
#summary(one.way)

#one.way <- ano(predict ~ type, data = data_neg)
#summary(one.way)
```



2. One-sample ttest to see whether offsets are above 0 _positive neurons_

1. For run trials (not significant)
```{r}
data_pos_run <- data_pos %>%
  filter(type == "Run") 

res <- t.test(data_pos_run$predict, mu = 0)
res 
```

1. For hit trials (significant)
```{r}
data_pos_hit <- data_pos %>%
  filter(type == "Hit") 

res <- t.test(data_pos_hit$predict, mu = 0)
res 
```

1. For miss trials (not significant)
```{r}
data_pos_miss <- data_pos %>%
  filter(type == "Try") 

res <- t.test(data_pos_miss$predict, mu = 0)
res 
```



One-sample ttest _negative_

1. For run trials
```{r}
data_neg_run <- data_neg %>%
  filter(type == "Run") 

res <- t.test(data_neg_run$predict, mu = 0)
res 
```

1. For hit trials
```{r}
data_neg_hit <- data_neg %>%
  filter(type == "Hit") 

res <- t.test(data_neg_hit$predict, mu = 0)
res 
```

1. For miss trials
```{r}
data_neg_miss <- data_neg %>%
  filter(type == "Try") 

res <- t.test(data_neg_miss$predict, mu = 0)
res 
```





### ----------------------------------------------------------------------------- ###


## Figure 3 statistical analysis

Find proportion & numbers of neurons that are significant/non-significiant

```{r}
ramps <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")
ramps_with_enough_trials <- subset(ramps, reward_interaction_id != "None" & reward_interaction_id != "NA")
```

```{r}
sig_ramps <- nrow(subset(ramps, reward_interaction_id == "Significant"))/nrow(ramps_with_enough_trials)*100
nonsig_ramps <- nrow(subset(ramps, reward_interaction_id == "Not-Significant"))/nrow(ramps_with_enough_trials)*100
```

```{r}
sig_ramps <- nrow(subset(ramps, reward_interaction_id == "Significant"))
nonsig_ramps <- nrow(subset(ramps, reward_interaction_id == "Not-Significant"))
```

