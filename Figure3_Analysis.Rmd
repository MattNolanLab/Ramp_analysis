---
title: "Figure3_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "Figure3_Analysis"
author: "Sarah Tennant"
date: "18/11/2020"
output: html_document
---



## Fit mixed effect models to evaluate contributions of speed, acceleration and position to firing rate

1. Load functions to perform linear mixed effect model
This might not be needed anymore??
```{r}
# source("Functions_Outbound_LMER.R")
```

Function to fit mixed effect models
```{r}
mm_fit <- function(df, TT = 0) {
  if (length(df) == 1)
    return(NA)
  df <-
    tibble(
      Rates = as.numeric(Re(df[[1]])),
      Position = as.numeric(Re(df[[2]])),
      Acceleration = as.numeric(Re(df[[3]])),
      Speed = as.numeric(Re(df[[4]])),
      Trials = as.factor(df[[5]]),
      Types = as.factor(df[[6]])
    )
  df <- df %>%
    subset(Position >= 30 & Position <= 90 & Speed > 3 & Types == TT)
  
  if (length(df) == 1 | nrow(df) < 3)
    return(NA)
  
  df_int <-
    lme4::lmer(
      Rates ~ Position + Speed + Acceleration + (1 |
                                                   Trials),
      data = df,
      na.action = na.exclude
    )

}
```


Function to extract P values for each coefficient from the model
```{r}
mm_pvalues <- function(mm) {
  if (is.na(mm)) {
    return(tibble(pos = NA, speed = NA, accel = NA))
  }
    modelAnova <- car::Anova(mm)
    return_tibble <- tibble(pos = modelAnova$"Pr(>Chisq)"[[1]],
                  speed = modelAnova$"Pr(>Chisq)"[[2]],
                  accel = modelAnova$"Pr(>Chisq)"[[3]])
}

```


2. Run on all cells 
```{r, warning=FALSE}
spatial_firing <- spatial_firing  %>%
  select(-contains('o_mm_p_b_')) %>%
  select(-contains('o_mm_p_nb_')) %>%
  mutate(o_mm_b = map2(spikes_in_time, 0, mm_fit),
         o_mm_nb = map2(spikes_in_time, 1, mm_fit),
         o_mm_p_b = map(o_mm_b, mm_pvalues),
         o_mm_p_nb = map(o_mm_nb, mm_pvalues)) %>%
  unnest_wider(o_mm_p_b, names_sep = "_", names_repair = "universal") %>%
  unnest_wider(o_mm_p_nb, names_sep = "_", names_repair = "universal")
```

Model p values are stored in:
spatial_firing$o_mm_p_b_pos
spatial_firing$o_mm_p_b_accel
spatial_firing$o_mm_p_b_speed


### ----------------------------------------------------------------------------------------- ###


## Select best model 

1. Write function to categorise neurons based on significant model coefficients
```{r}

model_comparison <- function(null_pos, null_speed, null_accel){
  pval <- 0.01
  if( is.na(null_pos) & is.na(null_accel)) {
    return( "None" )
  
  } else if( null_pos < pval & null_accel > pval & null_speed > pval) {
    return( "P" )
    
  } else if( null_pos > pval & null_accel > pval & null_speed < pval) {
    return( "S" ) 
    
  } else if( null_pos > pval & null_accel < pval & null_speed > pval) {
    return( "A" )
    
  } else if( null_pos < pval & null_accel > pval & null_speed < pval) {
    return("PS")
    
  } else if( null_pos < pval & null_accel < pval & null_speed > pval) {
    return( "PA" )
        
  } else if( null_pos > pval & null_accel < pval & null_speed < pval) {
    return("SA")

  } else if( null_pos < pval & null_accel < pval & null_speed < pval) {
    return("PSA")
    
  } else {
    return("None")
  }
}

```


2. Run on all cells in dataframe
```{r}
spatial_firing <- spatial_firing  %>%
    mutate(final_model_o_b  = pmap(list(o_mm_p_b_pos, o_mm_p_b_speed, o_mm_p_b_accel), model_comparison),
           final_model_o_nb  = pmap(list(o_mm_p_nb_pos, o_mm_p_nb_speed, o_mm_p_nb_accel), model_comparison))#%>%
    #mutate(final_model_o_p  = pmap(list(o_pos_p, o_speed_p, o_accel_p), model_comparison))

```


### ----------------------------------------------------------------------------------------- ###


### Plot model selection results

First for all cells. 

1. Split data by linear model result
```{r}

# extracting diff models 
pos <-subset(spatial_firing, lm_group_b == "Positive")
neg <-subset(spatial_firing, lm_group_b == "Negative")
none <-subset(spatial_firing, lm_group_b == "Unclassified")

```

2. Split data by mixed effect model result
```{r}

P_positive <- nrow(subset(pos, final_model_o_b == "P"))/nrow(pos)*100
P_negative <- nrow(subset(neg, final_model_o_b == "P"))/nrow(neg)*100
P_none <- nrow(subset(none,final_model_o_b == "P"))/nrow(none)*100

S_positive <- nrow(subset(pos,final_model_o_b == "S"))/nrow(pos)*100
S_negative <- nrow(subset(neg,final_model_o_b == "S"))/nrow(neg)*100
S_none <- nrow(subset(none,final_model_o_b == "S"))/nrow(none)*100

A_positive <- nrow(subset(pos,final_model_o_b == "A"))/nrow(pos)*100
A_negative <- nrow(subset(neg,final_model_o_b == "A"))/nrow(neg)*100
A_none <- nrow(subset(none,final_model_o_b == "A"))/nrow(none)*100

P_S_positive <- nrow(subset(pos,final_model_o_b == "PS"))/nrow(pos)*100
P_S_negative <- nrow(subset(neg,final_model_o_b == "PS"))/nrow(neg)*100
P_S_none <- nrow(subset(none,final_model_o_b == "PS"))/nrow(none)*100

P_A_positive <- nrow(subset(pos ,final_model_o_b == "PA"))/nrow(pos)*100
P_A_negative <- nrow(subset(neg ,final_model_o_b == "PA"))/nrow(neg)*100
P_A_none <- nrow(subset(none,final_model_o_b == "PA"))/nrow(none)*100

S_A_positive <- nrow(subset(pos ,final_model_o_b == "SA"))/nrow(pos)*100
S_A_negative <- nrow(subset(neg ,final_model_o_b == "SA"))/nrow(neg)*100
S_A_none <- nrow(subset(none,final_model_o_b == "SA"))/nrow(none)*100

P_S_A_positive <- nrow(subset(pos ,final_model_o_b == "PSA"))/nrow(pos)*100
P_S_A_negative <- nrow(subset(neg ,final_model_o_b == "PSA"))/nrow(neg)*100
P_S_A_none <- nrow(subset(none ,final_model_o_b == "PSA"))/nrow(none)*100

NONE_positive <- nrow(subset(pos ,final_model_o_b == "None"))/nrow(pos)*100
NONE_negative <- nrow(subset(neg ,final_model_o_b == "None"))/nrow(neg)*100
NONE_none <- nrow(subset(none ,final_model_o_b == "None"))/nrow(none)*100


```

3. Put data into tibble
```{r}


mixed_ramps <- tibble(perc=c(P_positive,P_negative,P_none,S_positive, S_negative, S_none, A_positive,A_negative,A_none,  P_S_positive, P_S_negative,P_S_none, P_A_positive, P_A_negative, P_A_none, S_A_positive, S_A_negative, S_A_none,P_S_A_positive, P_S_A_negative, P_S_A_none, NONE_positive,NONE_negative, NONE_none), 
                      
                      ramp_id= c("P","P","P", 
                                 "S", "S", "S", 
                                 "A", "A", "A",
                                 "PS", "PS", "PS", 
                                 "PA", "PA", "PA", 
                                 "SA", "SA", "SA", 
                                 "PAS", "PAS","PAS",
                                 "None","None", "None"), 
                      ramp_type= c("Positive", "Negative", "Unclassified","Positive", "Negative", "Unclassified", "Positive", "Negative", "Unclassified","Positive", "Negative" ,"Unclassified","Positive", "Negative","Unclassified","Positive", "Negative","Unclassified", "Positive", "Negative", "Unclassified", "Positive", "Negative", "Unclassified" ))

```

4. Plot model results
```{r}
# plot data
level_order <- c("P", "S", "A", "PS", "PA","SA", "PAS", "None")
ggplot(mixed_ramps, aes(x= factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons") +
  scale_fill_manual(values=c("firebrick1","gold", "dodgerblue2", "darkorange", "darkorchid1", "chartreuse3", "darkslategray", "grey78")) +
  #scale_fill_brewer(palette= "RdYlBu") +
  theme_classic() +
  theme(axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=16), 
        legend.text=element_text(size=16), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) +
ggsave(file = "plots/LMERProportions_beaconed.png", width = 4, height = 4.5)


```


### ----------------------------------------------------------------------------------------- ###

## Calculate standardized coefficients for position, speed and acceleration in LMER model

1. Load functions to calculate and extract standardised coefficients for each variable in the lmer
```{r}
source("Functions_StdCoef_lmer.R")
```

2. calculate and extract standardized coefficients for position, speed and acceleration

Function to calculate standardized coefficients from the model fits
```{r}
std_coef <- function(mm) {
  mod <- stdCoef.merMod(mm) 
  mod_coefs <- tibble(pos = mod[2,1],
                      speed = mod[3,1],
                      accel = mod[4,1])
}
  
```

3. Run on all cells
```{r, warning=FALSE}

spatial_firing <- spatial_firing  %>%
  select(-contains('o_b_mod_coefs_')) %>%
  mutate(o_b_mod_coefs = map(o_mm_b, std_coef)) %>%
  unnest_wider(o_b_mod_coefs, names_sep = "_", names_repair = "universal")
```

Standardized coefficients are in:
spatial_firing$o_b_mod_coefs_pos
spatial_firing$o_b_mod_coefs_speed
spatial_firing$o_b_mod_coefs_accel

### plot distribution of coefficients for all cells
_split by positive and negative sloping neurons_

1. make unique id for each neuron (session_id + cluster_id)
```{r}
# First make a function to concatenate session id and cluster id
make_unique_id <- function(session,cluster) {
  x <- paste(session, cluster, sep="_")
  return(as.character(x))
}

# run on all cells
spatial_firing <- spatial_firing  %>%
  mutate(unique_id = map2(session_id, cluster_id, make_unique_id))

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save <- select(spatial_firing, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

```

3. save to csv file _this is for matching to plots from python_
```{r}
write_csv2(spatial_firing_save, "all_results_coefficients.csv")
```

4. put data into a tibble for plotting
```{r}
data_coef <- tibble(session_id = rep(unlist(spatial_firing_save$unique_id), times=3), 
                    cluster_id = rep(spatial_firing_save$cluster_id, times=3), 
                    coef = c(as.character(spatial_firing_save$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b)), 
                    # cue_group = c(as.character(spatial_firing_save$cue_group_o),
                    #            as.character(spatial_firing_save$cue_group_o),
                    #            as.character(spatial_firing_save$cue_group_o)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save)),
                    lm_result = rep(as.character(spatial_firing_save$lm_group_b), times=3))
```

_Plot coefficients for all cells_


Make function for plotting standardised coefficients
```{r}
standard_plot <- function(df) {
  level_order <- c("P", "S", "A")
  ggplot(data=df, aes(x = factor(coef_type), y = as.numeric(coef))) +
  #coord_cartesian(ylim=c(0,1)) +
  geom_violin(aes(x = factor(coef_type), y = as.numeric(coef), fill=factor(coef_type, level=level_order)), alpha=0.7) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_jitter(alpha=0.05) +
  scale_fill_manual(values=c("firebrick1","gold","dodgerblue2")) +
  labs(y = "std coef \n", x="\n model parameter") +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
}
```

5. Select cells classified in Figure 2 as having positive or negative slopes
```{r}
data_coef_pos_neg <- data_coef %>%
  subset(lm_result == "Positive" || lm_result == "Negative")

(pos_neg_coef_plot <- standard_plot(data_coef_pos_neg) +
    ggsave(file = "plots/CoefficientValues_positive_negative_cells1.png", width = 3, height = 2.5))
```



5. Split by positive slope _all cells_
```{r}
data_coef_pos <- data_coef %>%
  subset(lm_result == "Positive" )

(pos_coef_plot <- standard_plot(data_coef_pos) +
    ggsave(file = "plots/CoefficientValues_positivecells.png", width = 3, height = 2.5))
```

5. Split by negative slope _all cells_
```{r}
data_coef_neg <- data_coef %>%
  subset(lm_result == "Negative" )

(neg_coef_plot <- standard_plot(data_coef_neg) +
ggsave(file = "plots/CoefficientValues_negativecells.png", width = 3, height = 2.5))
  
```

_Plot coefficients for all cells_

5. Split by positive slope _PA cells_
```{r}
data_coef_pos_PA <- data_coef %>%
  subset(group == "PA") %>%
  subset(lm_result == "Positive" )

(pos_PA_coef_plot <- standard_plot(data_coef_pos_PA) +
ggsave(file = "plots/CoefficientValues_PositivePAcells.png", width = 3, height = 2.5))
  
```

6. Split by negative slope
```{r}
data_coef_neg_PA <- data_coef %>%
  subset(group == "PA") %>%
  subset(lm_result == "Negative" )

(neg_PA_coef_plot <- standard_plot(data_coef_neg_PA) +
ggsave(file = "plots/CoefficientValues_NegativePAcells.png", width = 3, height = 2.5))
 
```


_Plot coefficients for just position cells_


6a. Plot coefficients for cells classified in Figure 2 as having a positive slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_pos_P <- data_coef %>%
  subset(group == "P") %>%
  subset(lm_result == "Positive")

(pos_P_coef_plot <- standard_plot(data_coef_pos_P) +
ggsave(file = "plots/CoefficientValues_PositivePcells.png", width = 3, height = 2.5))
 

```



6b. Plot coefficients for cells classified in Figure 2 as having a negative slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_neg_P <- data_coef %>%
  subset(group == "P") %>%
  subset(lm_result == "Negative")

(neg_P_coef_plot <- standard_plot(data_coef_neg_P) +
ggsave(file = "plots/CoefficientValues_NegativePcells.png", width = 3, height = 2.5))

```



6c. Plot coefficients for cells classified in Figure 2 as being unclassified but that have 'significant' positional coefficients in the mixed effect model.

```{r}
data_coef_UC_PSA <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(lm_result == "Unclassified")

(UC_PSA_coef_plot <- standard_plot(data_coef_UC_PSA) +
ggsave(file = "plots/CoefficientValues_UCPSAcells.png", width = 3, height = 2.5))

```

## Save to csv file _this is for matching to plots from python_
```{r}
spatial_firing_save <- tibble(session_id = spatial_firing_save$session_id,
                              cluster_id = spatial_firing_save$cluster_id,
                              pos_stdcoef =  as.character(spatial_firing_save$o_b_mod_coefs_pos),
                              speed_stdcoef =  as.character(spatial_firing_save$o_b_mod_coefs_speed),
                              accel_stdcoef =  as.character(spatial_firing_save$o_b_mod_coefs_accel),
                              final_model_o_b =  as.character(spatial_firing_save$final_model_o_b),
                              lm_result_o_rewarded_b =  as.character(spatial_firing_save$lm_group_b))

write.table(spatial_firing_save, "all_results_coefficients.txt", quote=FALSE, sep="\t")
```





###----------------------------------------------------------------------------###

Analyses

Compare coefficients for position, speed and acceleration.

```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

```{r}
pos_position_cells <- subset(spatial_firing, lm_group_b == "Positive")
neg_position_cells <- subset(spatial_firing, lm_group_b == "Negative")

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save_p <- select(pos_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

spatial_firing_save_n <- select(neg_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()
```

1. put data into a tibble for plotting
```{r}

data_coef_p <- tibble(session_id = rep(unlist(spatial_firing_save_p$unique_id), times=3),
                    cluster_id = rep(spatial_firing_save_p$cluster_id, times=3),

                    coef = c(as.character(spatial_firing_save_p$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save_p$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save_p$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save_p$final_model_o_b),
                              as.character(spatial_firing_save_p$final_model_o_b),
                              as.character(spatial_firing_save_p$final_model_o_b)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save_p)),
                    lm_result = rep(as.character(spatial_firing_save_p$lm_group_b), times=3))

data_coef_n <- tibble(session_id = rep(unlist(spatial_firing_save_n$unique_id), times=3),
                    cluster_id = rep(spatial_firing_save_n$cluster_id, times=3),
                    coef = c(as.character(spatial_firing_save_n$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save_n$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save_n$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save_n$final_model_o_b),
                              as.character(spatial_firing_save_n$final_model_o_b),
                              as.character(spatial_firing_save_n$final_model_o_b)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save_n)),
                    lm_result = rep(as.character(spatial_firing_save_n$lm_group_b), times=3))
```

2. run anova
```{r}
one.way_p <- aov(coef ~ coef_type, data = data_coef_p)

summary(one.way_p)

one.way_n <- aov(coef ~ coef_type, data = data_coef_n)

summary(one.way_n)
```

3. Post hoc Tukey's test
```{r}
tukey.test_p <- TukeyHSD(one.way_p)
tukey.test_p$coef_type

tukey.test_n <- TukeyHSD(one.way_n)
tukey.test_n$coef_type
```



