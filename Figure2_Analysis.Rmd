---
title: "RampCodes_Figure2"
author: "Sarah Tennant & Matt Nolan"
date: "20/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### ------------------------------------------------------------------------------------------ ### 

## Do ramping neurons encode speed, position or acceleration?

### ------------------------------------------------------------------------------------------ ### 



## Fit general linear mixed effect models (GLMER) using LME4 package to evaluate contributions of speed, acceleration and position to firing rate

Note here, there may be some overfitting with the mixed effect model. This is likely because some  coefficients likely do not vary with position. However, we can't address this by tailoring the model to each cell as we want to treat each cell the same way. The standardized coefficients should still be interpretable.
See discussion in ?isSingular and here: https://stats.stackexchange.com/questions/378939/dealing-with-singular-fit-in-mixed-models

spatial_firing$spikes_in_time is a list column. Each row corresponds to a single cell and contains a list of 6 data frames. These correspond to firing rate, position, acceleration, speed, trial number and trial type. The data cover a full behavioral session. Trial types are beaconed (0), non-beaconed and probe.
```{r, warning=FALSE}
spatial_firing <- spatial_firing  %>%
  mutate(o_mm_b = map2(spikes_in_time, 0, mm_fit_function),
         #o_mm_p = map2(spikes_in_time, 1, mm_fit_function),
         o_mm_p_b = map2(o_mm_b, session_id, mm_pvalues)) %>% 
         #o_mm_p_p = map(o_mm_p, session_id, mm_pvalues)) %>% 
  unnest_wider(o_mm_p_b, names_sep = "_", names_repair = "universal")
  #unnest_wider(o_mm_p_p, names_sep = "_", names_repair = "universal")
```


# Adjust p values for multiple comparisons
```{r}
spatial_firing <- spatial_firing %>%
    mutate(o_mm_p_b_pos = p.adjust(o_mm_p_b_pos, "BH"),
         o_mm_p_b_speed = p.adjust(o_mm_p_b_speed, "BH"),
         o_mm_p_b_accel = p.adjust(o_mm_p_b_accel, "BH"))
```




```{r}
if (save_results == 1) {
  saveRDS(spatial_firing, "/data_out/SpatialFiring_with_glmer.Rda")
}
```

### ----------------------------------------------------------------------------------------- ###


## Categorise neurons based on significant model coefficients
```{r}

coef_comparison <- function(null_pos, null_speed, null_accel, pval = 0.01){
  if( is.na(null_pos) & is.na(null_accel)) {
    return( "None" )
  
  } else if( null_pos < pval & null_accel > pval & null_speed > pval) {
    return( "P" )
    
  } else if( null_pos > pval & null_accel > pval & null_speed < pval) {
    return( "S" ) 
    
  } else if( null_pos > pval & null_accel < pval & null_speed > pval) {
    return( "A" )
    
  } else if( null_pos < pval & null_accel > pval & null_speed < pval) {
    return("PS")
    
  } else if( null_pos < pval & null_accel < pval & null_speed > pval) {
    return( "PA" )
        
  } else if( null_pos > pval & null_accel < pval & null_speed < pval) {
    return("SA")

  } else if( null_pos < pval & null_accel < pval & null_speed < pval) {
    return("PSA")
    
  } else {
    return("None")
  }
}

```


the idea here it to categorise each neuron according to whether it has coefficients for P, S or A that are 'signficant' at a threshold of 0.01.
```{r}
spatial_firing <- spatial_firing  %>%
    mutate(final_model_o_b  = pmap(list(o_mm_p_b_pos, o_mm_p_b_speed, o_mm_p_b_accel, 0.01), coef_comparison))

```

### ----------------------------------------------------------------------------------------- ###

position encoding ramp neurons were classified with a similar slope on the non-beaconed and probe trials as on beaconed trials ....
1. extract position cells
```{r}
ramp_cells <- subset(spatial_firing, lm_group_b == "Negative" | lm_group_b == "Positive")

position_cells <- subset(ramp_cells, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")

```


### ----------------------------------------------------------------------------------------- ###

## Calculate standardized coefficients for position, speed and acceleration in LMER model


1. Load functions to calculate and extract standardised coefficients for each variable in the lmer
```{r}
#1. Function to calculate standardized coefficients for a LMER
#https://stackoverflow.com/questions/25142901/standardized-coefficients-for-lmer-model 

stdCoef.merMod <- function(object) {
  sdy <- sd(getME(object,"y"))
  sdx <- apply(getME(object,"X"), 2, sd)
  sc <- fixef(object)*sdx/sdy
  se.fixef <- coef(summary(object))[,"Std. Error"]
  se <- se.fixef*sdx/sdy
  return(data.frame(stdcoef=sc, stdse=se))
}
```

1. calculate and extract standardized coefficients for position, speed and acceleration

Function to calculate standardized coefficients from the model fits
```{r}
std_coef <- function(mm) {
  tryCatch({
  mod <- stdCoef.merMod(mm)
  mod_coefs <- tibble(pos = mod[2,1],
                      speed = mod[3,1],
                      accel = mod[4,1])
      },
    error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

```


3. Run on all cells
```{r, warning=FALSE}
spatial_firing <- spatial_firing %>%
  mutate(o_b_mod_coefs = map(o_mm_b, std_coef)) %>%
  #mutate(o_p_mod_coefs = map(o_mm_p, std_coef)) %>%
  unnest_wider(o_b_mod_coefs, names_sep = "_", names_repair = "universal") #%>%
  #unnest_wider(o_p_mod_coefs, names_sep = "_", names_repair = "universal")

# check number of NAs
sum(is.na(spatial_firing$o_b_mod_coefs_pos))
```

Standardized coefficients are in:
spatial_firing$o_b_mod_coefs_pos
spatial_firing$o_b_mod_coefs_speed
spatial_firing$o_b_mod_coefs_accel


1. make unique id for each neuron (session_id + cluster_id)
```{r}
# First make a function to concatenate session id and cluster id
make_unique_id <- function(session,cluster) {
  x <- paste(session, cluster, sep="_")
  return(as.character(x))
}
```

```{r}
# run on all cells
spatial_firing <- spatial_firing  %>%
  mutate(unique_id = map2(session_id, cluster_id, make_unique_id))
```


### Plot model selection results performed in Figure1_Analysis.Rmd

First for all cells. 

1. Split data by linear model result
```{r}
# extracting diff models 
pos <-subset(spatial_firing, lm_group_b == "Positive")
neg <-subset(spatial_firing, lm_group_b == "Negative")
none <-subset(spatial_firing, lm_group_b == "Unclassified")

```

2. Split data by mixed effect model result
```{r}

P_positive <- nrow(subset(pos, final_model_o_b == "P"))/nrow(pos)*100
P_negative <- nrow(subset(neg, final_model_o_b == "P"))/nrow(neg)*100
P_none <- nrow(subset(none,final_model_o_b == "P"))/nrow(none)*100

S_positive <- nrow(subset(pos,final_model_o_b == "S"))/nrow(pos)*100
S_negative <- nrow(subset(neg,final_model_o_b == "S"))/nrow(neg)*100
S_none <- nrow(subset(none,final_model_o_b == "S"))/nrow(none)*100

A_positive <- nrow(subset(pos,final_model_o_b == "A"))/nrow(pos)*100
A_negative <- nrow(subset(neg,final_model_o_b == "A"))/nrow(neg)*100
A_none <- nrow(subset(none,final_model_o_b == "A"))/nrow(none)*100

P_S_positive <- nrow(subset(pos,final_model_o_b == "PS"))/nrow(pos)*100
P_S_negative <- nrow(subset(neg,final_model_o_b == "PS"))/nrow(neg)*100
P_S_none <- nrow(subset(none,final_model_o_b == "PS"))/nrow(none)*100

P_A_positive <- nrow(subset(pos ,final_model_o_b == "PA"))/nrow(pos)*100
P_A_negative <- nrow(subset(neg ,final_model_o_b == "PA"))/nrow(neg)*100
P_A_none <- nrow(subset(none,final_model_o_b == "PA"))/nrow(none)*100

S_A_positive <- nrow(subset(pos ,final_model_o_b == "SA"))/nrow(pos)*100
S_A_negative <- nrow(subset(neg ,final_model_o_b == "SA"))/nrow(neg)*100
S_A_none <- nrow(subset(none,final_model_o_b == "SA"))/nrow(none)*100

P_S_A_positive <- nrow(subset(pos ,final_model_o_b == "PSA"))/nrow(pos)*100
P_S_A_negative <- nrow(subset(neg ,final_model_o_b == "PSA"))/nrow(neg)*100
P_S_A_none <- nrow(subset(none ,final_model_o_b == "PSA"))/nrow(none)*100

NONE_positive <- nrow(subset(pos ,final_model_o_b == "None"))/nrow(pos)*100
NONE_negative <- nrow(subset(neg ,final_model_o_b == "None"))/nrow(neg)*100
NONE_none <- nrow(subset(none ,final_model_o_b == "None"))/nrow(none)*100


```

3. number of cells in each group - positive sloping neurons
```{r}
P_positive_num <- nrow(subset(pos, final_model_o_b == "P"))
P_A_positive_num <- nrow(subset(pos, final_model_o_b == "PA"))
P_S_positive_num <- nrow(subset(pos, final_model_o_b == "PS"))
P_S_A_positive_num <- nrow(subset(pos, final_model_o_b == "PSA"))
S_A_positive_num <- nrow(subset(pos, final_model_o_b == "SA"))
S_positive_num <- nrow(subset(pos, final_model_o_b == "S"))
A_positive_num <- nrow(subset(pos, final_model_o_b == "A"))
NONE_positive_num <- nrow(subset(pos, final_model_o_b == "None"))

```

4. number of cells in each group - negative sloping neurons
```{r}
P_negative_num <- nrow(subset(neg, final_model_o_b == "P"))
P_A_negative_num <- nrow(subset(neg, final_model_o_b == "PA"))
P_S_negative_num <- nrow(subset(neg, final_model_o_b == "PS"))
P_S_A_negative_num <- nrow(subset(neg, final_model_o_b == "PSA"))
S_A_negative_num <- nrow(subset(neg, final_model_o_b == "SA"))
S_negative_num <- nrow(subset(neg, final_model_o_b == "S"))
A_negative_num <- nrow(subset(neg, final_model_o_b == "A"))
NONE_negative_num <- nrow(subset(neg, final_model_o_b == "None"))

```

5. number of cells in each group - unclassified  neurons
```{r}
P_none_num <- nrow(subset(none, final_model_o_b == "P"))
P_A_none_num <- nrow(subset(none, final_model_o_b == "PA"))
P_S_none_num <- nrow(subset(none, final_model_o_b == "PS"))
P_S_A_none_num <- nrow(subset(none, final_model_o_b == "PSA"))
S_A_none_num <- nrow(subset(none, final_model_o_b == "SA"))
S_none_num <- nrow(subset(none, final_model_o_b == "S"))
A_none_num <- nrow(subset(none, final_model_o_b == "A"))
NONE_none_num <- nrow(subset(none, final_model_o_b == "None"))

```

6. Put data into tibble
```{r}

mixed_ramps <- tibble(perc=c(P_positive,P_negative,P_none,S_positive, S_negative, S_none, A_positive,A_negative,A_none,  P_S_positive, P_S_negative,P_S_none, P_A_positive, P_A_negative, P_A_none, S_A_positive, S_A_negative, S_A_none,P_S_A_positive, P_S_A_negative, P_S_A_none, NONE_positive,NONE_negative, NONE_none), 
                      num=c(P_positive_num,P_negative_num,P_none_num,S_positive_num, S_negative_num, S_none_num, A_positive_num,A_negative_num,A_none_num,  P_S_positive_num, P_S_negative_num,P_S_none_num, P_A_positive_num, P_A_negative_num, P_A_none_num, S_A_positive_num, S_A_negative_num, S_A_none_num,P_S_A_positive_num, P_S_A_negative_num, P_S_A_none_num, NONE_positive_num,NONE_negative_num, NONE_none_num),
                      
                      ramp_id= c("P","P","P", 
                                 "S", "S", "S", 
                                 "A", "A", "A",
                                 "PS", "PS", "PS", 
                                 "PA", "PA", "PA", 
                                 "SA", "SA", "SA", 
                                 "PAS", "PAS","PAS",
                                 "None","None", "None"), 
                      ramp_type= c("Positive", "Negative", "Unclassified","Positive", "Negative", "Unclassified", "Positive", "Negative", "Unclassified","Positive", "Negative" ,"Unclassified","Positive", "Negative","Unclassified","Positive", "Negative","Unclassified", "Positive", "Negative", "Unclassified", "Positive", "Negative", "Unclassified" ))

```

7. Plot model results
```{r}
# plot data
level_order <- c("P", "S", "A", "PS", "PA","SA", "PAS", "None")
ggplot(mixed_ramps, aes(x= factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons", x="") +
  scale_fill_manual(values=c("firebrick1","gold", "dodgerblue2", "darkorange", "darkorchid1", "chartreuse3", "darkslategray", "grey78")) +
  geom_text(aes(label = num), hjust = 0.7, vjust = 0.2, size = 5, position = position_stack(vjust= 0.5)) +
  #scale_fill_brewer(palette= "RdYlBu") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 50, vjust=0.65)) +
  theme(axis.text.x = element_text(size=17),
        axis.text.y = element_text(size=16),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=16), 
        legend.text=element_text(size=16), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
if (save_figures == 1) {
  ggsave(file = "plots/LMERProportions_beaconed_update.png", width = 4, height = 5.5)
}
```




### plot distribution of coefficients for all cells
_split by positive and negative sloping neurons_

1. make unique id for each neuron (session_id + cluster_id)
```{r}
# First make a function to concatenate session id and cluster id
make_unique_id <- function(session,cluster) {
  x <- paste(session, cluster, sep="_")
  return(as.character(x))
}
```

```{r}
# run on all cells
spatial_firing <- spatial_firing  %>%
  mutate(unique_id = map2(session_id, cluster_id, make_unique_id))

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save <- select(spatial_firing, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()
spatial_firing_save$o_b_mod_coefs_pos <- as.numeric(spatial_firing_save$o_b_mod_coefs_pos)
spatial_firing_save$o_b_mod_coefs_speed <- as.numeric(spatial_firing_save$o_b_mod_coefs_speed)
spatial_firing_save$o_b_mod_coefs_accel <- as.numeric(spatial_firing_save$o_b_mod_coefs_accel)
spatial_firing_save$cluster_id <- as.numeric(spatial_firing_save$cluster_id)

```

3. save to csv file _this is for matching the coefficient values to plots of instantaneous rates from python_
```{r}
write.table(spatial_firing_save, "data_out/all_results_coefficients.csv", quote=FALSE, sep="\t")

```

4. put data into a tibble for plotting
```{r}
data_coef <- tibble(session_id = rep(unlist(spatial_firing_save$unique_id), times=3), 
                    cluster_id = rep(spatial_firing_save$cluster_id, times=3), 
                    coef = c(as.character(spatial_firing_save$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b)), 
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save)),
                    lm_result = rep(as.character(spatial_firing_save$lm_group_b), times=3))
```

_Plot coefficients for all cells_

Make function for plotting standardised coefficients
```{r}
standard_plot <- function(df) {
  level_order <- c("P", "S", "A")
  ggplot(data=df, aes(x = factor(coef_type), y = as.numeric(coef))) +
  geom_violin(aes(x = factor(coef_type), y = as.numeric(coef), fill=factor(coef_type, level=level_order)), alpha=0.7) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_jitter(alpha=0.05) +
  scale_fill_manual(values=c("firebrick1","gold","dodgerblue2")) +
  labs(y = "std coef", x="\n model parameter") +
  scale_y_continuous(trans=pseudolog10_trans) +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
}
```



5. Split by positive slope _all cells_
```{r}
data_coef_pos <- data_coef %>%
  subset(lm_result == "Positive" )

(pos_coef_plot <- standard_plot(data_coef_pos))
if (save_figures == 1) {
   ggsave(file = "plots/CoefficientValues_positivecells.png", width = 3, height = 2.5)
}
```

5. Split by negative slope _all cells_
```{r}
data_coef_neg <- data_coef %>%
  subset(lm_result == "Negative" )

(neg_coef_plot <- standard_plot(data_coef_neg))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_negativecells.png", width = 3, height = 2.5)
}
```

_Plot coefficients for all cells_

5. Split by positive slope _PS cells_
```{r}
data_coef_pos_PS <- data_coef %>%
  subset(group == "PSA") %>%
  subset(lm_result == "Positive" )

(pos_PS_coef_plot <- standard_plot(data_coef_pos_PS))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositivePSAcells.png", width = 3, height = 2.5)
}
```

6. Split by negative slope
```{r}
data_coef_neg_PS <- data_coef %>%
  subset(group == "PSA") %>%
  subset(lm_result == "Negative" )

(neg_PS_coef_plot <- standard_plot(data_coef_neg_PS))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativePSAcells.png", width = 3, height = 2.5)
}
```


_Plot coefficients for just position cells_


6a. Plot coefficients for cells classified in Figure 2 as having a positive slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_pos_P <- data_coef %>%
  subset(group == "P") %>%
  subset(lm_result == "Positive")

(pos_P_coef_plot <- standard_plot(data_coef_pos_P))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositivePcells.png", width = 3, height = 2.5)
}
```



6b. Plot coefficients for cells classified in Figure 2 as having a negative slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_neg_P <- data_coef %>%
  subset(group == "P") %>%
  subset(lm_result == "Negative")

(neg_P_coef_plot <- standard_plot(data_coef_neg_P))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativePcells.png", width = 3, height = 2.5)
}
```


_Plot coefficients for just position cells_


6a. Plot coefficients for cells classified in Figure 1 as having a positive slope and in Figure 2 as having significant fit coefficients for position only.

```{r}
data_coef_pos_SA <- data_coef %>%
  subset(group == "SA") %>%
  subset(lm_result == "Positive")

(pos_SA_coef_plot <- standard_plot(data_coef_pos_SA))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositiveSAcells.png", width = 3, height = 2.5)
}
```


6b. Plot coefficients for cells classified in Figure 1 as having a negative slope and in Figure 2 as having significant fit coefficients for position only.

```{r}
data_coef_neg_SA <- data_coef %>%
  subset(group == "SA") %>%
  subset(lm_result == "Negative")

(neg_SA_coef_plot <- standard_plot(data_coef_neg_SA))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativeSAcells.png", width = 3, height = 2.5)
}
```


6c. Plot coefficients for cells classified in Figure 1 as being unclassified but that have 'significant' positional coefficients in the mixed effect model.

```{r}
data_coef_UC_PSA <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(lm_result == "Unclassified")

(UC_PSA_coef_plot <- standard_plot(data_coef_UC_PSA))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_UCPSAcells.png", width = 3, height = 2.5)
}
```




###----------------------------------------------------------------------------###

Statistical analyses to compare coefficients for position, speed and acceleration.

1. Take only 
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

```{r}
pos_position_cells <- subset(spatial_firing, lm_group_b == "Positive")
neg_position_cells <- subset(spatial_firing, lm_group_b == "Negative")

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save_p <- select(pos_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

spatial_firing_save_n <- select(neg_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()
```

1. put data into a tibble for plotting
```{r}

data_coef_p <- tibble(session_id = rep(unlist(spatial_firing_save_p$unique_id), times=3),
                    cluster_id = rep(spatial_firing_save_p$cluster_id, times=3),

                    coef = c(as.character(spatial_firing_save_p$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save_p$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save_p$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save_p$final_model_o_b),
                              as.character(spatial_firing_save_p$final_model_o_b),
                              as.character(spatial_firing_save_p$final_model_o_b)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save_p)),
                    lm_result = rep(as.character(spatial_firing_save_p$lm_group_b), times=3))

data_coef_n <- tibble(session_id = rep(unlist(spatial_firing_save_n$unique_id), times=3),
                    cluster_id = rep(spatial_firing_save_n$cluster_id, times=3),
                    coef = c(as.character(spatial_firing_save_n$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save_n$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save_n$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save_n$final_model_o_b),
                              as.character(spatial_firing_save_n$final_model_o_b),
                              as.character(spatial_firing_save_n$final_model_o_b)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save_n)),
                    lm_result = rep(as.character(spatial_firing_save_n$lm_group_b), times=3))
```

2. run anova
```{r}
one.way_p <- aov(coef ~ coef_type, data = data_coef_p)

summary(one.way_p)

one.way_n <- aov(coef ~ coef_type, data = data_coef_n)

summary(one.way_n)
```

3. Post hoc Tukey's test
```{r}
tukey.test_p <- TukeyHSD(one.way_p)
tukey.test_p$coef_type

tukey.test_n <- TukeyHSD(one.way_n)
tukey.test_n$coef_type
```



```{r}
if (save_results == 1) {
  saveRDS(spatial_firing, "SpatialFiring_with_Results.Rda")
}
```
