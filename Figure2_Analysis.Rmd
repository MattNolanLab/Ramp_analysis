---
title: "Figure2_Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "Figure2_Analysis"
author: "Sarah Tennant"
date: "18/11/2020"
output: html_document
---

## Analysis of neurons recorded from the medial entorhinal cortex during virtual navigation

The aim of this analysis is to identify all ramp cells within a specified dataset (all mice or all days for one mouse) and perform analysis to investigate their firing properties. 
1. Identify cells that represent location by ramping their firing rate using LM modeling 
2. Subset data by model fit (r2 value)
3. Compare firing rates of cells in this group



## Import packages

```{r}
library(tidyverse)
library(broom)
library(lme4)
library(ggExtra)
library(ggthemes)
library(scales)
library(Hmisc)
library(Metrics)
library(plotrix)
#library(plyr)
#library("plot3D")
#library(NetworkD3)
```


## Import functions

```{r}
source("Functions.R")
source("Functions_Outbound_LMER.R")
```

### ----------------------------------------------------------------------------------------- ###

## Load the data
_note : only run if not ran ConvertPickletoRda.Rmd_

```{r}
# spatial_firing <- readRDS(file="df_final.Rda")
spatial_firing <- readRDS(file="Link to df_final.Rda")
# Not sure the line below is necessary # Run if loaded from pandas dataframe to save data as .Rda
# saveRDS(spatial_firing_test, file="spatial_firing_test.Rda")

```



### ----------------------------------------------------------------------------------------- ###

## Average firing rate (for LM modelling)

The linear model uses firing rate data binned in space. For this we want to load average firing rate over trials from the data frame for each cluster. 
- Map over "Rates_averaged" column and extract averaged rates
- Add position for each point ( data is binned into 200, 1 cm bins )
- Insert result back into dataframe
- Do this for beaconed, nonbeaconed and probe trials
- Do this for shuffled spike rate (beaconed)

1. Write function to add position
```{r}
add_position <- function(df) { 
  df <- tibble(Rates = unlist(df), Position = rep(1:200)) 
}
```

2. Run on dataframe : Average trials with reward
```{r}
spatial_firing <- spatial_firing %>%
  mutate(asr_b_rewarded = map(Rates_averaged_rewarded_b, add_position)) %>%
  mutate(asr_nb_rewarded = map(Rates_averaged_rewarded_nb, add_position)) %>%
  mutate(asr_p_rewarded = map(averaged_rewarded_p, add_position))

```


### ----------------------------------------------------------------------------------------- ###

# Run simple linear model 

1. make function to run linear model
```{r}
lm_helper <- function(df, bins){
  df_mod <- lm(Rates ~ Position, data = df[bins,], na.action=na.exclude)
}
```

2. make function to extract linear model output for each neuron
```{r}
lm_analysis <- function(df, spike_rate_col, startbin = 30, endbin = 90) {
  spike_rate_col <- enquo(spike_rate_col)
  out_name <- sym(paste0(quo_name(spike_rate_col)))
  sr_unnest_name <- sym(paste0(quo_name(spike_rate_col), "_unnest"))
  fit_name <- sym(paste0(quo_name(out_name), "_fit"))
  glance_name <- sym(paste0(quo_name(out_name), "_glance"))
  r2_name <- sym(paste0(quo_name(out_name), "_r2_o"))
  Pval_name <- sym(paste0(quo_name(out_name), "_Pval_o"))
  slope_name <- sym(paste0(quo_name(out_name), "_slope_o"))
  intercept_name <- sym(paste0(quo_name(out_name), "_intercept_o"))
  df <- df %>%
    mutate(!!fit_name := map(!!spike_rate_col, bins=c(startbin:endbin), lm_helper),
           !!glance_name := map(!!fit_name, glance),
           !!r2_name := map_dbl(!!glance_name, ~.$r.squared),
           !!Pval_name := map_dbl(!!glance_name, ~.$p.value),
           !!slope_name := map_dbl(!!fit_name, ~.$coefficients[2]),
           !!intercept_name := map_dbl(!!fit_name, ~.$coefficients[1]))
}
```

3. run lm on all cells
```{r}

spatial_firing <- spatial_firing %>%
  lm_analysis(asr_b_rewarded, 30, 90) %>%
  lm_analysis(asr_nb_rewarded, 30, 90) %>%
  lm_analysis(asr_p_rewarded, 30, 90)

```




```{r}
ggplot(data=spatial_firing, aes(x = asr_b_rewarded_slope_o, y = asr_b_rewarded_r2_o)) + 
    coord_cartesian(xlim = c(-1,1), ylim = c(0,1)) +
    #geom_point(alpha=.4) + 
    geom_point() +
    xlab("\nslope") +
    ylab("R2") +
    theme_classic() +
    scale_color_manual(values=c("grey82", "grey32", "violetred2", "chartreuse3")) +
    theme(axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          legend.position="bottom", 
          legend.title = element_blank(),
          text = element_text(size=12), 
          legend.text=element_text(size=12), 
          axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
ggsave(file = "plots/shuff_lm1_allcells.png", width = 4, height = 5)
```



### ----------------------------------------------------------------------------------------- ###

## Identification of ramp cells in dataset (Beaconed trials)

Ramp like cells are identified by whether the coefficients of the linear model lie outside the 95% confidence intervals of the same result from 1000 shuffled datasets


1. Write function to run linear model
```{r}
lm_helper <- function(df){
  if(all(is.na(df))) 
    return(0)
  df_mod <- lm(Rates ~ Position, data = df, na.action=na.exclude)
}
```

2. write function to generate 1000 shuffles
- shuffles spikes using sample() function
- runs lm
- extracts coefficients
- stores coefficients for each 1000 shuffles (less memory than saving 1000 shuffles)
```{r}
#library(gdata)
shuffle_rates <- function(df) {
  df_modified <- data.frame(neuron=as.numeric(),
                 slope=as.numeric(), 
                 rsquared=as.numeric(), 
                 pval=vector())
  names(df_modified) <- c("neuron", "slope", "rsquared", "pval")
  x <- 1
  repeat {
  shuff_df <- tibble(Rates = sample(as.vector(unlist(df)),replace = TRUE, prob = NULL), Position = c(1:200))
  shuff_df <- subset(shuff_df, Position >=30 & Position <=90)
  df_mod <- lm_helper(shuff_df)
  rsquared <- glance(df_mod)$r.squared
  pval<- glance(df_mod)$p.value
  slope <- coefficients(df_mod)[2] # slope
  data <- data.frame(as.numeric(x), slope, rsquared, round(pval,5))
  names(data) <- c("neuron", "slope", "rsquared", "pval")
  df_modified <- rbind(df_modified,data)

  x = x+1
  if (x == 1000){
  break
  }
  }
return(df_modified)
}
```

3. Run on example neuron (beaconed and non-beaconed trials)
```{r}

spatial_firing <- spatial_firing %>%
  #mutate(shuffle_results = map(Rates_averaged_rewarded_b, shuffle_rates)) %>%
  #mutate(shuffle_results_nb = map(Rates_averaged_rewarded_nb, shuffle_rates)) %>%
  mutate(shuffle_results_p = map(Rates_averaged_p, shuffle_rates)) 

```

