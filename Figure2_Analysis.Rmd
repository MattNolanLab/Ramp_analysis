---
title: "RampCodes_Figure2"
author: "Sarah Tennant & Matt Nolan"
date: "20/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```





### ------------------------------------------------------------------------------------------ ### 

## Do ramping neurons encode speed, position or acceleration?

### ------------------------------------------------------------------------------------------ ### 

### Plot model selection results performed in Figure1_Analysis.Rmd

First for all cells. 

1. Split data by linear model result
```{r}
# extracting diff models 
pos <-subset(spatial_firing, lm_group_b == "Positive")
neg <-subset(spatial_firing, lm_group_b == "Negative")
none <-subset(spatial_firing, lm_group_b == "Unclassified")

```

2. Split data by mixed effect model result
```{r}

P_positive <- nrow(subset(pos, final_model_o_b == "P"))/nrow(pos)*100
P_negative <- nrow(subset(neg, final_model_o_b == "P"))/nrow(neg)*100
P_none <- nrow(subset(none,final_model_o_b == "P"))/nrow(none)*100

S_positive <- nrow(subset(pos,final_model_o_b == "S"))/nrow(pos)*100
S_negative <- nrow(subset(neg,final_model_o_b == "S"))/nrow(neg)*100
S_none <- nrow(subset(none,final_model_o_b == "S"))/nrow(none)*100

A_positive <- nrow(subset(pos,final_model_o_b == "A"))/nrow(pos)*100
A_negative <- nrow(subset(neg,final_model_o_b == "A"))/nrow(neg)*100
A_none <- nrow(subset(none,final_model_o_b == "A"))/nrow(none)*100

P_S_positive <- nrow(subset(pos,final_model_o_b == "PS"))/nrow(pos)*100
P_S_negative <- nrow(subset(neg,final_model_o_b == "PS"))/nrow(neg)*100
P_S_none <- nrow(subset(none,final_model_o_b == "PS"))/nrow(none)*100

P_A_positive <- nrow(subset(pos ,final_model_o_b == "PA"))/nrow(pos)*100
P_A_negative <- nrow(subset(neg ,final_model_o_b == "PA"))/nrow(neg)*100
P_A_none <- nrow(subset(none,final_model_o_b == "PA"))/nrow(none)*100

S_A_positive <- nrow(subset(pos ,final_model_o_b == "SA"))/nrow(pos)*100
S_A_negative <- nrow(subset(neg ,final_model_o_b == "SA"))/nrow(neg)*100
S_A_none <- nrow(subset(none,final_model_o_b == "SA"))/nrow(none)*100

P_S_A_positive <- nrow(subset(pos ,final_model_o_b == "PSA"))/nrow(pos)*100
P_S_A_negative <- nrow(subset(neg ,final_model_o_b == "PSA"))/nrow(neg)*100
P_S_A_none <- nrow(subset(none ,final_model_o_b == "PSA"))/nrow(none)*100

NONE_positive <- nrow(subset(pos ,final_model_o_b == "None"))/nrow(pos)*100
NONE_negative <- nrow(subset(neg ,final_model_o_b == "None"))/nrow(neg)*100
NONE_none <- nrow(subset(none ,final_model_o_b == "None"))/nrow(none)*100


```

2. number of cells in each group - positive sloping neurons
```{r}
P_positive_num <- nrow(subset(pos, final_model_o_b == "P"))
P_A_positive_num <- nrow(subset(pos, final_model_o_b == "PA"))
P_S_positive_num <- nrow(subset(pos, final_model_o_b == "PS"))
P_S_A_positive_num <- nrow(subset(pos, final_model_o_b == "PSA"))
S_A_positive_num <- nrow(subset(pos, final_model_o_b == "SA"))
S_positive_num <- nrow(subset(pos, final_model_o_b == "S"))
A_positive_num <- nrow(subset(pos, final_model_o_b == "A"))
NONE_positive_num <- nrow(subset(pos, final_model_o_b == "None"))

```

3. number of cells in each group - negative sloping neurons
```{r}
P_negative_num <- nrow(subset(neg, final_model_o_b == "P"))
P_A_negative_num <- nrow(subset(neg, final_model_o_b == "PA"))
P_S_negative_num <- nrow(subset(neg, final_model_o_b == "PS"))
P_S_A_negative_num <- nrow(subset(neg, final_model_o_b == "PSA"))
S_A_negative_num <- nrow(subset(neg, final_model_o_b == "SA"))
S_negative_num <- nrow(subset(neg, final_model_o_b == "S"))
A_negative_num <- nrow(subset(neg, final_model_o_b == "A"))
NONE_negative_num <- nrow(subset(neg, final_model_o_b == "None"))

```

3. number of cells in each group - unclassified  neurons
```{r}
P_none_num <- nrow(subset(none, final_model_o_b == "P"))
P_A_none_num <- nrow(subset(none, final_model_o_b == "PA"))
P_S_none_num <- nrow(subset(none, final_model_o_b == "PS"))
P_S_A_none_num <- nrow(subset(none, final_model_o_b == "PSA"))
S_A_none_num <- nrow(subset(none, final_model_o_b == "SA"))
S_none_num <- nrow(subset(none, final_model_o_b == "S"))
A_none_num <- nrow(subset(none, final_model_o_b == "A"))
NONE_none_num <- nrow(subset(none, final_model_o_b == "None"))

```

3. Put data into tibble
```{r}

mixed_ramps <- tibble(perc=c(P_positive,P_negative,P_none,S_positive, S_negative, S_none, A_positive,A_negative,A_none,  P_S_positive, P_S_negative,P_S_none, P_A_positive, P_A_negative, P_A_none, S_A_positive, S_A_negative, S_A_none,P_S_A_positive, P_S_A_negative, P_S_A_none, NONE_positive,NONE_negative, NONE_none), 
                      num=c(P_positive_num,P_negative_num,P_none_num,S_positive_num, S_negative_num, S_none_num, A_positive_num,A_negative_num,A_none_num,  P_S_positive_num, P_S_negative_num,P_S_none_num, P_A_positive_num, P_A_negative_num, P_A_none_num, S_A_positive_num, S_A_negative_num, S_A_none_num,P_S_A_positive_num, P_S_A_negative_num, P_S_A_none_num, NONE_positive_num,NONE_negative_num, NONE_none_num),
                      
                      ramp_id= c("P","P","P", 
                                 "S", "S", "S", 
                                 "A", "A", "A",
                                 "PS", "PS", "PS", 
                                 "PA", "PA", "PA", 
                                 "SA", "SA", "SA", 
                                 "PAS", "PAS","PAS",
                                 "None","None", "None"), 
                      ramp_type= c("Positive", "Negative", "Unclassified","Positive", "Negative", "Unclassified", "Positive", "Negative", "Unclassified","Positive", "Negative" ,"Unclassified","Positive", "Negative","Unclassified","Positive", "Negative","Unclassified", "Positive", "Negative", "Unclassified", "Positive", "Negative", "Unclassified" ))

```

4. Plot model results
```{r}
# plot data
level_order <- c("P", "S", "A", "PS", "PA","SA", "PAS", "None")
ggplot(mixed_ramps, aes(x= factor(ramp_type), y = perc, fill=factor(ramp_id, level = level_order))) +
  geom_bar(stat="identity",width = 0.9, alpha = .7) +
  labs(y = "Percent of neurons", x="") +
  scale_fill_manual(values=c("firebrick1","gold", "dodgerblue2", "darkorange", "darkorchid1", "chartreuse3", "darkslategray", "grey78")) +
  geom_text(aes(label = num), hjust = 0.7, vjust = 0.2, size = 5, position = position_stack(vjust= 0.5)) +
  #scale_fill_brewer(palette= "RdYlBu") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 50, vjust=0.65)) +
  theme(axis.text.x = element_text(size=17),
        axis.text.y = element_text(size=16),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=16), 
        legend.text=element_text(size=16), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)))
if (save_figures == 1) {
  ggsave(file = "plots/LMERProportions_beaconed_update.png", width = 4, height = 5.5)
}
```




### plot distribution of coefficients for all cells
_split by positive and negative sloping neurons_

1. make unique id for each neuron (session_id + cluster_id)
```{r}
# First make a function to concatenate session id and cluster id
make_unique_id <- function(session,cluster) {
  x <- paste(session, cluster, sep="_")
  return(as.character(x))
}

# run on all cells
spatial_firing <- spatial_firing  %>%
  mutate(unique_id = map2(session_id, cluster_id, make_unique_id))

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save <- select(spatial_firing, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

```

3. save to csv file _this is for matching the coefficient values to plots of instantaneous rates from python_
```{r}
write_csv2(spatial_firing_save, "data_out/all_results_coefficients.csv")
```

4. put data into a tibble for plotting
```{r}
data_coef <- tibble(session_id = rep(unlist(spatial_firing_save$unique_id), times=3), 
                    cluster_id = rep(spatial_firing_save$cluster_id, times=3), 
                    coef = c(as.character(spatial_firing_save$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b),
                              as.character(spatial_firing_save$final_model_o_b)), 
                    # cue_group = c(as.character(spatial_firing_save$cue_group_o),
                    #            as.character(spatial_firing_save$cue_group_o),
                    #            as.character(spatial_firing_save$cue_group_o)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save)),
                    lm_result = rep(as.character(spatial_firing_save$lm_group_b), times=3))
```

_Plot coefficients for all cells_

Make function for plotting standardised coefficients
```{r}
standard_plot <- function(df) {
  level_order <- c("P", "S", "A")
  ggplot(data=df, aes(x = factor(coef_type), y = as.numeric(coef))) +
  geom_violin(aes(x = factor(coef_type), y = as.numeric(coef), fill=factor(coef_type, level=level_order)), alpha=0.7) +
  stat_summary(fun.y=mean, geom="point", shape=23, size=2) +
  geom_jitter(alpha=0.05) +
  scale_fill_manual(values=c("firebrick1","gold","dodgerblue2")) +
  labs(y = "std coef", x="\n model parameter") +
  #scale_y_continuous(breaks=c(0,0.5, 1, 4)) +
  scale_y_continuous(trans=pseudolog10_trans) +
  #coord_trans(y='log2', x=) +
  theme_classic() +
  theme(axis.text.x = element_text(size=14),
        axis.text.y = element_text(size=12),
        legend.position="bottom", 
        legend.title = element_blank(),
        text = element_text(size=12), 
        legend.text=element_text(size=12), 
        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))) 
}
```



5. Split by positive slope _all cells_
```{r}
data_coef_pos <- data_coef %>%
  subset(lm_result == "Positive" )

(pos_coef_plot <- standard_plot(data_coef_pos))
if (save_figures == 1) {
   ggsave(file = "plots/CoefficientValues_positivecells.png", width = 3, height = 2.5)
}
```

5. Split by negative slope _all cells_
```{r}
data_coef_neg <- data_coef %>%
  subset(lm_result == "Negative" )

(neg_coef_plot <- standard_plot(data_coef_neg))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_negativecells.png", width = 3, height = 2.5)
}
```

_Plot coefficients for all cells_

5. Split by positive slope _PS cells_
```{r}
data_coef_pos_PS <- data_coef %>%
  subset(group == "PS") %>%
  subset(lm_result == "Positive" )

(pos_PS_coef_plot <- standard_plot(data_coef_pos_PS))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositivePScells.png", width = 3, height = 2.5)
}
```

6. Split by negative slope
```{r}
data_coef_neg_PS <- data_coef %>%
  subset(group == "PS") %>%
  subset(lm_result == "Negative" )

(neg_PS_coef_plot <- standard_plot(data_coef_neg_PS))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativePScells.png", width = 3, height = 2.5)
}
```


_Plot coefficients for just position cells_


6a. Plot coefficients for cells classified in Figure 2 as having a positive slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_pos_P <- data_coef %>%
  subset(group == "P") %>%
  subset(lm_result == "Positive")

(pos_P_coef_plot <- standard_plot(data_coef_pos_P))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositivePcells.png", width = 3, height = 2.5)
}
```



6b. Plot coefficients for cells classified in Figure 2 as having a negative slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_neg_P <- data_coef %>%
  subset(group == "P") %>%
  subset(lm_result == "Negative")

(neg_P_coef_plot <- standard_plot(data_coef_neg_P))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativePcells.png", width = 3, height = 2.5)
}
```


_Plot coefficients for just position cells_


6a. Plot coefficients for cells classified in Figure 2 as having a positive slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_pos_SA <- data_coef %>%
  subset(group == "SA") %>%
  subset(lm_result == "Positive")

(pos_SA_coef_plot <- standard_plot(data_coef_pos_SA))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_PositiveSAcells.png", width = 3, height = 2.5)
}
```



6b. Plot coefficients for cells classified in Figure 2 as having a negative slope and in Figure 3 as having significant fit coefficients for position only.

```{r}
data_coef_neg_SA <- data_coef %>%
  subset(group == "SA") %>%
  subset(lm_result == "Negative")

(neg_SA_coef_plot <- standard_plot(data_coef_neg_SA))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_NegativeSAcells.png", width = 3, height = 2.5)
}
```

6c. Plot coefficients for cells classified in Figure 2 as being unclassified but that have 'significant' positional coefficients in the mixed effect model.

```{r}
data_coef_UC_PSA <- data_coef %>%
  subset(group == "P" | group == "PS" | group == "PA" | group == "PSA") %>%
  subset(lm_result == "Unclassified")

(UC_PSA_coef_plot <- standard_plot(data_coef_UC_PSA))
if (save_figures == 1) {
  ggsave(file = "plots/CoefficientValues_UCPSAcells.png", width = 3, height = 2.5)
}
```




###----------------------------------------------------------------------------###

Statistical analyses to compare coefficients for position, speed and acceleration.

1. Take only 
```{r}
position_cells <- subset(spatial_firing, final_model_o_b == "P" | final_model_o_b == "PS" | final_model_o_b == "PA" | final_model_o_b == "PSA")
```

```{r}
pos_position_cells <- subset(spatial_firing, lm_group_b == "Positive")
neg_position_cells <- subset(spatial_firing, lm_group_b == "Negative")

```

2. take only columns we need for the rest of the analysis
```{r}
spatial_firing_save_p <- select(pos_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()

spatial_firing_save_n <- select(neg_position_cells, session_id, cluster_id, unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel, final_model_o_b, lm_group_b) %>%
  unnest(cols = c(unique_id, o_b_mod_coefs_pos, o_b_mod_coefs_speed, o_b_mod_coefs_accel,
    final_model_o_b, lm_group_b)) %>%
  as.tibble()
```

1. put data into a tibble for plotting
```{r}

data_coef_p <- tibble(session_id = rep(unlist(spatial_firing_save_p$unique_id), times=3),
                    cluster_id = rep(spatial_firing_save_p$cluster_id, times=3),

                    coef = c(as.character(spatial_firing_save_p$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save_p$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save_p$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save_p$final_model_o_b),
                              as.character(spatial_firing_save_p$final_model_o_b),
                              as.character(spatial_firing_save_p$final_model_o_b)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save_p)),
                    lm_result = rep(as.character(spatial_firing_save_p$lm_group_b), times=3))

data_coef_n <- tibble(session_id = rep(unlist(spatial_firing_save_n$unique_id), times=3),
                    cluster_id = rep(spatial_firing_save_n$cluster_id, times=3),
                    coef = c(as.character(spatial_firing_save_n$o_b_mod_coefs_pos),
                             as.character(spatial_firing_save_n$o_b_mod_coefs_speed),
                             as.character(spatial_firing_save_n$o_b_mod_coefs_accel)),
                    group = c(as.character(spatial_firing_save_n$final_model_o_b),
                              as.character(spatial_firing_save_n$final_model_o_b),
                              as.character(spatial_firing_save_n$final_model_o_b)),
                    coef_type = rep(c("P", "S", "A"),
                                    each = nrow(spatial_firing_save_n)),
                    lm_result = rep(as.character(spatial_firing_save_n$lm_group_b), times=3))
```

2. run anova
```{r}
one.way_p <- aov(coef ~ coef_type, data = data_coef_p)

summary(one.way_p)

one.way_n <- aov(coef ~ coef_type, data = data_coef_n)

summary(one.way_n)
```

3. Post hoc Tukey's test
```{r}
tukey.test_p <- TukeyHSD(one.way_p)
tukey.test_p$coef_type

tukey.test_n <- TukeyHSD(one.way_n)
tukey.test_n$coef_type
```

